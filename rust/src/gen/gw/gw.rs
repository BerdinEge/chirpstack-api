// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `gw/gw.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct UplinkTXInfo {
    // message fields
    pub frequency: u32,
    pub modulation: super::common::Modulation,
    // message oneof groups
    pub modulation_info: ::std::option::Option<UplinkTXInfo_oneof_modulation_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UplinkTXInfo {
    fn default() -> &'a UplinkTXInfo {
        <UplinkTXInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UplinkTXInfo_oneof_modulation_info {
    lora_modulation_info(LoRaModulationInfo),
    fsk_modulation_info(FSKModulationInfo),
}

impl UplinkTXInfo {
    pub fn new() -> UplinkTXInfo {
        ::std::default::Default::default()
    }

    // uint32 frequency = 1;


    pub fn get_frequency(&self) -> u32 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = v;
    }

    // .common.Modulation modulation = 2;


    pub fn get_modulation(&self) -> super::common::Modulation {
        self.modulation
    }
    pub fn clear_modulation(&mut self) {
        self.modulation = super::common::Modulation::LORA;
    }

    // Param is passed by value, moved
    pub fn set_modulation(&mut self, v: super::common::Modulation) {
        self.modulation = v;
    }

    // .gw.LoRaModulationInfo lora_modulation_info = 3;


    pub fn get_lora_modulation_info(&self) -> &LoRaModulationInfo {
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v)) => v,
            _ => LoRaModulationInfo::default_instance(),
        }
    }
    pub fn clear_lora_modulation_info(&mut self) {
        self.modulation_info = ::std::option::Option::None;
    }

    pub fn has_lora_modulation_info(&self) -> bool {
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lora_modulation_info(&mut self, v: LoRaModulationInfo) {
        self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lora_modulation_info(&mut self) -> &mut LoRaModulationInfo {
        if let ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(_)) = self.modulation_info {
        } else {
            self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(LoRaModulationInfo::new()));
        }
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lora_modulation_info(&mut self) -> LoRaModulationInfo {
        if self.has_lora_modulation_info() {
            match self.modulation_info.take() {
                ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(v)) => v,
                _ => panic!(),
            }
        } else {
            LoRaModulationInfo::new()
        }
    }

    // .gw.FSKModulationInfo fsk_modulation_info = 4;


    pub fn get_fsk_modulation_info(&self) -> &FSKModulationInfo {
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v)) => v,
            _ => FSKModulationInfo::default_instance(),
        }
    }
    pub fn clear_fsk_modulation_info(&mut self) {
        self.modulation_info = ::std::option::Option::None;
    }

    pub fn has_fsk_modulation_info(&self) -> bool {
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fsk_modulation_info(&mut self, v: FSKModulationInfo) {
        self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fsk_modulation_info(&mut self) -> &mut FSKModulationInfo {
        if let ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(_)) = self.modulation_info {
        } else {
            self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(FSKModulationInfo::new()));
        }
        match self.modulation_info {
            ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fsk_modulation_info(&mut self) -> FSKModulationInfo {
        if self.has_fsk_modulation_info() {
            match self.modulation_info.take() {
                ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(v)) => v,
                _ => panic!(),
            }
        } else {
            FSKModulationInfo::new()
        }
    }
}

impl ::protobuf::Message for UplinkTXInfo {
    fn is_initialized(&self) -> bool {
        if let Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v)) = self.modulation_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v)) = self.modulation_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.modulation, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::lora_modulation_info(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_info = ::std::option::Option::Some(UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.modulation != super::common::Modulation::LORA {
            my_size += ::protobuf::rt::enum_size(2, self.modulation);
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_info {
            match v {
                &UplinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.frequency != 0 {
            os.write_uint32(1, self.frequency)?;
        }
        if self.modulation != super::common::Modulation::LORA {
            os.write_enum(2, self.modulation.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_info {
            match v {
                &UplinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UplinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UplinkTXInfo {
        UplinkTXInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    |m: &UplinkTXInfo| { &m.frequency },
                    |m: &mut UplinkTXInfo| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Modulation>>(
                    "modulation",
                    |m: &UplinkTXInfo| { &m.modulation },
                    |m: &mut UplinkTXInfo| { &mut m.modulation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LoRaModulationInfo>(
                    "lora_modulation_info",
                    UplinkTXInfo::has_lora_modulation_info,
                    UplinkTXInfo::get_lora_modulation_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FSKModulationInfo>(
                    "fsk_modulation_info",
                    UplinkTXInfo::has_fsk_modulation_info,
                    UplinkTXInfo::get_fsk_modulation_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UplinkTXInfo>(
                    "UplinkTXInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UplinkTXInfo {
        static mut instance: ::protobuf::lazy::Lazy<UplinkTXInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UplinkTXInfo,
        };
        unsafe {
            instance.get(UplinkTXInfo::new)
        }
    }
}

impl ::protobuf::Clear for UplinkTXInfo {
    fn clear(&mut self) {
        self.frequency = 0;
        self.modulation = super::common::Modulation::LORA;
        self.modulation_info = ::std::option::Option::None;
        self.modulation_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UplinkTXInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UplinkTXInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoRaModulationInfo {
    // message fields
    pub bandwidth: u32,
    pub spreading_factor: u32,
    pub code_rate: ::std::string::String,
    pub polarization_inversion: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoRaModulationInfo {
    fn default() -> &'a LoRaModulationInfo {
        <LoRaModulationInfo as ::protobuf::Message>::default_instance()
    }
}

impl LoRaModulationInfo {
    pub fn new() -> LoRaModulationInfo {
        ::std::default::Default::default()
    }

    // uint32 bandwidth = 1;


    pub fn get_bandwidth(&self) -> u32 {
        self.bandwidth
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = v;
    }

    // uint32 spreading_factor = 2;


    pub fn get_spreading_factor(&self) -> u32 {
        self.spreading_factor
    }
    pub fn clear_spreading_factor(&mut self) {
        self.spreading_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_spreading_factor(&mut self, v: u32) {
        self.spreading_factor = v;
    }

    // string code_rate = 3;


    pub fn get_code_rate(&self) -> &str {
        &self.code_rate
    }
    pub fn clear_code_rate(&mut self) {
        self.code_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_rate(&mut self, v: ::std::string::String) {
        self.code_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_rate(&mut self) -> &mut ::std::string::String {
        &mut self.code_rate
    }

    // Take field
    pub fn take_code_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_rate, ::std::string::String::new())
    }

    // bool polarization_inversion = 4;


    pub fn get_polarization_inversion(&self) -> bool {
        self.polarization_inversion
    }
    pub fn clear_polarization_inversion(&mut self) {
        self.polarization_inversion = false;
    }

    // Param is passed by value, moved
    pub fn set_polarization_inversion(&mut self, v: bool) {
        self.polarization_inversion = v;
    }
}

impl ::protobuf::Message for LoRaModulationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bandwidth = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spreading_factor = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_rate)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.polarization_inversion = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spreading_factor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.spreading_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.code_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code_rate);
        }
        if self.polarization_inversion != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bandwidth != 0 {
            os.write_uint32(1, self.bandwidth)?;
        }
        if self.spreading_factor != 0 {
            os.write_uint32(2, self.spreading_factor)?;
        }
        if !self.code_rate.is_empty() {
            os.write_string(3, &self.code_rate)?;
        }
        if self.polarization_inversion != false {
            os.write_bool(4, self.polarization_inversion)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoRaModulationInfo {
        LoRaModulationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bandwidth",
                    |m: &LoRaModulationInfo| { &m.bandwidth },
                    |m: &mut LoRaModulationInfo| { &mut m.bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spreading_factor",
                    |m: &LoRaModulationInfo| { &m.spreading_factor },
                    |m: &mut LoRaModulationInfo| { &mut m.spreading_factor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code_rate",
                    |m: &LoRaModulationInfo| { &m.code_rate },
                    |m: &mut LoRaModulationInfo| { &mut m.code_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "polarization_inversion",
                    |m: &LoRaModulationInfo| { &m.polarization_inversion },
                    |m: &mut LoRaModulationInfo| { &mut m.polarization_inversion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoRaModulationInfo>(
                    "LoRaModulationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoRaModulationInfo {
        static mut instance: ::protobuf::lazy::Lazy<LoRaModulationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoRaModulationInfo,
        };
        unsafe {
            instance.get(LoRaModulationInfo::new)
        }
    }
}

impl ::protobuf::Clear for LoRaModulationInfo {
    fn clear(&mut self) {
        self.bandwidth = 0;
        self.spreading_factor = 0;
        self.code_rate.clear();
        self.polarization_inversion = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoRaModulationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoRaModulationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FSKModulationInfo {
    // message fields
    pub bandwidth: u32,
    pub bitrate: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FSKModulationInfo {
    fn default() -> &'a FSKModulationInfo {
        <FSKModulationInfo as ::protobuf::Message>::default_instance()
    }
}

impl FSKModulationInfo {
    pub fn new() -> FSKModulationInfo {
        ::std::default::Default::default()
    }

    // uint32 bandwidth = 1;


    pub fn get_bandwidth(&self) -> u32 {
        self.bandwidth
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = v;
    }

    // uint32 bitrate = 2;


    pub fn get_bitrate(&self) -> u32 {
        self.bitrate
    }
    pub fn clear_bitrate(&mut self) {
        self.bitrate = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: u32) {
        self.bitrate = v;
    }
}

impl ::protobuf::Message for FSKModulationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bandwidth = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bitrate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bitrate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bitrate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bandwidth != 0 {
            os.write_uint32(1, self.bandwidth)?;
        }
        if self.bitrate != 0 {
            os.write_uint32(2, self.bitrate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FSKModulationInfo {
        FSKModulationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bandwidth",
                    |m: &FSKModulationInfo| { &m.bandwidth },
                    |m: &mut FSKModulationInfo| { &mut m.bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bitrate",
                    |m: &FSKModulationInfo| { &m.bitrate },
                    |m: &mut FSKModulationInfo| { &mut m.bitrate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FSKModulationInfo>(
                    "FSKModulationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FSKModulationInfo {
        static mut instance: ::protobuf::lazy::Lazy<FSKModulationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FSKModulationInfo,
        };
        unsafe {
            instance.get(FSKModulationInfo::new)
        }
    }
}

impl ::protobuf::Clear for FSKModulationInfo {
    fn clear(&mut self) {
        self.bandwidth = 0;
        self.bitrate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FSKModulationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FSKModulationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptedFineTimestamp {
    // message fields
    pub aes_key_index: u32,
    pub encrypted_ns: ::std::vec::Vec<u8>,
    pub fpga_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptedFineTimestamp {
    fn default() -> &'a EncryptedFineTimestamp {
        <EncryptedFineTimestamp as ::protobuf::Message>::default_instance()
    }
}

impl EncryptedFineTimestamp {
    pub fn new() -> EncryptedFineTimestamp {
        ::std::default::Default::default()
    }

    // uint32 aes_key_index = 1;


    pub fn get_aes_key_index(&self) -> u32 {
        self.aes_key_index
    }
    pub fn clear_aes_key_index(&mut self) {
        self.aes_key_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_aes_key_index(&mut self, v: u32) {
        self.aes_key_index = v;
    }

    // bytes encrypted_ns = 2;


    pub fn get_encrypted_ns(&self) -> &[u8] {
        &self.encrypted_ns
    }
    pub fn clear_encrypted_ns(&mut self) {
        self.encrypted_ns.clear();
    }

    // Param is passed by value, moved
    pub fn set_encrypted_ns(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_ns = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_ns(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encrypted_ns
    }

    // Take field
    pub fn take_encrypted_ns(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encrypted_ns, ::std::vec::Vec::new())
    }

    // bytes fpga_id = 3;


    pub fn get_fpga_id(&self) -> &[u8] {
        &self.fpga_id
    }
    pub fn clear_fpga_id(&mut self) {
        self.fpga_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_fpga_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.fpga_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fpga_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fpga_id
    }

    // Take field
    pub fn take_fpga_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fpga_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptedFineTimestamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.aes_key_index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encrypted_ns)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fpga_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.aes_key_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.aes_key_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encrypted_ns.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.encrypted_ns);
        }
        if !self.fpga_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.fpga_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.aes_key_index != 0 {
            os.write_uint32(1, self.aes_key_index)?;
        }
        if !self.encrypted_ns.is_empty() {
            os.write_bytes(2, &self.encrypted_ns)?;
        }
        if !self.fpga_id.is_empty() {
            os.write_bytes(3, &self.fpga_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedFineTimestamp {
        EncryptedFineTimestamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "aes_key_index",
                    |m: &EncryptedFineTimestamp| { &m.aes_key_index },
                    |m: &mut EncryptedFineTimestamp| { &mut m.aes_key_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encrypted_ns",
                    |m: &EncryptedFineTimestamp| { &m.encrypted_ns },
                    |m: &mut EncryptedFineTimestamp| { &mut m.encrypted_ns },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "fpga_id",
                    |m: &EncryptedFineTimestamp| { &m.fpga_id },
                    |m: &mut EncryptedFineTimestamp| { &mut m.fpga_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncryptedFineTimestamp>(
                    "EncryptedFineTimestamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptedFineTimestamp {
        static mut instance: ::protobuf::lazy::Lazy<EncryptedFineTimestamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncryptedFineTimestamp,
        };
        unsafe {
            instance.get(EncryptedFineTimestamp::new)
        }
    }
}

impl ::protobuf::Clear for EncryptedFineTimestamp {
    fn clear(&mut self) {
        self.aes_key_index = 0;
        self.encrypted_ns.clear();
        self.fpga_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedFineTimestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedFineTimestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlainFineTimestamp {
    // message fields
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlainFineTimestamp {
    fn default() -> &'a PlainFineTimestamp {
        <PlainFineTimestamp as ::protobuf::Message>::default_instance()
    }
}

impl PlainFineTimestamp {
    pub fn new() -> PlainFineTimestamp {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 1;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for PlainFineTimestamp {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlainFineTimestamp {
        PlainFineTimestamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "time",
                    |m: &PlainFineTimestamp| { &m.time },
                    |m: &mut PlainFineTimestamp| { &mut m.time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlainFineTimestamp>(
                    "PlainFineTimestamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlainFineTimestamp {
        static mut instance: ::protobuf::lazy::Lazy<PlainFineTimestamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlainFineTimestamp,
        };
        unsafe {
            instance.get(PlainFineTimestamp::new)
        }
    }
}

impl ::protobuf::Clear for PlainFineTimestamp {
    fn clear(&mut self) {
        self.time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlainFineTimestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlainFineTimestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GatewayStats {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub ip: ::std::string::String,
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub location: ::protobuf::SingularPtrField<super::common::Location>,
    pub config_version: ::std::string::String,
    pub rx_packets_received: u32,
    pub rx_packets_received_ok: u32,
    pub tx_packets_received: u32,
    pub tx_packets_emitted: u32,
    pub meta_data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub stats_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GatewayStats {
    fn default() -> &'a GatewayStats {
        <GatewayStats as ::protobuf::Message>::default_instance()
    }
}

impl GatewayStats {
    pub fn new() -> GatewayStats {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // string ip = 9;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp time = 2;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .common.Location location = 3;


    pub fn get_location(&self) -> &super::common::Location {
        self.location.as_ref().unwrap_or_else(|| super::common::Location::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: super::common::Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut super::common::Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> super::common::Location {
        self.location.take().unwrap_or_else(|| super::common::Location::new())
    }

    // string config_version = 4;


    pub fn get_config_version(&self) -> &str {
        &self.config_version
    }
    pub fn clear_config_version(&mut self) {
        self.config_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_version(&mut self, v: ::std::string::String) {
        self.config_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_version(&mut self) -> &mut ::std::string::String {
        &mut self.config_version
    }

    // Take field
    pub fn take_config_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.config_version, ::std::string::String::new())
    }

    // uint32 rx_packets_received = 5;


    pub fn get_rx_packets_received(&self) -> u32 {
        self.rx_packets_received
    }
    pub fn clear_rx_packets_received(&mut self) {
        self.rx_packets_received = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets_received(&mut self, v: u32) {
        self.rx_packets_received = v;
    }

    // uint32 rx_packets_received_ok = 6;


    pub fn get_rx_packets_received_ok(&self) -> u32 {
        self.rx_packets_received_ok
    }
    pub fn clear_rx_packets_received_ok(&mut self) {
        self.rx_packets_received_ok = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_packets_received_ok(&mut self, v: u32) {
        self.rx_packets_received_ok = v;
    }

    // uint32 tx_packets_received = 7;


    pub fn get_tx_packets_received(&self) -> u32 {
        self.tx_packets_received
    }
    pub fn clear_tx_packets_received(&mut self) {
        self.tx_packets_received = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets_received(&mut self, v: u32) {
        self.tx_packets_received = v;
    }

    // uint32 tx_packets_emitted = 8;


    pub fn get_tx_packets_emitted(&self) -> u32 {
        self.tx_packets_emitted
    }
    pub fn clear_tx_packets_emitted(&mut self) {
        self.tx_packets_emitted = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_packets_emitted(&mut self, v: u32) {
        self.tx_packets_emitted = v;
    }

    // repeated .gw.GatewayStats.MetaDataEntry meta_data = 10;


    pub fn get_meta_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.meta_data
    }
    pub fn clear_meta_data(&mut self) {
        self.meta_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_meta_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.meta_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_meta_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.meta_data
    }

    // Take field
    pub fn take_meta_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.meta_data, ::std::collections::HashMap::new())
    }

    // bytes stats_id = 11;


    pub fn get_stats_id(&self) -> &[u8] {
        &self.stats_id
    }
    pub fn clear_stats_id(&mut self) {
        self.stats_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.stats_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stats_id
    }

    // Take field
    pub fn take_stats_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stats_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GatewayStats {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.config_version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_packets_received = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_packets_received_ok = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_packets_received = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_packets_emitted = tmp;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.meta_data)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stats_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.ip);
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.config_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.config_version);
        }
        if self.rx_packets_received != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rx_packets_received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_packets_received_ok != 0 {
            my_size += ::protobuf::rt::value_size(6, self.rx_packets_received_ok, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_packets_received != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_packets_received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tx_packets_emitted != 0 {
            my_size += ::protobuf::rt::value_size(8, self.tx_packets_emitted, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.meta_data);
        if !self.stats_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.stats_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.ip.is_empty() {
            os.write_string(9, &self.ip)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.config_version.is_empty() {
            os.write_string(4, &self.config_version)?;
        }
        if self.rx_packets_received != 0 {
            os.write_uint32(5, self.rx_packets_received)?;
        }
        if self.rx_packets_received_ok != 0 {
            os.write_uint32(6, self.rx_packets_received_ok)?;
        }
        if self.tx_packets_received != 0 {
            os.write_uint32(7, self.tx_packets_received)?;
        }
        if self.tx_packets_emitted != 0 {
            os.write_uint32(8, self.tx_packets_emitted)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(10, &self.meta_data, os)?;
        if !self.stats_id.is_empty() {
            os.write_bytes(11, &self.stats_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GatewayStats {
        GatewayStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &GatewayStats| { &m.gateway_id },
                    |m: &mut GatewayStats| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    |m: &GatewayStats| { &m.ip },
                    |m: &mut GatewayStats| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "time",
                    |m: &GatewayStats| { &m.time },
                    |m: &mut GatewayStats| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Location>>(
                    "location",
                    |m: &GatewayStats| { &m.location },
                    |m: &mut GatewayStats| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "config_version",
                    |m: &GatewayStats| { &m.config_version },
                    |m: &mut GatewayStats| { &mut m.config_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_packets_received",
                    |m: &GatewayStats| { &m.rx_packets_received },
                    |m: &mut GatewayStats| { &mut m.rx_packets_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_packets_received_ok",
                    |m: &GatewayStats| { &m.rx_packets_received_ok },
                    |m: &mut GatewayStats| { &mut m.rx_packets_received_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_packets_received",
                    |m: &GatewayStats| { &m.tx_packets_received },
                    |m: &mut GatewayStats| { &mut m.tx_packets_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_packets_emitted",
                    |m: &GatewayStats| { &m.tx_packets_emitted },
                    |m: &mut GatewayStats| { &mut m.tx_packets_emitted },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "meta_data",
                    |m: &GatewayStats| { &m.meta_data },
                    |m: &mut GatewayStats| { &mut m.meta_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stats_id",
                    |m: &GatewayStats| { &m.stats_id },
                    |m: &mut GatewayStats| { &mut m.stats_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GatewayStats>(
                    "GatewayStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GatewayStats {
        static mut instance: ::protobuf::lazy::Lazy<GatewayStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GatewayStats,
        };
        unsafe {
            instance.get(GatewayStats::new)
        }
    }
}

impl ::protobuf::Clear for GatewayStats {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.ip.clear();
        self.time.clear();
        self.location.clear();
        self.config_version.clear();
        self.rx_packets_received = 0;
        self.rx_packets_received_ok = 0;
        self.tx_packets_received = 0;
        self.tx_packets_emitted = 0;
        self.meta_data.clear();
        self.stats_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GatewayStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UplinkRXInfo {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub time_since_gps_epoch: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub rssi: i32,
    pub lora_snr: f64,
    pub channel: u32,
    pub rf_chain: u32,
    pub board: u32,
    pub antenna: u32,
    pub location: ::protobuf::SingularPtrField<super::common::Location>,
    pub fine_timestamp_type: FineTimestampType,
    pub context: ::std::vec::Vec<u8>,
    pub uplink_id: ::std::vec::Vec<u8>,
    // message oneof groups
    pub fine_timestamp: ::std::option::Option<UplinkRXInfo_oneof_fine_timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UplinkRXInfo {
    fn default() -> &'a UplinkRXInfo {
        <UplinkRXInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UplinkRXInfo_oneof_fine_timestamp {
    encrypted_fine_timestamp(EncryptedFineTimestamp),
    plain_fine_timestamp(PlainFineTimestamp),
}

impl UplinkRXInfo {
    pub fn new() -> UplinkRXInfo {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // .google.protobuf.Timestamp time = 2;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Duration time_since_gps_epoch = 3;


    pub fn get_time_since_gps_epoch(&self) -> &::protobuf::well_known_types::Duration {
        self.time_since_gps_epoch.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_time_since_gps_epoch(&mut self) {
        self.time_since_gps_epoch.clear();
    }

    pub fn has_time_since_gps_epoch(&self) -> bool {
        self.time_since_gps_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_since_gps_epoch(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.time_since_gps_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_since_gps_epoch(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.time_since_gps_epoch.is_none() {
            self.time_since_gps_epoch.set_default();
        }
        self.time_since_gps_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_since_gps_epoch(&mut self) -> ::protobuf::well_known_types::Duration {
        self.time_since_gps_epoch.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // int32 rssi = 5;


    pub fn get_rssi(&self) -> i32 {
        self.rssi
    }
    pub fn clear_rssi(&mut self) {
        self.rssi = 0;
    }

    // Param is passed by value, moved
    pub fn set_rssi(&mut self, v: i32) {
        self.rssi = v;
    }

    // double lora_snr = 6;


    pub fn get_lora_snr(&self) -> f64 {
        self.lora_snr
    }
    pub fn clear_lora_snr(&mut self) {
        self.lora_snr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lora_snr(&mut self, v: f64) {
        self.lora_snr = v;
    }

    // uint32 channel = 7;


    pub fn get_channel(&self) -> u32 {
        self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = v;
    }

    // uint32 rf_chain = 8;


    pub fn get_rf_chain(&self) -> u32 {
        self.rf_chain
    }
    pub fn clear_rf_chain(&mut self) {
        self.rf_chain = 0;
    }

    // Param is passed by value, moved
    pub fn set_rf_chain(&mut self, v: u32) {
        self.rf_chain = v;
    }

    // uint32 board = 9;


    pub fn get_board(&self) -> u32 {
        self.board
    }
    pub fn clear_board(&mut self) {
        self.board = 0;
    }

    // Param is passed by value, moved
    pub fn set_board(&mut self, v: u32) {
        self.board = v;
    }

    // uint32 antenna = 10;


    pub fn get_antenna(&self) -> u32 {
        self.antenna
    }
    pub fn clear_antenna(&mut self) {
        self.antenna = 0;
    }

    // Param is passed by value, moved
    pub fn set_antenna(&mut self, v: u32) {
        self.antenna = v;
    }

    // .common.Location location = 11;


    pub fn get_location(&self) -> &super::common::Location {
        self.location.as_ref().unwrap_or_else(|| super::common::Location::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: super::common::Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut super::common::Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> super::common::Location {
        self.location.take().unwrap_or_else(|| super::common::Location::new())
    }

    // .gw.FineTimestampType fine_timestamp_type = 12;


    pub fn get_fine_timestamp_type(&self) -> FineTimestampType {
        self.fine_timestamp_type
    }
    pub fn clear_fine_timestamp_type(&mut self) {
        self.fine_timestamp_type = FineTimestampType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_fine_timestamp_type(&mut self, v: FineTimestampType) {
        self.fine_timestamp_type = v;
    }

    // .gw.EncryptedFineTimestamp encrypted_fine_timestamp = 13;


    pub fn get_encrypted_fine_timestamp(&self) -> &EncryptedFineTimestamp {
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(ref v)) => v,
            _ => EncryptedFineTimestamp::default_instance(),
        }
    }
    pub fn clear_encrypted_fine_timestamp(&mut self) {
        self.fine_timestamp = ::std::option::Option::None;
    }

    pub fn has_encrypted_fine_timestamp(&self) -> bool {
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encrypted_fine_timestamp(&mut self, v: EncryptedFineTimestamp) {
        self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encrypted_fine_timestamp(&mut self) -> &mut EncryptedFineTimestamp {
        if let ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(_)) = self.fine_timestamp {
        } else {
            self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(EncryptedFineTimestamp::new()));
        }
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encrypted_fine_timestamp(&mut self) -> EncryptedFineTimestamp {
        if self.has_encrypted_fine_timestamp() {
            match self.fine_timestamp.take() {
                ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            EncryptedFineTimestamp::new()
        }
    }

    // .gw.PlainFineTimestamp plain_fine_timestamp = 14;


    pub fn get_plain_fine_timestamp(&self) -> &PlainFineTimestamp {
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(ref v)) => v,
            _ => PlainFineTimestamp::default_instance(),
        }
    }
    pub fn clear_plain_fine_timestamp(&mut self) {
        self.fine_timestamp = ::std::option::Option::None;
    }

    pub fn has_plain_fine_timestamp(&self) -> bool {
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plain_fine_timestamp(&mut self, v: PlainFineTimestamp) {
        self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plain_fine_timestamp(&mut self) -> &mut PlainFineTimestamp {
        if let ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(_)) = self.fine_timestamp {
        } else {
            self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(PlainFineTimestamp::new()));
        }
        match self.fine_timestamp {
            ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plain_fine_timestamp(&mut self) -> PlainFineTimestamp {
        if self.has_plain_fine_timestamp() {
            match self.fine_timestamp.take() {
                ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            PlainFineTimestamp::new()
        }
    }

    // bytes context = 15;


    pub fn get_context(&self) -> &[u8] {
        &self.context
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.context = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.context
    }

    // Take field
    pub fn take_context(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.context, ::std::vec::Vec::new())
    }

    // bytes uplink_id = 16;


    pub fn get_uplink_id(&self) -> &[u8] {
        &self.uplink_id
    }
    pub fn clear_uplink_id(&mut self) {
        self.uplink_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_uplink_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.uplink_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uplink_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uplink_id
    }

    // Take field
    pub fn take_uplink_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uplink_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UplinkRXInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_since_gps_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(ref v)) = self.fine_timestamp {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(ref v)) = self.fine_timestamp {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_since_gps_epoch)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rssi = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lora_snr = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rf_chain = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.board = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.antenna = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fine_timestamp_type, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fine_timestamp = ::std::option::Option::Some(UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(is.read_message()?));
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.context)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uplink_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_since_gps_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.rssi != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rssi, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lora_snr != 0. {
            my_size += 9;
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::value_size(7, self.channel, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rf_chain != 0 {
            my_size += ::protobuf::rt::value_size(8, self.rf_chain, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.board != 0 {
            my_size += ::protobuf::rt::value_size(9, self.board, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.antenna != 0 {
            my_size += ::protobuf::rt::value_size(10, self.antenna, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fine_timestamp_type != FineTimestampType::NONE {
            my_size += ::protobuf::rt::enum_size(12, self.fine_timestamp_type);
        }
        if !self.context.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.context);
        }
        if !self.uplink_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.uplink_id);
        }
        if let ::std::option::Option::Some(ref v) = self.fine_timestamp {
            match v {
                &UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_since_gps_epoch.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.rssi != 0 {
            os.write_int32(5, self.rssi)?;
        }
        if self.lora_snr != 0. {
            os.write_double(6, self.lora_snr)?;
        }
        if self.channel != 0 {
            os.write_uint32(7, self.channel)?;
        }
        if self.rf_chain != 0 {
            os.write_uint32(8, self.rf_chain)?;
        }
        if self.board != 0 {
            os.write_uint32(9, self.board)?;
        }
        if self.antenna != 0 {
            os.write_uint32(10, self.antenna)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fine_timestamp_type != FineTimestampType::NONE {
            os.write_enum(12, self.fine_timestamp_type.value())?;
        }
        if !self.context.is_empty() {
            os.write_bytes(15, &self.context)?;
        }
        if !self.uplink_id.is_empty() {
            os.write_bytes(16, &self.uplink_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.fine_timestamp {
            match v {
                &UplinkRXInfo_oneof_fine_timestamp::encrypted_fine_timestamp(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UplinkRXInfo_oneof_fine_timestamp::plain_fine_timestamp(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UplinkRXInfo {
        UplinkRXInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &UplinkRXInfo| { &m.gateway_id },
                    |m: &mut UplinkRXInfo| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "time",
                    |m: &UplinkRXInfo| { &m.time },
                    |m: &mut UplinkRXInfo| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "time_since_gps_epoch",
                    |m: &UplinkRXInfo| { &m.time_since_gps_epoch },
                    |m: &mut UplinkRXInfo| { &mut m.time_since_gps_epoch },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rssi",
                    |m: &UplinkRXInfo| { &m.rssi },
                    |m: &mut UplinkRXInfo| { &mut m.rssi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lora_snr",
                    |m: &UplinkRXInfo| { &m.lora_snr },
                    |m: &mut UplinkRXInfo| { &mut m.lora_snr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel",
                    |m: &UplinkRXInfo| { &m.channel },
                    |m: &mut UplinkRXInfo| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rf_chain",
                    |m: &UplinkRXInfo| { &m.rf_chain },
                    |m: &mut UplinkRXInfo| { &mut m.rf_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "board",
                    |m: &UplinkRXInfo| { &m.board },
                    |m: &mut UplinkRXInfo| { &mut m.board },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "antenna",
                    |m: &UplinkRXInfo| { &m.antenna },
                    |m: &mut UplinkRXInfo| { &mut m.antenna },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Location>>(
                    "location",
                    |m: &UplinkRXInfo| { &m.location },
                    |m: &mut UplinkRXInfo| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FineTimestampType>>(
                    "fine_timestamp_type",
                    |m: &UplinkRXInfo| { &m.fine_timestamp_type },
                    |m: &mut UplinkRXInfo| { &mut m.fine_timestamp_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, EncryptedFineTimestamp>(
                    "encrypted_fine_timestamp",
                    UplinkRXInfo::has_encrypted_fine_timestamp,
                    UplinkRXInfo::get_encrypted_fine_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PlainFineTimestamp>(
                    "plain_fine_timestamp",
                    UplinkRXInfo::has_plain_fine_timestamp,
                    UplinkRXInfo::get_plain_fine_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "context",
                    |m: &UplinkRXInfo| { &m.context },
                    |m: &mut UplinkRXInfo| { &mut m.context },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uplink_id",
                    |m: &UplinkRXInfo| { &m.uplink_id },
                    |m: &mut UplinkRXInfo| { &mut m.uplink_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UplinkRXInfo>(
                    "UplinkRXInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UplinkRXInfo {
        static mut instance: ::protobuf::lazy::Lazy<UplinkRXInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UplinkRXInfo,
        };
        unsafe {
            instance.get(UplinkRXInfo::new)
        }
    }
}

impl ::protobuf::Clear for UplinkRXInfo {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.time.clear();
        self.time_since_gps_epoch.clear();
        self.rssi = 0;
        self.lora_snr = 0.;
        self.channel = 0;
        self.rf_chain = 0;
        self.board = 0;
        self.antenna = 0;
        self.location.clear();
        self.fine_timestamp_type = FineTimestampType::NONE;
        self.fine_timestamp = ::std::option::Option::None;
        self.fine_timestamp = ::std::option::Option::None;
        self.context.clear();
        self.uplink_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UplinkRXInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UplinkRXInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownlinkTXInfo {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub frequency: u32,
    pub power: i32,
    pub modulation: super::common::Modulation,
    pub board: u32,
    pub antenna: u32,
    pub timing: DownlinkTiming,
    pub context: ::std::vec::Vec<u8>,
    // message oneof groups
    pub modulation_info: ::std::option::Option<DownlinkTXInfo_oneof_modulation_info>,
    pub timing_info: ::std::option::Option<DownlinkTXInfo_oneof_timing_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownlinkTXInfo {
    fn default() -> &'a DownlinkTXInfo {
        <DownlinkTXInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DownlinkTXInfo_oneof_modulation_info {
    lora_modulation_info(LoRaModulationInfo),
    fsk_modulation_info(FSKModulationInfo),
}

#[derive(Clone,PartialEq,Debug)]
pub enum DownlinkTXInfo_oneof_timing_info {
    immediately_timing_info(ImmediatelyTimingInfo),
    delay_timing_info(DelayTimingInfo),
    gps_epoch_timing_info(GPSEpochTimingInfo),
}

impl DownlinkTXInfo {
    pub fn new() -> DownlinkTXInfo {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // uint32 frequency = 5;


    pub fn get_frequency(&self) -> u32 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = v;
    }

    // int32 power = 6;


    pub fn get_power(&self) -> i32 {
        self.power
    }
    pub fn clear_power(&mut self) {
        self.power = 0;
    }

    // Param is passed by value, moved
    pub fn set_power(&mut self, v: i32) {
        self.power = v;
    }

    // .common.Modulation modulation = 7;


    pub fn get_modulation(&self) -> super::common::Modulation {
        self.modulation
    }
    pub fn clear_modulation(&mut self) {
        self.modulation = super::common::Modulation::LORA;
    }

    // Param is passed by value, moved
    pub fn set_modulation(&mut self, v: super::common::Modulation) {
        self.modulation = v;
    }

    // .gw.LoRaModulationInfo lora_modulation_info = 8;


    pub fn get_lora_modulation_info(&self) -> &LoRaModulationInfo {
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v)) => v,
            _ => LoRaModulationInfo::default_instance(),
        }
    }
    pub fn clear_lora_modulation_info(&mut self) {
        self.modulation_info = ::std::option::Option::None;
    }

    pub fn has_lora_modulation_info(&self) -> bool {
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lora_modulation_info(&mut self, v: LoRaModulationInfo) {
        self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lora_modulation_info(&mut self) -> &mut LoRaModulationInfo {
        if let ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(_)) = self.modulation_info {
        } else {
            self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(LoRaModulationInfo::new()));
        }
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lora_modulation_info(&mut self) -> LoRaModulationInfo {
        if self.has_lora_modulation_info() {
            match self.modulation_info.take() {
                ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(v)) => v,
                _ => panic!(),
            }
        } else {
            LoRaModulationInfo::new()
        }
    }

    // .gw.FSKModulationInfo fsk_modulation_info = 9;


    pub fn get_fsk_modulation_info(&self) -> &FSKModulationInfo {
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v)) => v,
            _ => FSKModulationInfo::default_instance(),
        }
    }
    pub fn clear_fsk_modulation_info(&mut self) {
        self.modulation_info = ::std::option::Option::None;
    }

    pub fn has_fsk_modulation_info(&self) -> bool {
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fsk_modulation_info(&mut self, v: FSKModulationInfo) {
        self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fsk_modulation_info(&mut self) -> &mut FSKModulationInfo {
        if let ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(_)) = self.modulation_info {
        } else {
            self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(FSKModulationInfo::new()));
        }
        match self.modulation_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fsk_modulation_info(&mut self) -> FSKModulationInfo {
        if self.has_fsk_modulation_info() {
            match self.modulation_info.take() {
                ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(v)) => v,
                _ => panic!(),
            }
        } else {
            FSKModulationInfo::new()
        }
    }

    // uint32 board = 10;


    pub fn get_board(&self) -> u32 {
        self.board
    }
    pub fn clear_board(&mut self) {
        self.board = 0;
    }

    // Param is passed by value, moved
    pub fn set_board(&mut self, v: u32) {
        self.board = v;
    }

    // uint32 antenna = 11;


    pub fn get_antenna(&self) -> u32 {
        self.antenna
    }
    pub fn clear_antenna(&mut self) {
        self.antenna = 0;
    }

    // Param is passed by value, moved
    pub fn set_antenna(&mut self, v: u32) {
        self.antenna = v;
    }

    // .gw.DownlinkTiming timing = 12;


    pub fn get_timing(&self) -> DownlinkTiming {
        self.timing
    }
    pub fn clear_timing(&mut self) {
        self.timing = DownlinkTiming::IMMEDIATELY;
    }

    // Param is passed by value, moved
    pub fn set_timing(&mut self, v: DownlinkTiming) {
        self.timing = v;
    }

    // .gw.ImmediatelyTimingInfo immediately_timing_info = 13;


    pub fn get_immediately_timing_info(&self) -> &ImmediatelyTimingInfo {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ref v)) => v,
            _ => ImmediatelyTimingInfo::default_instance(),
        }
    }
    pub fn clear_immediately_timing_info(&mut self) {
        self.timing_info = ::std::option::Option::None;
    }

    pub fn has_immediately_timing_info(&self) -> bool {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_immediately_timing_info(&mut self, v: ImmediatelyTimingInfo) {
        self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_immediately_timing_info(&mut self) -> &mut ImmediatelyTimingInfo {
        if let ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(_)) = self.timing_info {
        } else {
            self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ImmediatelyTimingInfo::new()));
        }
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_immediately_timing_info(&mut self) -> ImmediatelyTimingInfo {
        if self.has_immediately_timing_info() {
            match self.timing_info.take() {
                ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(v)) => v,
                _ => panic!(),
            }
        } else {
            ImmediatelyTimingInfo::new()
        }
    }

    // .gw.DelayTimingInfo delay_timing_info = 14;


    pub fn get_delay_timing_info(&self) -> &DelayTimingInfo {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(ref v)) => v,
            _ => DelayTimingInfo::default_instance(),
        }
    }
    pub fn clear_delay_timing_info(&mut self) {
        self.timing_info = ::std::option::Option::None;
    }

    pub fn has_delay_timing_info(&self) -> bool {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delay_timing_info(&mut self, v: DelayTimingInfo) {
        self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delay_timing_info(&mut self) -> &mut DelayTimingInfo {
        if let ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(_)) = self.timing_info {
        } else {
            self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(DelayTimingInfo::new()));
        }
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delay_timing_info(&mut self) -> DelayTimingInfo {
        if self.has_delay_timing_info() {
            match self.timing_info.take() {
                ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(v)) => v,
                _ => panic!(),
            }
        } else {
            DelayTimingInfo::new()
        }
    }

    // .gw.GPSEpochTimingInfo gps_epoch_timing_info = 15;


    pub fn get_gps_epoch_timing_info(&self) -> &GPSEpochTimingInfo {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(ref v)) => v,
            _ => GPSEpochTimingInfo::default_instance(),
        }
    }
    pub fn clear_gps_epoch_timing_info(&mut self) {
        self.timing_info = ::std::option::Option::None;
    }

    pub fn has_gps_epoch_timing_info(&self) -> bool {
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gps_epoch_timing_info(&mut self, v: GPSEpochTimingInfo) {
        self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gps_epoch_timing_info(&mut self) -> &mut GPSEpochTimingInfo {
        if let ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(_)) = self.timing_info {
        } else {
            self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(GPSEpochTimingInfo::new()));
        }
        match self.timing_info {
            ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gps_epoch_timing_info(&mut self) -> GPSEpochTimingInfo {
        if self.has_gps_epoch_timing_info() {
            match self.timing_info.take() {
                ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(v)) => v,
                _ => panic!(),
            }
        } else {
            GPSEpochTimingInfo::new()
        }
    }

    // bytes context = 16;


    pub fn get_context(&self) -> &[u8] {
        &self.context
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.context = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.context
    }

    // Take field
    pub fn take_context(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.context, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DownlinkTXInfo {
    fn is_initialized(&self) -> bool {
        if let Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v)) = self.modulation_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v)) = self.modulation_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ref v)) = self.timing_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(ref v)) = self.timing_info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(ref v)) = self.timing_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.power = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.modulation, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.board = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.antenna = tmp;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.timing, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::immediately_timing_info(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::delay_timing_info(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timing_info = ::std::option::Option::Some(DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(is.read_message()?));
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(5, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::value_size(6, self.power, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.modulation != super::common::Modulation::LORA {
            my_size += ::protobuf::rt::enum_size(7, self.modulation);
        }
        if self.board != 0 {
            my_size += ::protobuf::rt::value_size(10, self.board, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.antenna != 0 {
            my_size += ::protobuf::rt::value_size(11, self.antenna, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timing != DownlinkTiming::IMMEDIATELY {
            my_size += ::protobuf::rt::enum_size(12, self.timing);
        }
        if !self.context.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.context);
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_info {
            match v {
                &DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.timing_info {
            match v {
                &DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DownlinkTXInfo_oneof_timing_info::delay_timing_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if self.frequency != 0 {
            os.write_uint32(5, self.frequency)?;
        }
        if self.power != 0 {
            os.write_int32(6, self.power)?;
        }
        if self.modulation != super::common::Modulation::LORA {
            os.write_enum(7, self.modulation.value())?;
        }
        if self.board != 0 {
            os.write_uint32(10, self.board)?;
        }
        if self.antenna != 0 {
            os.write_uint32(11, self.antenna)?;
        }
        if self.timing != DownlinkTiming::IMMEDIATELY {
            os.write_enum(12, self.timing.value())?;
        }
        if !self.context.is_empty() {
            os.write_bytes(16, &self.context)?;
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_info {
            match v {
                &DownlinkTXInfo_oneof_modulation_info::lora_modulation_info(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DownlinkTXInfo_oneof_modulation_info::fsk_modulation_info(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.timing_info {
            match v {
                &DownlinkTXInfo_oneof_timing_info::immediately_timing_info(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DownlinkTXInfo_oneof_timing_info::delay_timing_info(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DownlinkTXInfo_oneof_timing_info::gps_epoch_timing_info(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownlinkTXInfo {
        DownlinkTXInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &DownlinkTXInfo| { &m.gateway_id },
                    |m: &mut DownlinkTXInfo| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    |m: &DownlinkTXInfo| { &m.frequency },
                    |m: &mut DownlinkTXInfo| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "power",
                    |m: &DownlinkTXInfo| { &m.power },
                    |m: &mut DownlinkTXInfo| { &mut m.power },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Modulation>>(
                    "modulation",
                    |m: &DownlinkTXInfo| { &m.modulation },
                    |m: &mut DownlinkTXInfo| { &mut m.modulation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LoRaModulationInfo>(
                    "lora_modulation_info",
                    DownlinkTXInfo::has_lora_modulation_info,
                    DownlinkTXInfo::get_lora_modulation_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FSKModulationInfo>(
                    "fsk_modulation_info",
                    DownlinkTXInfo::has_fsk_modulation_info,
                    DownlinkTXInfo::get_fsk_modulation_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "board",
                    |m: &DownlinkTXInfo| { &m.board },
                    |m: &mut DownlinkTXInfo| { &mut m.board },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "antenna",
                    |m: &DownlinkTXInfo| { &m.antenna },
                    |m: &mut DownlinkTXInfo| { &mut m.antenna },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DownlinkTiming>>(
                    "timing",
                    |m: &DownlinkTXInfo| { &m.timing },
                    |m: &mut DownlinkTXInfo| { &mut m.timing },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImmediatelyTimingInfo>(
                    "immediately_timing_info",
                    DownlinkTXInfo::has_immediately_timing_info,
                    DownlinkTXInfo::get_immediately_timing_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DelayTimingInfo>(
                    "delay_timing_info",
                    DownlinkTXInfo::has_delay_timing_info,
                    DownlinkTXInfo::get_delay_timing_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GPSEpochTimingInfo>(
                    "gps_epoch_timing_info",
                    DownlinkTXInfo::has_gps_epoch_timing_info,
                    DownlinkTXInfo::get_gps_epoch_timing_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "context",
                    |m: &DownlinkTXInfo| { &m.context },
                    |m: &mut DownlinkTXInfo| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownlinkTXInfo>(
                    "DownlinkTXInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownlinkTXInfo {
        static mut instance: ::protobuf::lazy::Lazy<DownlinkTXInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownlinkTXInfo,
        };
        unsafe {
            instance.get(DownlinkTXInfo::new)
        }
    }
}

impl ::protobuf::Clear for DownlinkTXInfo {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.frequency = 0;
        self.power = 0;
        self.modulation = super::common::Modulation::LORA;
        self.modulation_info = ::std::option::Option::None;
        self.modulation_info = ::std::option::Option::None;
        self.board = 0;
        self.antenna = 0;
        self.timing = DownlinkTiming::IMMEDIATELY;
        self.timing_info = ::std::option::Option::None;
        self.timing_info = ::std::option::Option::None;
        self.timing_info = ::std::option::Option::None;
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownlinkTXInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkTXInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmediatelyTimingInfo {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImmediatelyTimingInfo {
    fn default() -> &'a ImmediatelyTimingInfo {
        <ImmediatelyTimingInfo as ::protobuf::Message>::default_instance()
    }
}

impl ImmediatelyTimingInfo {
    pub fn new() -> ImmediatelyTimingInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ImmediatelyTimingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmediatelyTimingInfo {
        ImmediatelyTimingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ImmediatelyTimingInfo>(
                    "ImmediatelyTimingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImmediatelyTimingInfo {
        static mut instance: ::protobuf::lazy::Lazy<ImmediatelyTimingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImmediatelyTimingInfo,
        };
        unsafe {
            instance.get(ImmediatelyTimingInfo::new)
        }
    }
}

impl ::protobuf::Clear for ImmediatelyTimingInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmediatelyTimingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmediatelyTimingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DelayTimingInfo {
    // message fields
    pub delay: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelayTimingInfo {
    fn default() -> &'a DelayTimingInfo {
        <DelayTimingInfo as ::protobuf::Message>::default_instance()
    }
}

impl DelayTimingInfo {
    pub fn new() -> DelayTimingInfo {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration delay = 1;


    pub fn get_delay(&self) -> &::protobuf::well_known_types::Duration {
        self.delay.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_delay(&mut self) {
        self.delay.clear();
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.delay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delay(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.delay.is_none() {
            self.delay.set_default();
        }
        self.delay.as_mut().unwrap()
    }

    // Take field
    pub fn take_delay(&mut self) -> ::protobuf::well_known_types::Duration {
        self.delay.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for DelayTimingInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.delay {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delay)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelayTimingInfo {
        DelayTimingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "delay",
                    |m: &DelayTimingInfo| { &m.delay },
                    |m: &mut DelayTimingInfo| { &mut m.delay },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DelayTimingInfo>(
                    "DelayTimingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DelayTimingInfo {
        static mut instance: ::protobuf::lazy::Lazy<DelayTimingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DelayTimingInfo,
        };
        unsafe {
            instance.get(DelayTimingInfo::new)
        }
    }
}

impl ::protobuf::Clear for DelayTimingInfo {
    fn clear(&mut self) {
        self.delay.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelayTimingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayTimingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GPSEpochTimingInfo {
    // message fields
    pub time_since_gps_epoch: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GPSEpochTimingInfo {
    fn default() -> &'a GPSEpochTimingInfo {
        <GPSEpochTimingInfo as ::protobuf::Message>::default_instance()
    }
}

impl GPSEpochTimingInfo {
    pub fn new() -> GPSEpochTimingInfo {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration time_since_gps_epoch = 1;


    pub fn get_time_since_gps_epoch(&self) -> &::protobuf::well_known_types::Duration {
        self.time_since_gps_epoch.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_time_since_gps_epoch(&mut self) {
        self.time_since_gps_epoch.clear();
    }

    pub fn has_time_since_gps_epoch(&self) -> bool {
        self.time_since_gps_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_since_gps_epoch(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.time_since_gps_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_since_gps_epoch(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.time_since_gps_epoch.is_none() {
            self.time_since_gps_epoch.set_default();
        }
        self.time_since_gps_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_since_gps_epoch(&mut self) -> ::protobuf::well_known_types::Duration {
        self.time_since_gps_epoch.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for GPSEpochTimingInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.time_since_gps_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_since_gps_epoch)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time_since_gps_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time_since_gps_epoch.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GPSEpochTimingInfo {
        GPSEpochTimingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "time_since_gps_epoch",
                    |m: &GPSEpochTimingInfo| { &m.time_since_gps_epoch },
                    |m: &mut GPSEpochTimingInfo| { &mut m.time_since_gps_epoch },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GPSEpochTimingInfo>(
                    "GPSEpochTimingInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GPSEpochTimingInfo {
        static mut instance: ::protobuf::lazy::Lazy<GPSEpochTimingInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GPSEpochTimingInfo,
        };
        unsafe {
            instance.get(GPSEpochTimingInfo::new)
        }
    }
}

impl ::protobuf::Clear for GPSEpochTimingInfo {
    fn clear(&mut self) {
        self.time_since_gps_epoch.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GPSEpochTimingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GPSEpochTimingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UplinkFrame {
    // message fields
    pub phy_payload: ::std::vec::Vec<u8>,
    pub tx_info: ::protobuf::SingularPtrField<UplinkTXInfo>,
    pub rx_info: ::protobuf::SingularPtrField<UplinkRXInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UplinkFrame {
    fn default() -> &'a UplinkFrame {
        <UplinkFrame as ::protobuf::Message>::default_instance()
    }
}

impl UplinkFrame {
    pub fn new() -> UplinkFrame {
        ::std::default::Default::default()
    }

    // bytes phy_payload = 1;


    pub fn get_phy_payload(&self) -> &[u8] {
        &self.phy_payload
    }
    pub fn clear_phy_payload(&mut self) {
        self.phy_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_phy_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.phy_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phy_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.phy_payload
    }

    // Take field
    pub fn take_phy_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.phy_payload, ::std::vec::Vec::new())
    }

    // .gw.UplinkTXInfo tx_info = 2;


    pub fn get_tx_info(&self) -> &UplinkTXInfo {
        self.tx_info.as_ref().unwrap_or_else(|| UplinkTXInfo::default_instance())
    }
    pub fn clear_tx_info(&mut self) {
        self.tx_info.clear();
    }

    pub fn has_tx_info(&self) -> bool {
        self.tx_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_info(&mut self, v: UplinkTXInfo) {
        self.tx_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_info(&mut self) -> &mut UplinkTXInfo {
        if self.tx_info.is_none() {
            self.tx_info.set_default();
        }
        self.tx_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_info(&mut self) -> UplinkTXInfo {
        self.tx_info.take().unwrap_or_else(|| UplinkTXInfo::new())
    }

    // .gw.UplinkRXInfo rx_info = 3;


    pub fn get_rx_info(&self) -> &UplinkRXInfo {
        self.rx_info.as_ref().unwrap_or_else(|| UplinkRXInfo::default_instance())
    }
    pub fn clear_rx_info(&mut self) {
        self.rx_info.clear();
    }

    pub fn has_rx_info(&self) -> bool {
        self.rx_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rx_info(&mut self, v: UplinkRXInfo) {
        self.rx_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rx_info(&mut self) -> &mut UplinkRXInfo {
        if self.rx_info.is_none() {
            self.rx_info.set_default();
        }
        self.rx_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_rx_info(&mut self) -> UplinkRXInfo {
        self.rx_info.take().unwrap_or_else(|| UplinkRXInfo::new())
    }
}

impl ::protobuf::Message for UplinkFrame {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rx_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.phy_payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rx_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.phy_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.phy_payload);
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rx_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.phy_payload.is_empty() {
            os.write_bytes(1, &self.phy_payload)?;
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rx_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UplinkFrame {
        UplinkFrame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "phy_payload",
                    |m: &UplinkFrame| { &m.phy_payload },
                    |m: &mut UplinkFrame| { &mut m.phy_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UplinkTXInfo>>(
                    "tx_info",
                    |m: &UplinkFrame| { &m.tx_info },
                    |m: &mut UplinkFrame| { &mut m.tx_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UplinkRXInfo>>(
                    "rx_info",
                    |m: &UplinkFrame| { &m.rx_info },
                    |m: &mut UplinkFrame| { &mut m.rx_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UplinkFrame>(
                    "UplinkFrame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UplinkFrame {
        static mut instance: ::protobuf::lazy::Lazy<UplinkFrame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UplinkFrame,
        };
        unsafe {
            instance.get(UplinkFrame::new)
        }
    }
}

impl ::protobuf::Clear for UplinkFrame {
    fn clear(&mut self) {
        self.phy_payload.clear();
        self.tx_info.clear();
        self.rx_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UplinkFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UplinkFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UplinkFrameSet {
    // message fields
    pub phy_payload: ::std::vec::Vec<u8>,
    pub tx_info: ::protobuf::SingularPtrField<UplinkTXInfo>,
    pub rx_info: ::protobuf::RepeatedField<UplinkRXInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UplinkFrameSet {
    fn default() -> &'a UplinkFrameSet {
        <UplinkFrameSet as ::protobuf::Message>::default_instance()
    }
}

impl UplinkFrameSet {
    pub fn new() -> UplinkFrameSet {
        ::std::default::Default::default()
    }

    // bytes phy_payload = 1;


    pub fn get_phy_payload(&self) -> &[u8] {
        &self.phy_payload
    }
    pub fn clear_phy_payload(&mut self) {
        self.phy_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_phy_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.phy_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phy_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.phy_payload
    }

    // Take field
    pub fn take_phy_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.phy_payload, ::std::vec::Vec::new())
    }

    // .gw.UplinkTXInfo tx_info = 2;


    pub fn get_tx_info(&self) -> &UplinkTXInfo {
        self.tx_info.as_ref().unwrap_or_else(|| UplinkTXInfo::default_instance())
    }
    pub fn clear_tx_info(&mut self) {
        self.tx_info.clear();
    }

    pub fn has_tx_info(&self) -> bool {
        self.tx_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_info(&mut self, v: UplinkTXInfo) {
        self.tx_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_info(&mut self) -> &mut UplinkTXInfo {
        if self.tx_info.is_none() {
            self.tx_info.set_default();
        }
        self.tx_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_info(&mut self) -> UplinkTXInfo {
        self.tx_info.take().unwrap_or_else(|| UplinkTXInfo::new())
    }

    // repeated .gw.UplinkRXInfo rx_info = 3;


    pub fn get_rx_info(&self) -> &[UplinkRXInfo] {
        &self.rx_info
    }
    pub fn clear_rx_info(&mut self) {
        self.rx_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_rx_info(&mut self, v: ::protobuf::RepeatedField<UplinkRXInfo>) {
        self.rx_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rx_info(&mut self) -> &mut ::protobuf::RepeatedField<UplinkRXInfo> {
        &mut self.rx_info
    }

    // Take field
    pub fn take_rx_info(&mut self) -> ::protobuf::RepeatedField<UplinkRXInfo> {
        ::std::mem::replace(&mut self.rx_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UplinkFrameSet {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rx_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.phy_payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rx_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.phy_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.phy_payload);
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rx_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.phy_payload.is_empty() {
            os.write_bytes(1, &self.phy_payload)?;
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rx_info {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UplinkFrameSet {
        UplinkFrameSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "phy_payload",
                    |m: &UplinkFrameSet| { &m.phy_payload },
                    |m: &mut UplinkFrameSet| { &mut m.phy_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UplinkTXInfo>>(
                    "tx_info",
                    |m: &UplinkFrameSet| { &m.tx_info },
                    |m: &mut UplinkFrameSet| { &mut m.tx_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UplinkRXInfo>>(
                    "rx_info",
                    |m: &UplinkFrameSet| { &m.rx_info },
                    |m: &mut UplinkFrameSet| { &mut m.rx_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UplinkFrameSet>(
                    "UplinkFrameSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UplinkFrameSet {
        static mut instance: ::protobuf::lazy::Lazy<UplinkFrameSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UplinkFrameSet,
        };
        unsafe {
            instance.get(UplinkFrameSet::new)
        }
    }
}

impl ::protobuf::Clear for UplinkFrameSet {
    fn clear(&mut self) {
        self.phy_payload.clear();
        self.tx_info.clear();
        self.rx_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UplinkFrameSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UplinkFrameSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownlinkFrame {
    // message fields
    pub phy_payload: ::std::vec::Vec<u8>,
    pub tx_info: ::protobuf::SingularPtrField<DownlinkTXInfo>,
    pub token: u32,
    pub downlink_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownlinkFrame {
    fn default() -> &'a DownlinkFrame {
        <DownlinkFrame as ::protobuf::Message>::default_instance()
    }
}

impl DownlinkFrame {
    pub fn new() -> DownlinkFrame {
        ::std::default::Default::default()
    }

    // bytes phy_payload = 1;


    pub fn get_phy_payload(&self) -> &[u8] {
        &self.phy_payload
    }
    pub fn clear_phy_payload(&mut self) {
        self.phy_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_phy_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.phy_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phy_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.phy_payload
    }

    // Take field
    pub fn take_phy_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.phy_payload, ::std::vec::Vec::new())
    }

    // .gw.DownlinkTXInfo tx_info = 2;


    pub fn get_tx_info(&self) -> &DownlinkTXInfo {
        self.tx_info.as_ref().unwrap_or_else(|| DownlinkTXInfo::default_instance())
    }
    pub fn clear_tx_info(&mut self) {
        self.tx_info.clear();
    }

    pub fn has_tx_info(&self) -> bool {
        self.tx_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_info(&mut self, v: DownlinkTXInfo) {
        self.tx_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_info(&mut self) -> &mut DownlinkTXInfo {
        if self.tx_info.is_none() {
            self.tx_info.set_default();
        }
        self.tx_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_info(&mut self) -> DownlinkTXInfo {
        self.tx_info.take().unwrap_or_else(|| DownlinkTXInfo::new())
    }

    // uint32 token = 3;


    pub fn get_token(&self) -> u32 {
        self.token
    }
    pub fn clear_token(&mut self) {
        self.token = 0;
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = v;
    }

    // bytes downlink_id = 4;


    pub fn get_downlink_id(&self) -> &[u8] {
        &self.downlink_id
    }
    pub fn clear_downlink_id(&mut self) {
        self.downlink_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_downlink_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.downlink_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.downlink_id
    }

    // Take field
    pub fn take_downlink_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.downlink_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DownlinkFrame {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.phy_payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.downlink_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.phy_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.phy_payload);
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.token != 0 {
            my_size += ::protobuf::rt::value_size(3, self.token, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.downlink_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.downlink_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.phy_payload.is_empty() {
            os.write_bytes(1, &self.phy_payload)?;
        }
        if let Some(ref v) = self.tx_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.token != 0 {
            os.write_uint32(3, self.token)?;
        }
        if !self.downlink_id.is_empty() {
            os.write_bytes(4, &self.downlink_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownlinkFrame {
        DownlinkFrame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "phy_payload",
                    |m: &DownlinkFrame| { &m.phy_payload },
                    |m: &mut DownlinkFrame| { &mut m.phy_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownlinkTXInfo>>(
                    "tx_info",
                    |m: &DownlinkFrame| { &m.tx_info },
                    |m: &mut DownlinkFrame| { &mut m.tx_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    |m: &DownlinkFrame| { &m.token },
                    |m: &mut DownlinkFrame| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "downlink_id",
                    |m: &DownlinkFrame| { &m.downlink_id },
                    |m: &mut DownlinkFrame| { &mut m.downlink_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownlinkFrame>(
                    "DownlinkFrame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownlinkFrame {
        static mut instance: ::protobuf::lazy::Lazy<DownlinkFrame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownlinkFrame,
        };
        unsafe {
            instance.get(DownlinkFrame::new)
        }
    }
}

impl ::protobuf::Clear for DownlinkFrame {
    fn clear(&mut self) {
        self.phy_payload.clear();
        self.tx_info.clear();
        self.token = 0;
        self.downlink_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownlinkFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownlinkTXAck {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub token: u32,
    pub error: ::std::string::String,
    pub downlink_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownlinkTXAck {
    fn default() -> &'a DownlinkTXAck {
        <DownlinkTXAck as ::protobuf::Message>::default_instance()
    }
}

impl DownlinkTXAck {
    pub fn new() -> DownlinkTXAck {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // uint32 token = 2;


    pub fn get_token(&self) -> u32 {
        self.token
    }
    pub fn clear_token(&mut self) {
        self.token = 0;
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = v;
    }

    // string error = 3;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes downlink_id = 4;


    pub fn get_downlink_id(&self) -> &[u8] {
        &self.downlink_id
    }
    pub fn clear_downlink_id(&mut self) {
        self.downlink_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_downlink_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.downlink_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downlink_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.downlink_id
    }

    // Take field
    pub fn take_downlink_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.downlink_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DownlinkTXAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.downlink_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if self.token != 0 {
            my_size += ::protobuf::rt::value_size(2, self.token, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        if !self.downlink_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.downlink_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if self.token != 0 {
            os.write_uint32(2, self.token)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        if !self.downlink_id.is_empty() {
            os.write_bytes(4, &self.downlink_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownlinkTXAck {
        DownlinkTXAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &DownlinkTXAck| { &m.gateway_id },
                    |m: &mut DownlinkTXAck| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "token",
                    |m: &DownlinkTXAck| { &m.token },
                    |m: &mut DownlinkTXAck| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &DownlinkTXAck| { &m.error },
                    |m: &mut DownlinkTXAck| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "downlink_id",
                    |m: &DownlinkTXAck| { &m.downlink_id },
                    |m: &mut DownlinkTXAck| { &mut m.downlink_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownlinkTXAck>(
                    "DownlinkTXAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownlinkTXAck {
        static mut instance: ::protobuf::lazy::Lazy<DownlinkTXAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownlinkTXAck,
        };
        unsafe {
            instance.get(DownlinkTXAck::new)
        }
    }
}

impl ::protobuf::Clear for DownlinkTXAck {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.token = 0;
        self.error.clear();
        self.downlink_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownlinkTXAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkTXAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GatewayConfiguration {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub version: ::std::string::String,
    pub channels: ::protobuf::RepeatedField<ChannelConfiguration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GatewayConfiguration {
    fn default() -> &'a GatewayConfiguration {
        <GatewayConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl GatewayConfiguration {
    pub fn new() -> GatewayConfiguration {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // repeated .gw.ChannelConfiguration channels = 3;


    pub fn get_channels(&self) -> &[ChannelConfiguration] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelConfiguration>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelConfiguration> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelConfiguration> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GatewayConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        for v in &self.channels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GatewayConfiguration {
        GatewayConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &GatewayConfiguration| { &m.gateway_id },
                    |m: &mut GatewayConfiguration| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &GatewayConfiguration| { &m.version },
                    |m: &mut GatewayConfiguration| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelConfiguration>>(
                    "channels",
                    |m: &GatewayConfiguration| { &m.channels },
                    |m: &mut GatewayConfiguration| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GatewayConfiguration>(
                    "GatewayConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GatewayConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<GatewayConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GatewayConfiguration,
        };
        unsafe {
            instance.get(GatewayConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for GatewayConfiguration {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.version.clear();
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GatewayConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelConfiguration {
    // message fields
    pub frequency: u32,
    pub modulation: super::common::Modulation,
    pub board: u32,
    pub demodulator: u32,
    // message oneof groups
    pub modulation_config: ::std::option::Option<ChannelConfiguration_oneof_modulation_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelConfiguration {
    fn default() -> &'a ChannelConfiguration {
        <ChannelConfiguration as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChannelConfiguration_oneof_modulation_config {
    lora_modulation_config(LoRaModulationConfig),
    fsk_modulation_config(FSKModulationConfig),
}

impl ChannelConfiguration {
    pub fn new() -> ChannelConfiguration {
        ::std::default::Default::default()
    }

    // uint32 frequency = 1;


    pub fn get_frequency(&self) -> u32 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = v;
    }

    // .common.Modulation modulation = 2;


    pub fn get_modulation(&self) -> super::common::Modulation {
        self.modulation
    }
    pub fn clear_modulation(&mut self) {
        self.modulation = super::common::Modulation::LORA;
    }

    // Param is passed by value, moved
    pub fn set_modulation(&mut self, v: super::common::Modulation) {
        self.modulation = v;
    }

    // .gw.LoRaModulationConfig lora_modulation_config = 3;


    pub fn get_lora_modulation_config(&self) -> &LoRaModulationConfig {
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(ref v)) => v,
            _ => LoRaModulationConfig::default_instance(),
        }
    }
    pub fn clear_lora_modulation_config(&mut self) {
        self.modulation_config = ::std::option::Option::None;
    }

    pub fn has_lora_modulation_config(&self) -> bool {
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lora_modulation_config(&mut self, v: LoRaModulationConfig) {
        self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lora_modulation_config(&mut self) -> &mut LoRaModulationConfig {
        if let ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(_)) = self.modulation_config {
        } else {
            self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(LoRaModulationConfig::new()));
        }
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lora_modulation_config(&mut self) -> LoRaModulationConfig {
        if self.has_lora_modulation_config() {
            match self.modulation_config.take() {
                ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(v)) => v,
                _ => panic!(),
            }
        } else {
            LoRaModulationConfig::new()
        }
    }

    // .gw.FSKModulationConfig fsk_modulation_config = 4;


    pub fn get_fsk_modulation_config(&self) -> &FSKModulationConfig {
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(ref v)) => v,
            _ => FSKModulationConfig::default_instance(),
        }
    }
    pub fn clear_fsk_modulation_config(&mut self) {
        self.modulation_config = ::std::option::Option::None;
    }

    pub fn has_fsk_modulation_config(&self) -> bool {
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fsk_modulation_config(&mut self, v: FSKModulationConfig) {
        self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fsk_modulation_config(&mut self) -> &mut FSKModulationConfig {
        if let ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(_)) = self.modulation_config {
        } else {
            self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(FSKModulationConfig::new()));
        }
        match self.modulation_config {
            ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fsk_modulation_config(&mut self) -> FSKModulationConfig {
        if self.has_fsk_modulation_config() {
            match self.modulation_config.take() {
                ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(v)) => v,
                _ => panic!(),
            }
        } else {
            FSKModulationConfig::new()
        }
    }

    // uint32 board = 5;


    pub fn get_board(&self) -> u32 {
        self.board
    }
    pub fn clear_board(&mut self) {
        self.board = 0;
    }

    // Param is passed by value, moved
    pub fn set_board(&mut self, v: u32) {
        self.board = v;
    }

    // uint32 demodulator = 6;


    pub fn get_demodulator(&self) -> u32 {
        self.demodulator
    }
    pub fn clear_demodulator(&mut self) {
        self.demodulator = 0;
    }

    // Param is passed by value, moved
    pub fn set_demodulator(&mut self, v: u32) {
        self.demodulator = v;
    }
}

impl ::protobuf::Message for ChannelConfiguration {
    fn is_initialized(&self) -> bool {
        if let Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(ref v)) = self.modulation_config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(ref v)) = self.modulation_config {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.modulation, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::lora_modulation_config(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.modulation_config = ::std::option::Option::Some(ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.board = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.demodulator = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.modulation != super::common::Modulation::LORA {
            my_size += ::protobuf::rt::enum_size(2, self.modulation);
        }
        if self.board != 0 {
            my_size += ::protobuf::rt::value_size(5, self.board, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.demodulator != 0 {
            my_size += ::protobuf::rt::value_size(6, self.demodulator, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_config {
            match v {
                &ChannelConfiguration_oneof_modulation_config::lora_modulation_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.frequency != 0 {
            os.write_uint32(1, self.frequency)?;
        }
        if self.modulation != super::common::Modulation::LORA {
            os.write_enum(2, self.modulation.value())?;
        }
        if self.board != 0 {
            os.write_uint32(5, self.board)?;
        }
        if self.demodulator != 0 {
            os.write_uint32(6, self.demodulator)?;
        }
        if let ::std::option::Option::Some(ref v) = self.modulation_config {
            match v {
                &ChannelConfiguration_oneof_modulation_config::lora_modulation_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelConfiguration_oneof_modulation_config::fsk_modulation_config(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelConfiguration {
        ChannelConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    |m: &ChannelConfiguration| { &m.frequency },
                    |m: &mut ChannelConfiguration| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::Modulation>>(
                    "modulation",
                    |m: &ChannelConfiguration| { &m.modulation },
                    |m: &mut ChannelConfiguration| { &mut m.modulation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LoRaModulationConfig>(
                    "lora_modulation_config",
                    ChannelConfiguration::has_lora_modulation_config,
                    ChannelConfiguration::get_lora_modulation_config,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FSKModulationConfig>(
                    "fsk_modulation_config",
                    ChannelConfiguration::has_fsk_modulation_config,
                    ChannelConfiguration::get_fsk_modulation_config,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "board",
                    |m: &ChannelConfiguration| { &m.board },
                    |m: &mut ChannelConfiguration| { &mut m.board },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "demodulator",
                    |m: &ChannelConfiguration| { &m.demodulator },
                    |m: &mut ChannelConfiguration| { &mut m.demodulator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelConfiguration>(
                    "ChannelConfiguration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelConfiguration {
        static mut instance: ::protobuf::lazy::Lazy<ChannelConfiguration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelConfiguration,
        };
        unsafe {
            instance.get(ChannelConfiguration::new)
        }
    }
}

impl ::protobuf::Clear for ChannelConfiguration {
    fn clear(&mut self) {
        self.frequency = 0;
        self.modulation = super::common::Modulation::LORA;
        self.modulation_config = ::std::option::Option::None;
        self.modulation_config = ::std::option::Option::None;
        self.board = 0;
        self.demodulator = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoRaModulationConfig {
    // message fields
    pub bandwidth: u32,
    pub spreading_factors: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoRaModulationConfig {
    fn default() -> &'a LoRaModulationConfig {
        <LoRaModulationConfig as ::protobuf::Message>::default_instance()
    }
}

impl LoRaModulationConfig {
    pub fn new() -> LoRaModulationConfig {
        ::std::default::Default::default()
    }

    // uint32 bandwidth = 1;


    pub fn get_bandwidth(&self) -> u32 {
        self.bandwidth
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = v;
    }

    // repeated uint32 spreading_factors = 2;


    pub fn get_spreading_factors(&self) -> &[u32] {
        &self.spreading_factors
    }
    pub fn clear_spreading_factors(&mut self) {
        self.spreading_factors.clear();
    }

    // Param is passed by value, moved
    pub fn set_spreading_factors(&mut self, v: ::std::vec::Vec<u32>) {
        self.spreading_factors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spreading_factors(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.spreading_factors
    }

    // Take field
    pub fn take_spreading_factors(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.spreading_factors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LoRaModulationConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bandwidth = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.spreading_factors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.spreading_factors {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bandwidth != 0 {
            os.write_uint32(1, self.bandwidth)?;
        }
        for v in &self.spreading_factors {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoRaModulationConfig {
        LoRaModulationConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bandwidth",
                    |m: &LoRaModulationConfig| { &m.bandwidth },
                    |m: &mut LoRaModulationConfig| { &mut m.bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spreading_factors",
                    |m: &LoRaModulationConfig| { &m.spreading_factors },
                    |m: &mut LoRaModulationConfig| { &mut m.spreading_factors },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoRaModulationConfig>(
                    "LoRaModulationConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoRaModulationConfig {
        static mut instance: ::protobuf::lazy::Lazy<LoRaModulationConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoRaModulationConfig,
        };
        unsafe {
            instance.get(LoRaModulationConfig::new)
        }
    }
}

impl ::protobuf::Clear for LoRaModulationConfig {
    fn clear(&mut self) {
        self.bandwidth = 0;
        self.spreading_factors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoRaModulationConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoRaModulationConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FSKModulationConfig {
    // message fields
    pub bandwidth: u32,
    pub bitrate: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FSKModulationConfig {
    fn default() -> &'a FSKModulationConfig {
        <FSKModulationConfig as ::protobuf::Message>::default_instance()
    }
}

impl FSKModulationConfig {
    pub fn new() -> FSKModulationConfig {
        ::std::default::Default::default()
    }

    // uint32 bandwidth = 1;


    pub fn get_bandwidth(&self) -> u32 {
        self.bandwidth
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = v;
    }

    // uint32 bitrate = 2;


    pub fn get_bitrate(&self) -> u32 {
        self.bitrate
    }
    pub fn clear_bitrate(&mut self) {
        self.bitrate = 0;
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: u32) {
        self.bitrate = v;
    }
}

impl ::protobuf::Message for FSKModulationConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bandwidth = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bitrate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bitrate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bitrate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bandwidth != 0 {
            os.write_uint32(1, self.bandwidth)?;
        }
        if self.bitrate != 0 {
            os.write_uint32(2, self.bitrate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FSKModulationConfig {
        FSKModulationConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bandwidth",
                    |m: &FSKModulationConfig| { &m.bandwidth },
                    |m: &mut FSKModulationConfig| { &mut m.bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bitrate",
                    |m: &FSKModulationConfig| { &m.bitrate },
                    |m: &mut FSKModulationConfig| { &mut m.bitrate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FSKModulationConfig>(
                    "FSKModulationConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FSKModulationConfig {
        static mut instance: ::protobuf::lazy::Lazy<FSKModulationConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FSKModulationConfig,
        };
        unsafe {
            instance.get(FSKModulationConfig::new)
        }
    }
}

impl ::protobuf::Clear for FSKModulationConfig {
    fn clear(&mut self) {
        self.bandwidth = 0;
        self.bitrate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FSKModulationConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FSKModulationConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GatewayCommandExecRequest {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub command: ::std::string::String,
    pub ExecId: ::std::vec::Vec<u8>,
    pub stdin: ::std::vec::Vec<u8>,
    pub environment: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GatewayCommandExecRequest {
    fn default() -> &'a GatewayCommandExecRequest {
        <GatewayCommandExecRequest as ::protobuf::Message>::default_instance()
    }
}

impl GatewayCommandExecRequest {
    pub fn new() -> GatewayCommandExecRequest {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // string command = 2;


    pub fn get_command(&self) -> &str {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.command, ::std::string::String::new())
    }

    // bytes ExecId = 3;


    pub fn get_ExecId(&self) -> &[u8] {
        &self.ExecId
    }
    pub fn clear_ExecId(&mut self) {
        self.ExecId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ExecId(&mut self, v: ::std::vec::Vec<u8>) {
        self.ExecId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ExecId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ExecId
    }

    // Take field
    pub fn take_ExecId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ExecId, ::std::vec::Vec::new())
    }

    // bytes stdin = 4;


    pub fn get_stdin(&self) -> &[u8] {
        &self.stdin
    }
    pub fn clear_stdin(&mut self) {
        self.stdin.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: ::std::vec::Vec<u8>) {
        self.stdin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdin(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stdin
    }

    // Take field
    pub fn take_stdin(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stdin, ::std::vec::Vec::new())
    }

    // repeated .gw.GatewayCommandExecRequest.EnvironmentEntry environment = 5;


    pub fn get_environment(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.environment
    }
    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.environment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_environment(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.environment
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.environment, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for GatewayCommandExecRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.command)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ExecId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stdin)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.environment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.command.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.command);
        }
        if !self.ExecId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ExecId);
        }
        if !self.stdin.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.stdin);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.environment);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.command.is_empty() {
            os.write_string(2, &self.command)?;
        }
        if !self.ExecId.is_empty() {
            os.write_bytes(3, &self.ExecId)?;
        }
        if !self.stdin.is_empty() {
            os.write_bytes(4, &self.stdin)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.environment, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GatewayCommandExecRequest {
        GatewayCommandExecRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &GatewayCommandExecRequest| { &m.gateway_id },
                    |m: &mut GatewayCommandExecRequest| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    |m: &GatewayCommandExecRequest| { &m.command },
                    |m: &mut GatewayCommandExecRequest| { &mut m.command },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ExecId",
                    |m: &GatewayCommandExecRequest| { &m.ExecId },
                    |m: &mut GatewayCommandExecRequest| { &mut m.ExecId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stdin",
                    |m: &GatewayCommandExecRequest| { &m.stdin },
                    |m: &mut GatewayCommandExecRequest| { &mut m.stdin },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "environment",
                    |m: &GatewayCommandExecRequest| { &m.environment },
                    |m: &mut GatewayCommandExecRequest| { &mut m.environment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GatewayCommandExecRequest>(
                    "GatewayCommandExecRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GatewayCommandExecRequest {
        static mut instance: ::protobuf::lazy::Lazy<GatewayCommandExecRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GatewayCommandExecRequest,
        };
        unsafe {
            instance.get(GatewayCommandExecRequest::new)
        }
    }
}

impl ::protobuf::Clear for GatewayCommandExecRequest {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.command.clear();
        self.ExecId.clear();
        self.stdin.clear();
        self.environment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GatewayCommandExecRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayCommandExecRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GatewayCommandExecResponse {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub exec_id: ::std::vec::Vec<u8>,
    pub stdout: ::std::vec::Vec<u8>,
    pub stderr: ::std::vec::Vec<u8>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GatewayCommandExecResponse {
    fn default() -> &'a GatewayCommandExecResponse {
        <GatewayCommandExecResponse as ::protobuf::Message>::default_instance()
    }
}

impl GatewayCommandExecResponse {
    pub fn new() -> GatewayCommandExecResponse {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // bytes exec_id = 2;


    pub fn get_exec_id(&self) -> &[u8] {
        &self.exec_id
    }
    pub fn clear_exec_id(&mut self) {
        self.exec_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exec_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.exec_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.exec_id
    }

    // Take field
    pub fn take_exec_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.exec_id, ::std::vec::Vec::new())
    }

    // bytes stdout = 3;


    pub fn get_stdout(&self) -> &[u8] {
        &self.stdout
    }
    pub fn clear_stdout(&mut self) {
        self.stdout.clear();
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: ::std::vec::Vec<u8>) {
        self.stdout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stdout(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stdout
    }

    // Take field
    pub fn take_stdout(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stdout, ::std::vec::Vec::new())
    }

    // bytes stderr = 4;


    pub fn get_stderr(&self) -> &[u8] {
        &self.stderr
    }
    pub fn clear_stderr(&mut self) {
        self.stderr.clear();
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: ::std::vec::Vec<u8>) {
        self.stderr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stderr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stderr
    }

    // Take field
    pub fn take_stderr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stderr, ::std::vec::Vec::new())
    }

    // string error = 5;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GatewayCommandExecResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.exec_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stdout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stderr)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.exec_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.exec_id);
        }
        if !self.stdout.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.stdout);
        }
        if !self.stderr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.stderr);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.exec_id.is_empty() {
            os.write_bytes(2, &self.exec_id)?;
        }
        if !self.stdout.is_empty() {
            os.write_bytes(3, &self.stdout)?;
        }
        if !self.stderr.is_empty() {
            os.write_bytes(4, &self.stderr)?;
        }
        if !self.error.is_empty() {
            os.write_string(5, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GatewayCommandExecResponse {
        GatewayCommandExecResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &GatewayCommandExecResponse| { &m.gateway_id },
                    |m: &mut GatewayCommandExecResponse| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "exec_id",
                    |m: &GatewayCommandExecResponse| { &m.exec_id },
                    |m: &mut GatewayCommandExecResponse| { &mut m.exec_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stdout",
                    |m: &GatewayCommandExecResponse| { &m.stdout },
                    |m: &mut GatewayCommandExecResponse| { &mut m.stdout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stderr",
                    |m: &GatewayCommandExecResponse| { &m.stderr },
                    |m: &mut GatewayCommandExecResponse| { &mut m.stderr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &GatewayCommandExecResponse| { &m.error },
                    |m: &mut GatewayCommandExecResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GatewayCommandExecResponse>(
                    "GatewayCommandExecResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GatewayCommandExecResponse {
        static mut instance: ::protobuf::lazy::Lazy<GatewayCommandExecResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GatewayCommandExecResponse,
        };
        unsafe {
            instance.get(GatewayCommandExecResponse::new)
        }
    }
}

impl ::protobuf::Clear for GatewayCommandExecResponse {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.exec_id.clear();
        self.stdout.clear();
        self.stderr.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GatewayCommandExecResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatewayCommandExecResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawPacketForwarderEvent {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub raw_id: ::std::vec::Vec<u8>,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawPacketForwarderEvent {
    fn default() -> &'a RawPacketForwarderEvent {
        <RawPacketForwarderEvent as ::protobuf::Message>::default_instance()
    }
}

impl RawPacketForwarderEvent {
    pub fn new() -> RawPacketForwarderEvent {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // bytes raw_id = 2;


    pub fn get_raw_id(&self) -> &[u8] {
        &self.raw_id
    }
    pub fn clear_raw_id(&mut self) {
        self.raw_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_id
    }

    // Take field
    pub fn take_raw_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_id, ::std::vec::Vec::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawPacketForwarderEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.raw_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.raw_id);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.raw_id.is_empty() {
            os.write_bytes(2, &self.raw_id)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawPacketForwarderEvent {
        RawPacketForwarderEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &RawPacketForwarderEvent| { &m.gateway_id },
                    |m: &mut RawPacketForwarderEvent| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "raw_id",
                    |m: &RawPacketForwarderEvent| { &m.raw_id },
                    |m: &mut RawPacketForwarderEvent| { &mut m.raw_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &RawPacketForwarderEvent| { &m.payload },
                    |m: &mut RawPacketForwarderEvent| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawPacketForwarderEvent>(
                    "RawPacketForwarderEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawPacketForwarderEvent {
        static mut instance: ::protobuf::lazy::Lazy<RawPacketForwarderEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawPacketForwarderEvent,
        };
        unsafe {
            instance.get(RawPacketForwarderEvent::new)
        }
    }
}

impl ::protobuf::Clear for RawPacketForwarderEvent {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.raw_id.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawPacketForwarderEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawPacketForwarderEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawPacketForwarderCommand {
    // message fields
    pub gateway_id: ::std::vec::Vec<u8>,
    pub raw_id: ::std::vec::Vec<u8>,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawPacketForwarderCommand {
    fn default() -> &'a RawPacketForwarderCommand {
        <RawPacketForwarderCommand as ::protobuf::Message>::default_instance()
    }
}

impl RawPacketForwarderCommand {
    pub fn new() -> RawPacketForwarderCommand {
        ::std::default::Default::default()
    }

    // bytes gateway_id = 1;


    pub fn get_gateway_id(&self) -> &[u8] {
        &self.gateway_id
    }
    pub fn clear_gateway_id(&mut self) {
        self.gateway_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_gateway_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gateway_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gateway_id
    }

    // Take field
    pub fn take_gateway_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gateway_id, ::std::vec::Vec::new())
    }

    // bytes raw_id = 2;


    pub fn get_raw_id(&self) -> &[u8] {
        &self.raw_id
    }
    pub fn clear_raw_id(&mut self) {
        self.raw_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_id
    }

    // Take field
    pub fn take_raw_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_id, ::std::vec::Vec::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawPacketForwarderCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gateway_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.gateway_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.gateway_id);
        }
        if !self.raw_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.raw_id);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.gateway_id.is_empty() {
            os.write_bytes(1, &self.gateway_id)?;
        }
        if !self.raw_id.is_empty() {
            os.write_bytes(2, &self.raw_id)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawPacketForwarderCommand {
        RawPacketForwarderCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gateway_id",
                    |m: &RawPacketForwarderCommand| { &m.gateway_id },
                    |m: &mut RawPacketForwarderCommand| { &mut m.gateway_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "raw_id",
                    |m: &RawPacketForwarderCommand| { &m.raw_id },
                    |m: &mut RawPacketForwarderCommand| { &mut m.raw_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &RawPacketForwarderCommand| { &m.payload },
                    |m: &mut RawPacketForwarderCommand| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawPacketForwarderCommand>(
                    "RawPacketForwarderCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawPacketForwarderCommand {
        static mut instance: ::protobuf::lazy::Lazy<RawPacketForwarderCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawPacketForwarderCommand,
        };
        unsafe {
            instance.get(RawPacketForwarderCommand::new)
        }
    }
}

impl ::protobuf::Clear for RawPacketForwarderCommand {
    fn clear(&mut self) {
        self.gateway_id.clear();
        self.raw_id.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawPacketForwarderCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawPacketForwarderCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DownlinkTiming {
    IMMEDIATELY = 0,
    DELAY = 1,
    GPS_EPOCH = 2,
}

impl ::protobuf::ProtobufEnum for DownlinkTiming {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DownlinkTiming> {
        match value {
            0 => ::std::option::Option::Some(DownlinkTiming::IMMEDIATELY),
            1 => ::std::option::Option::Some(DownlinkTiming::DELAY),
            2 => ::std::option::Option::Some(DownlinkTiming::GPS_EPOCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DownlinkTiming] = &[
            DownlinkTiming::IMMEDIATELY,
            DownlinkTiming::DELAY,
            DownlinkTiming::GPS_EPOCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DownlinkTiming", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DownlinkTiming {
}

impl ::std::default::Default for DownlinkTiming {
    fn default() -> Self {
        DownlinkTiming::IMMEDIATELY
    }
}

impl ::protobuf::reflect::ProtobufValue for DownlinkTiming {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FineTimestampType {
    NONE = 0,
    ENCRYPTED = 1,
    PLAIN = 2,
}

impl ::protobuf::ProtobufEnum for FineTimestampType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FineTimestampType> {
        match value {
            0 => ::std::option::Option::Some(FineTimestampType::NONE),
            1 => ::std::option::Option::Some(FineTimestampType::ENCRYPTED),
            2 => ::std::option::Option::Some(FineTimestampType::PLAIN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FineTimestampType] = &[
            FineTimestampType::NONE,
            FineTimestampType::ENCRYPTED,
            FineTimestampType::PLAIN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FineTimestampType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FineTimestampType {
}

impl ::std::default::Default for FineTimestampType {
    fn default() -> Self {
        FineTimestampType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for FineTimestampType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bgw/gw.proto\x12\x02gw\x1a\x13common/common.proto\x1a\x1fgoogle/pro\
    tobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\"\x88\x02\n\
    \x0cUplinkTXInfo\x12\x1c\n\tfrequency\x18\x01\x20\x01(\rR\tfrequency\x12\
    2\n\nmodulation\x18\x02\x20\x01(\x0e2\x12.common.ModulationR\nmodulation\
    \x12J\n\x14lora_modulation_info\x18\x03\x20\x01(\x0b2\x16.gw.LoRaModulat\
    ionInfoH\0R\x12loRaModulationInfo\x12G\n\x13fsk_modulation_info\x18\x04\
    \x20\x01(\x0b2\x15.gw.FSKModulationInfoH\0R\x11fskModulationInfoB\x11\n\
    \x0fmodulation_info\"\xb1\x01\n\x12LoRaModulationInfo\x12\x1c\n\tbandwid\
    th\x18\x01\x20\x01(\rR\tbandwidth\x12)\n\x10spreading_factor\x18\x02\x20\
    \x01(\rR\x0fspreadingFactor\x12\x1b\n\tcode_rate\x18\x03\x20\x01(\tR\x08\
    codeRate\x125\n\x16polarization_inversion\x18\x04\x20\x01(\x08R\x15polar\
    izationInversion\"K\n\x11FSKModulationInfo\x12\x1c\n\tbandwidth\x18\x01\
    \x20\x01(\rR\tbandwidth\x12\x18\n\x07bitrate\x18\x02\x20\x01(\rR\x07bitr\
    ate\"x\n\x16EncryptedFineTimestamp\x12\"\n\raes_key_index\x18\x01\x20\
    \x01(\rR\x0baesKeyIndex\x12!\n\x0cencrypted_ns\x18\x02\x20\x01(\x0cR\x0b\
    encryptedNS\x12\x17\n\x07fpga_id\x18\x03\x20\x01(\x0cR\x06fpgaID\"D\n\
    \x12PlainFineTimestamp\x12.\n\x04time\x18\x01\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\x04time\"\x9a\x04\n\x0cGatewayStats\x12\x1d\n\ngatewa\
    y_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12\x0e\n\x02ip\x18\t\x20\x01(\tR\
    \x02ip\x12.\n\x04time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Timestam\
    pR\x04time\x12,\n\x08location\x18\x03\x20\x01(\x0b2\x10.common.LocationR\
    \x08location\x12%\n\x0econfig_version\x18\x04\x20\x01(\tR\rconfigVersion\
    \x12.\n\x13rx_packets_received\x18\x05\x20\x01(\rR\x11rxPacketsReceived\
    \x123\n\x16rx_packets_received_ok\x18\x06\x20\x01(\rR\x13rxPacketsReceiv\
    edOK\x12.\n\x13tx_packets_received\x18\x07\x20\x01(\rR\x11txPacketsRecei\
    ved\x12,\n\x12tx_packets_emitted\x18\x08\x20\x01(\rR\x10txPacketsEmitted\
    \x12;\n\tmeta_data\x18\n\x20\x03(\x0b2\x1e.gw.GatewayStats.MetaDataEntry\
    R\x08metaData\x12\x19\n\x08stats_id\x18\x0b\x20\x01(\x0cR\x07statsID\x1a\
    ;\n\rMetaDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x9f\x05\n\x0cUplinkRX\
    Info\x12\x1d\n\ngateway_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12.\n\x04ti\
    me\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04time\x12J\n\
    \x14time_since_gps_epoch\x18\x03\x20\x01(\x0b2\x19.google.protobuf.Durat\
    ionR\x11timeSinceGPSEpoch\x12\x12\n\x04rssi\x18\x05\x20\x01(\x05R\x04rss\
    i\x12\x19\n\x08lora_snr\x18\x06\x20\x01(\x01R\x07loRaSNR\x12\x18\n\x07ch\
    annel\x18\x07\x20\x01(\rR\x07channel\x12\x19\n\x08rf_chain\x18\x08\x20\
    \x01(\rR\x07rfChain\x12\x14\n\x05board\x18\t\x20\x01(\rR\x05board\x12\
    \x18\n\x07antenna\x18\n\x20\x01(\rR\x07antenna\x12,\n\x08location\x18\
    \x0b\x20\x01(\x0b2\x10.common.LocationR\x08location\x12E\n\x13fine_times\
    tamp_type\x18\x0c\x20\x01(\x0e2\x15.gw.FineTimestampTypeR\x11fineTimesta\
    mpType\x12V\n\x18encrypted_fine_timestamp\x18\r\x20\x01(\x0b2\x1a.gw.Enc\
    ryptedFineTimestampH\0R\x16encryptedFineTimestamp\x12J\n\x14plain_fine_t\
    imestamp\x18\x0e\x20\x01(\x0b2\x16.gw.PlainFineTimestampH\0R\x12plainFin\
    eTimestamp\x12\x18\n\x07context\x18\x0f\x20\x01(\x0cR\x07context\x12\x1b\
    \n\tuplink_id\x18\x10\x20\x01(\x0cR\x08uplinkIDB\x10\n\x0efine_timestamp\
    \"\xa9\x05\n\x0eDownlinkTXInfo\x12\x1d\n\ngateway_id\x18\x01\x20\x01(\
    \x0cR\tgatewayID\x12\x1c\n\tfrequency\x18\x05\x20\x01(\rR\tfrequency\x12\
    \x14\n\x05power\x18\x06\x20\x01(\x05R\x05power\x122\n\nmodulation\x18\
    \x07\x20\x01(\x0e2\x12.common.ModulationR\nmodulation\x12J\n\x14lora_mod\
    ulation_info\x18\x08\x20\x01(\x0b2\x16.gw.LoRaModulationInfoH\0R\x12loRa\
    ModulationInfo\x12G\n\x13fsk_modulation_info\x18\t\x20\x01(\x0b2\x15.gw.\
    FSKModulationInfoH\0R\x11fskModulationInfo\x12\x14\n\x05board\x18\n\x20\
    \x01(\rR\x05board\x12\x18\n\x07antenna\x18\x0b\x20\x01(\rR\x07antenna\
    \x12*\n\x06timing\x18\x0c\x20\x01(\x0e2\x12.gw.DownlinkTimingR\x06timing\
    \x12S\n\x17immediately_timing_info\x18\r\x20\x01(\x0b2\x19.gw.Immediatel\
    yTimingInfoH\x01R\x15immediatelyTimingInfo\x12A\n\x11delay_timing_info\
    \x18\x0e\x20\x01(\x0b2\x13.gw.DelayTimingInfoH\x01R\x0fdelayTimingInfo\
    \x12K\n\x15gps_epoch_timing_info\x18\x0f\x20\x01(\x0b2\x16.gw.GPSEpochTi\
    mingInfoH\x01R\x12gpsEpochTimingInfo\x12\x18\n\x07context\x18\x10\x20\
    \x01(\x0cR\x07contextB\x11\n\x0fmodulation_infoB\r\n\x0btiming_info\"\
    \x17\n\x15ImmediatelyTimingInfo\"B\n\x0fDelayTimingInfo\x12/\n\x05delay\
    \x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x05delay\"`\n\x12GP\
    SEpochTimingInfo\x12J\n\x14time_since_gps_epoch\x18\x01\x20\x01(\x0b2\
    \x19.google.protobuf.DurationR\x11timeSinceGPSEpoch\"\x84\x01\n\x0bUplin\
    kFrame\x12\x1f\n\x0bphy_payload\x18\x01\x20\x01(\x0cR\nphyPayload\x12)\n\
    \x07tx_info\x18\x02\x20\x01(\x0b2\x10.gw.UplinkTXInfoR\x06txInfo\x12)\n\
    \x07rx_info\x18\x03\x20\x01(\x0b2\x10.gw.UplinkRXInfoR\x06rxInfo\"\x87\
    \x01\n\x0eUplinkFrameSet\x12\x1f\n\x0bphy_payload\x18\x01\x20\x01(\x0cR\
    \nphyPayload\x12)\n\x07tx_info\x18\x02\x20\x01(\x0b2\x10.gw.UplinkTXInfo\
    R\x06txInfo\x12)\n\x07rx_info\x18\x03\x20\x03(\x0b2\x10.gw.UplinkRXInfoR\
    \x06rxInfo\"\x94\x01\n\rDownlinkFrame\x12\x1f\n\x0bphy_payload\x18\x01\
    \x20\x01(\x0cR\nphyPayload\x12+\n\x07tx_info\x18\x02\x20\x01(\x0b2\x12.g\
    w.DownlinkTXInfoR\x06txInfo\x12\x14\n\x05token\x18\x03\x20\x01(\rR\x05to\
    ken\x12\x1f\n\x0bdownlink_id\x18\x04\x20\x01(\x0cR\ndownlinkID\"{\n\rDow\
    nlinkTXAck\x12\x1d\n\ngateway_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12\
    \x14\n\x05token\x18\x02\x20\x01(\rR\x05token\x12\x14\n\x05error\x18\x03\
    \x20\x01(\tR\x05error\x12\x1f\n\x0bdownlink_id\x18\x04\x20\x01(\x0cR\ndo\
    wnlinkID\"\x85\x01\n\x14GatewayConfiguration\x12\x1d\n\ngateway_id\x18\
    \x01\x20\x01(\x0cR\tgatewayID\x12\x18\n\x07version\x18\x02\x20\x01(\tR\
    \x07version\x124\n\x08channels\x18\x03\x20\x03(\x0b2\x18.gw.ChannelConfi\
    gurationR\x08channels\"\xd6\x02\n\x14ChannelConfiguration\x12\x1c\n\tfre\
    quency\x18\x01\x20\x01(\rR\tfrequency\x122\n\nmodulation\x18\x02\x20\x01\
    (\x0e2\x12.common.ModulationR\nmodulation\x12P\n\x16lora_modulation_conf\
    ig\x18\x03\x20\x01(\x0b2\x18.gw.LoRaModulationConfigH\0R\x14loRaModulati\
    onConfig\x12M\n\x15fsk_modulation_config\x18\x04\x20\x01(\x0b2\x17.gw.FS\
    KModulationConfigH\0R\x13fskModulationConfig\x12\x14\n\x05board\x18\x05\
    \x20\x01(\rR\x05board\x12\x20\n\x0bdemodulator\x18\x06\x20\x01(\rR\x0bde\
    modulatorB\x13\n\x11modulation_config\"a\n\x14LoRaModulationConfig\x12\
    \x1c\n\tbandwidth\x18\x01\x20\x01(\rR\tbandwidth\x12+\n\x11spreading_fac\
    tors\x18\x02\x20\x03(\rR\x10spreadingFactors\"M\n\x13FSKModulationConfig\
    \x12\x1c\n\tbandwidth\x18\x01\x20\x01(\rR\tbandwidth\x12\x18\n\x07bitrat\
    e\x18\x02\x20\x01(\rR\x07bitrate\"\x94\x02\n\x19GatewayCommandExecReques\
    t\x12\x1d\n\ngateway_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12\x18\n\x07co\
    mmand\x18\x02\x20\x01(\tR\x07command\x12\x16\n\x06ExecId\x18\x03\x20\x01\
    (\x0cR\x06execID\x12\x14\n\x05stdin\x18\x04\x20\x01(\x0cR\x05stdin\x12P\
    \n\x0benvironment\x18\x05\x20\x03(\x0b2..gw.GatewayCommandExecRequest.En\
    vironmentEntryR\x0benvironment\x1a>\n\x10EnvironmentEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\"\x9a\x01\n\x1aGatewayCommandExecResponse\x12\x1d\n\ngat\
    eway_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12\x17\n\x07exec_id\x18\x02\
    \x20\x01(\x0cR\x06execID\x12\x16\n\x06stdout\x18\x03\x20\x01(\x0cR\x06st\
    dout\x12\x16\n\x06stderr\x18\x04\x20\x01(\x0cR\x06stderr\x12\x14\n\x05er\
    ror\x18\x05\x20\x01(\tR\x05error\"i\n\x17RawPacketForwarderEvent\x12\x1d\
    \n\ngateway_id\x18\x01\x20\x01(\x0cR\tgatewayID\x12\x15\n\x06raw_id\x18\
    \x02\x20\x01(\x0cR\x05rawID\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\
    \x07payload\"k\n\x19RawPacketForwarderCommand\x12\x1d\n\ngateway_id\x18\
    \x01\x20\x01(\x0cR\tgatewayID\x12\x15\n\x06raw_id\x18\x02\x20\x01(\x0cR\
    \x05rawID\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload*;\n\x0eD\
    ownlinkTiming\x12\x0f\n\x0bIMMEDIATELY\x10\0\x12\t\n\x05DELAY\x10\x01\
    \x12\r\n\tGPS_EPOCH\x10\x02*7\n\x11FineTimestampType\x12\x08\n\x04NONE\
    \x10\0\x12\r\n\tENCRYPTED\x10\x01\x12\t\n\x05PLAIN\x10\x02B,Z*github.com\
    /brocaar/chirpstack-api/go/v3/gwJ\xe8b\n\x07\x12\x05\0\0\x91\x03\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\n\n\x08\n\
    \x01\x08\x12\x03\x04\0A\n\t\n\x02\x08\x0b\x12\x03\x04\0A\n\t\n\x02\x03\0\
    \x12\x03\x06\x07\x1c\n\t\n\x02\x03\x01\x12\x03\x07\x07(\n\t\n\x02\x03\
    \x02\x12\x03\x08\x07'\n\n\n\x02\x05\0\x12\x04\x0b\0\x14\x01\n\n\n\x03\
    \x05\0\x01\x12\x03\x0b\x05\x13\n-\n\x04\x05\0\x02\0\x12\x03\r\x04\x14\
    \x1a\x20\x20Send\x20the\x20downlink\x20immediately.\n\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03\r\x04\x0f\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\r\x12\
    \x13\nL\n\x04\x05\0\x02\x01\x12\x03\x10\x04\x0e\x1a?\x20Send\x20downlink\
    \x20at\x20the\x20given\x20delay\x20(based\x20on\x20provided\x20context).\
    \n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x10\x04\t\n\x0c\n\x05\x05\0\x02\
    \x01\x02\x12\x03\x10\x0c\r\n-\n\x04\x05\0\x02\x02\x12\x03\x13\x04\x12\
    \x1a\x20\x20Send\x20at\x20given\x20GPS\x20epoch\x20value.\n\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03\x13\x04\r\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03\x13\x10\x11\n\n\n\x02\x05\x01\x12\x04\x17\0\x20\x01\n\n\n\x03\x05\
    \x01\x01\x12\x03\x17\x05\x16\n+\n\x04\x05\x01\x02\0\x12\x03\x19\x04\r\
    \x1a\x1e\x20No\x20fine-timestamp\x20available.\n\n\x0c\n\x05\x05\x01\x02\
    \0\x01\x12\x03\x19\x04\x08\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x19\x0b\
    \x0c\n(\n\x04\x05\x01\x02\x01\x12\x03\x1c\x04\x12\x1a\x1b\x20Encrypted\
    \x20fine-timestamp.\n\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\x1c\x04\r\
    \n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x1c\x10\x11\n$\n\x04\x05\x01\
    \x02\x02\x12\x03\x1f\x04\x0e\x1a\x17\x20Plain\x20fine-timestamp.\n\n\x0c\
    \n\x05\x05\x01\x02\x02\x01\x12\x03\x1f\x04\t\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03\x1f\x0c\r\n\n\n\x02\x04\0\x12\x04\"\00\x01\n\n\n\x03\x04\0\
    \x01\x12\x03\"\x08\x14\n\x1e\n\x04\x04\0\x02\0\x12\x03$\x08\x1d\x1a\x11\
    \x20Frequency\x20(Hz).\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04$\x08\"\x16\n\
    \x0c\n\x05\x04\0\x02\0\x05\x12\x03$\x08\x0e\n\x0c\n\x05\x04\0\x02\0\x01\
    \x12\x03$\x0f\x18\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03$\x1b\x1c\n\x1a\n\
    \x04\x04\0\x02\x01\x12\x03'\x04%\x1a\r\x20Modulation.\n\n\r\n\x05\x04\0\
    \x02\x01\x04\x12\x04'\x04$\x1d\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03'\
    \x04\x15\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03'\x16\x20\n\x0c\n\x05\x04\
    \0\x02\x01\x03\x12\x03'#$\n\x0c\n\x04\x04\0\x08\0\x12\x04)\x04/\x05\n\
    \x0c\n\x05\x04\0\x08\0\x01\x12\x03)\n\x19\n+\n\x04\x04\0\x02\x02\x12\x03\
    +\x08W\x1a\x1e\x20LoRa\x20modulation\x20information.\n\n\x0c\n\x05\x04\0\
    \x02\x02\x06\x12\x03+\x08\x1a\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03+\x1b\
    /\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03+23\n\x0c\n\x05\x04\0\x02\x02\x08\
    \x12\x03+4V\n\x0c\n\x05\x04\0\x02\x02\n\x12\x03+AU\n*\n\x04\x04\0\x02\
    \x03\x12\x03.\x082\x1a\x1d\x20FSK\x20modulation\x20information.\n\n\x0c\
    \n\x05\x04\0\x02\x03\x06\x12\x03.\x08\x19\n\x0c\n\x05\x04\0\x02\x03\x01\
    \x12\x03.\x1a-\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03.01\n\n\n\x02\x04\
    \x01\x12\x042\0>\x01\n\n\n\x03\x04\x01\x01\x12\x032\x08\x1a\n\x19\n\x04\
    \x04\x01\x02\0\x12\x034\x04\x19\x1a\x0c\x20Bandwidth.\n\n\r\n\x05\x04\
    \x01\x02\0\x04\x12\x044\x042\x1c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x034\
    \x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x034\x0b\x14\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x034\x17\x18\n\x1f\n\x04\x04\x01\x02\x01\x12\x037\x04\
    \x20\x1a\x12\x20Speading-factor.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\
    7\x044\x19\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x037\x04\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x037\x0b\x1b\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x037\x1e\x1f\n\x19\n\x04\x04\x01\x02\x02\x12\x03:\x04\x19\x1a\x0c\
    \x20Code-rate.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04:\x047\x20\n\x0c\n\
    \x05\x04\x01\x02\x02\x05\x12\x03:\x04\n\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03:\x0b\x14\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03:\x17\x18\n&\n\
    \x04\x04\x01\x02\x03\x12\x03=\x04$\x1a\x19\x20Polarization\x20inversion.\
    \n\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04=\x04:\x19\n\x0c\n\x05\x04\x01\
    \x02\x03\x05\x12\x03=\x04\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03=\t\
    \x1f\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03=\"#\n\n\n\x02\x04\x02\x12\
    \x04@\0F\x01\n\n\n\x03\x04\x02\x01\x12\x03@\x08\x19\n\x19\n\x04\x04\x02\
    \x02\0\x12\x03B\x04\x19\x1a\x0c\x20Bandwidth.\n\n\r\n\x05\x04\x02\x02\0\
    \x04\x12\x04B\x04@\x1b\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03B\x04\n\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03B\x0b\x14\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03B\x17\x18\n\x17\n\x04\x04\x02\x02\x01\x12\x03E\x04\x17\x1a\n\
    \x20Bitrate.\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04E\x04B\x19\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03E\x04\n\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03E\x0b\x12\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03E\x15\x16\n\n\n\
    \x02\x04\x03\x12\x04H\0Q\x01\n\n\n\x03\x04\x03\x01\x12\x03H\x08\x1e\nD\n\
    \x04\x04\x03\x02\0\x12\x03J\x04\x1d\x1a7\x20AES\x20key\x20index\x20used\
    \x20for\x20encrypting\x20the\x20fine\x20timestamp.\n\n\r\n\x05\x04\x03\
    \x02\0\x04\x12\x04J\x04H\x20\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03J\x04\
    \n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03J\x0b\x18\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03J\x1b\x1c\nT\n\x04\x04\x03\x02\x01\x12\x03M\x047\x1aG\
    \x20Encrypted\x20'main'\x20fine-timestamp\x20(ns\x20precision\x20part\
    \x20of\x20the\x20timestamp).\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04M\
    \x04J\x1d\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03M\x04\t\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03M\n\x16\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03M\
    \x19\x1a\n\x0c\n\x05\x04\x03\x02\x01\x08\x12\x03M\x1b6\n\x0c\n\x05\x04\
    \x03\x02\x01\n\x12\x03M(5\n\x17\n\x04\x04\x03\x02\x02\x12\x03P\x04-\x1a\
    \n\x20FPGA\x20ID.\n\n\r\n\x05\x04\x03\x02\x02\x04\x12\x04P\x04M7\n\x0c\n\
    \x05\x04\x03\x02\x02\x05\x12\x03P\x04\t\n\x0c\n\x05\x04\x03\x02\x02\x01\
    \x12\x03P\n\x11\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03P\x14\x15\n\x0c\n\
    \x05\x04\x03\x02\x02\x08\x12\x03P\x16,\n\x0c\n\x05\x04\x03\x02\x02\n\x12\
    \x03P#+\n\n\n\x02\x04\x04\x12\x04S\0V\x01\n\n\n\x03\x04\x04\x01\x12\x03S\
    \x08\x1a\n\x1e\n\x04\x04\x04\x02\0\x12\x03U\x04'\x1a\x11\x20Full\x20time\
    stamp.\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04U\x04S\x1c\n\x0c\n\x05\x04\
    \x04\x02\0\x06\x12\x03U\x04\x1d\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03U\
    \x1e\"\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03U%&\n\n\n\x02\x04\x05\x12\
    \x04X\0{\x01\n\n\n\x03\x04\x05\x01\x12\x03X\x08\x14\n\x1a\n\x04\x04\x05\
    \x02\0\x12\x03Z\x043\x1a\r\x20Gateway\x20ID.\n\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04Z\x04X\x16\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03Z\x04\t\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03Z\n\x14\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03Z\x17\x18\n\x0c\n\x05\x04\x05\x02\0\x08\x12\x03Z\x192\n\x0c\
    \n\x05\x04\x05\x02\0\n\x12\x03Z&1\n\x1a\n\x04\x04\x05\x02\x01\x12\x03]\
    \x04\x12\x1a\r\x20Gateway\x20IP.\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\
    ]\x04Z3\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03]\x04\n\n\x0c\n\x05\x04\
    \x05\x02\x01\x01\x12\x03]\x0b\r\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03]\
    \x10\x11\n\x1c\n\x04\x04\x05\x02\x02\x12\x03`\x04'\x1a\x0f\x20Gateway\
    \x20time.\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04`\x04]\x12\n\x0c\n\x05\
    \x04\x05\x02\x02\x06\x12\x03`\x04\x1d\n\x0c\n\x05\x04\x05\x02\x02\x01\
    \x12\x03`\x1e\"\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03`%&\n\x20\n\x04\
    \x04\x05\x02\x03\x12\x03c\x04!\x1a\x13\x20Gateway\x20location.\n\n\r\n\
    \x05\x04\x05\x02\x03\x04\x12\x04c\x04`'\n\x0c\n\x05\x04\x05\x02\x03\x06\
    \x12\x03c\x04\x13\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03c\x14\x1c\n\x0c\
    \n\x05\x04\x05\x02\x03\x03\x12\x03c\x1f\x20\ns\n\x04\x04\x05\x02\x04\x12\
    \x03g\x04\x1e\x1af\x20Gateway\x20configuration\x20version\x20(this\x20ma\
    ps\x20to\x20the\x20config_version\x20sent\n\x20by\x20LoRa\x20Server\x20t\
    o\x20the\x20gateway).\n\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04g\x04c!\n\
    \x0c\n\x05\x04\x05\x02\x04\x05\x12\x03g\x04\n\n\x0c\n\x05\x04\x05\x02\
    \x04\x01\x12\x03g\x0b\x19\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03g\x1c\
    \x1d\n0\n\x04\x04\x05\x02\x05\x12\x03j\x04#\x1a#\x20Number\x20of\x20radi\
    o\x20packets\x20received.\n\n\r\n\x05\x04\x05\x02\x05\x04\x12\x04j\x04g\
    \x1e\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03j\x04\n\n\x0c\n\x05\x04\x05\
    \x02\x05\x01\x12\x03j\x0b\x1e\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03j!\
    \"\nC\n\x04\x04\x05\x02\x06\x12\x03m\x04J\x1a6\x20Number\x20of\x20radio\
    \x20packets\x20received\x20with\x20valid\x20PHY\x20CRC.\n\n\r\n\x05\x04\
    \x05\x02\x06\x04\x12\x04m\x04j#\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\x03m\
    \x04\n\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03m\x0b!\n\x0c\n\x05\x04\x05\
    \x02\x06\x03\x12\x03m$%\n\x0c\n\x05\x04\x05\x02\x06\x08\x12\x03m&I\n\x0c\
    \n\x05\x04\x05\x02\x06\n\x12\x03m3H\nD\n\x04\x04\x05\x02\x07\x12\x03p\
    \x04#\x1a7\x20Number\x20of\x20downlink\x20packets\x20received\x20for\x20\
    transmission.\n\n\r\n\x05\x04\x05\x02\x07\x04\x12\x04p\x04mJ\n\x0c\n\x05\
    \x04\x05\x02\x07\x05\x12\x03p\x04\n\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\
    \x03p\x0b\x1e\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03p!\"\n2\n\x04\x04\
    \x05\x02\x08\x12\x03s\x04\"\x1a%\x20Number\x20of\x20downlink\x20packets\
    \x20emitted.\n\n\r\n\x05\x04\x05\x02\x08\x04\x12\x04s\x04p#\n\x0c\n\x05\
    \x04\x05\x02\x08\x05\x12\x03s\x04\n\n\x0c\n\x05\x04\x05\x02\x08\x01\x12\
    \x03s\x0b\x1d\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03s\x20!\n,\n\x04\x04\
    \x05\x02\t\x12\x03v\x04'\x1a\x1f\x20Additional\x20gateway\x20meta-data.\
    \n\n\r\n\x05\x04\x05\x02\t\x04\x12\x04v\x04s\"\n\x0c\n\x05\x04\x05\x02\t\
    \x06\x12\x03v\x04\x17\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03v\x18!\n\x0c\
    \n\x05\x04\x05\x02\t\x03\x12\x03v$&\nI\n\x04\x04\x05\x02\n\x12\x03z\x040\
    \x1a<\x20Stats\x20ID\x20(UUID).\n\x20Unique\x20identifier\x20for\x20the\
    \x20gateway\x20stats.\n\n\r\n\x05\x04\x05\x02\n\x04\x12\x04z\x04v'\n\x0c\
    \n\x05\x04\x05\x02\n\x05\x12\x03z\x04\t\n\x0c\n\x05\x04\x05\x02\n\x01\
    \x12\x03z\n\x12\n\x0c\n\x05\x04\x05\x02\n\x03\x12\x03z\x15\x17\n\x0c\n\
    \x05\x04\x05\x02\n\x08\x12\x03z\x18/\n\x0c\n\x05\x04\x05\x02\n\n\x12\x03\
    z%.\n\x0b\n\x02\x04\x06\x12\x05}\0\xae\x01\x01\n\n\n\x03\x04\x06\x01\x12\
    \x03}\x08\x14\n\x1a\n\x04\x04\x06\x02\0\x12\x03\x7f\x043\x1a\r\x20Gatewa\
    y\x20ID.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x7f\x04}\x16\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03\x7f\x04\t\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03\x7f\n\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03\x7f\x17\x18\n\x0c\n\
    \x05\x04\x06\x02\0\x08\x12\x03\x7f\x192\n\x0c\n\x05\x04\x06\x02\0\n\x12\
    \x03\x7f&1\nE\n\x04\x04\x06\x02\x01\x12\x04\x82\x01\x04'\x1a7\x20RX\x20t\
    ime\x20(only\x20set\x20when\x20the\x20gateway\x20has\x20a\x20GPS\x20modu\
    le).\n\n\x0e\n\x05\x04\x06\x02\x01\x04\x12\x05\x82\x01\x04\x7f3\n\r\n\
    \x05\x04\x06\x02\x01\x06\x12\x04\x82\x01\x04\x1d\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\x82\x01\x1e\"\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x82\
    \x01%&\nU\n\x04\x04\x06\x02\x02\x12\x04\x85\x01\x04X\x1aG\x20RX\x20time\
    \x20since\x20GPS\x20epoch\x20(only\x20set\x20when\x20the\x20gateway\x20h\
    as\x20a\x20GPS\x20module).\n\n\x0f\n\x05\x04\x06\x02\x02\x04\x12\x06\x85\
    \x01\x04\x82\x01'\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\x85\x01\x04\x1c\
    \n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\x85\x01\x1d1\n\r\n\x05\x04\x06\
    \x02\x02\x03\x12\x04\x85\x0145\n\r\n\x05\x04\x06\x02\x02\x08\x12\x04\x85\
    \x016W\n\r\n\x05\x04\x06\x02\x02\n\x12\x04\x85\x01CV\n\x15\n\x04\x04\x06\
    \x02\x03\x12\x04\x88\x01\x04\x13\x1a\x07\x20RSSI.\n\n\x0f\n\x05\x04\x06\
    \x02\x03\x04\x12\x06\x88\x01\x04\x85\x01X\n\r\n\x05\x04\x06\x02\x03\x05\
    \x12\x04\x88\x01\x04\t\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x88\x01\n\
    \x0e\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\x88\x01\x11\x12\n\x19\n\x04\
    \x04\x06\x02\x04\x12\x04\x8b\x01\x040\x1a\x0b\x20LoRa\x20SNR.\n\n\x0f\n\
    \x05\x04\x06\x02\x04\x04\x12\x06\x8b\x01\x04\x88\x01\x13\n\r\n\x05\x04\
    \x06\x02\x04\x05\x12\x04\x8b\x01\x04\n\n\r\n\x05\x04\x06\x02\x04\x01\x12\
    \x04\x8b\x01\x0b\x13\n\r\n\x05\x04\x06\x02\x04\x03\x12\x04\x8b\x01\x16\
    \x17\n\r\n\x05\x04\x06\x02\x04\x08\x12\x04\x8b\x01\x18/\n\r\n\x05\x04\
    \x06\x02\x04\n\x12\x04\x8b\x01%.\n\x18\n\x04\x04\x06\x02\x05\x12\x04\x8e\
    \x01\x04\x17\x1a\n\x20Channel.\n\n\x0f\n\x05\x04\x06\x02\x05\x04\x12\x06\
    \x8e\x01\x04\x8b\x010\n\r\n\x05\x04\x06\x02\x05\x05\x12\x04\x8e\x01\x04\
    \n\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\x8e\x01\x0b\x12\n\r\n\x05\x04\
    \x06\x02\x05\x03\x12\x04\x8e\x01\x15\x16\n\x19\n\x04\x04\x06\x02\x06\x12\
    \x04\x91\x01\x04\x18\x1a\x0b\x20RF\x20Chain.\n\n\x0f\n\x05\x04\x06\x02\
    \x06\x04\x12\x06\x91\x01\x04\x8e\x01\x17\n\r\n\x05\x04\x06\x02\x06\x05\
    \x12\x04\x91\x01\x04\n\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\x91\x01\x0b\
    \x13\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\x91\x01\x16\x17\n\x16\n\x04\
    \x04\x06\x02\x07\x12\x04\x94\x01\x04\x15\x1a\x08\x20Board.\n\n\x0f\n\x05\
    \x04\x06\x02\x07\x04\x12\x06\x94\x01\x04\x91\x01\x18\n\r\n\x05\x04\x06\
    \x02\x07\x05\x12\x04\x94\x01\x04\n\n\r\n\x05\x04\x06\x02\x07\x01\x12\x04\
    \x94\x01\x0b\x10\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\x94\x01\x13\x14\n\
    \x18\n\x04\x04\x06\x02\x08\x12\x04\x97\x01\x04\x18\x1a\n\x20Antenna.\n\n\
    \x0f\n\x05\x04\x06\x02\x08\x04\x12\x06\x97\x01\x04\x94\x01\x15\n\r\n\x05\
    \x04\x06\x02\x08\x05\x12\x04\x97\x01\x04\n\n\r\n\x05\x04\x06\x02\x08\x01\
    \x12\x04\x97\x01\x0b\x12\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\x97\x01\
    \x15\x17\n\x19\n\x04\x04\x06\x02\t\x12\x04\x9a\x01\x04\"\x1a\x0b\x20Loca\
    tion.\n\n\x0f\n\x05\x04\x06\x02\t\x04\x12\x06\x9a\x01\x04\x97\x01\x18\n\
    \r\n\x05\x04\x06\x02\t\x06\x12\x04\x9a\x01\x04\x13\n\r\n\x05\x04\x06\x02\
    \t\x01\x12\x04\x9a\x01\x14\x1c\n\r\n\x05\x04\x06\x02\t\x03\x12\x04\x9a\
    \x01\x1f!\n$\n\x04\x04\x06\x02\n\x12\x04\x9d\x01\x04/\x1a\x16\x20Fine-ti\
    mestamp\x20type.\n\n\x0f\n\x05\x04\x06\x02\n\x04\x12\x06\x9d\x01\x04\x9a\
    \x01\"\n\r\n\x05\x04\x06\x02\n\x06\x12\x04\x9d\x01\x04\x15\n\r\n\x05\x04\
    \x06\x02\n\x01\x12\x04\x9d\x01\x16)\n\r\n\x05\x04\x06\x02\n\x03\x12\x04\
    \x9d\x01,.\n&\n\x04\x04\x06\x08\0\x12\x06\xa0\x01\x04\xa6\x01\x05\x1a\
    \x16\x20Fine-timestamp\x20data.\n\n\r\n\x05\x04\x06\x08\0\x01\x12\x04\
    \xa0\x01\n\x18\n.\n\x04\x04\x06\x02\x0b\x12\x04\xa2\x01\x08=\x1a\x20\x20\
    Encrypted\x20fine-timestamp\x20data.\n\n\r\n\x05\x04\x06\x02\x0b\x06\x12\
    \x04\xa2\x01\x08\x1e\n\r\n\x05\x04\x06\x02\x0b\x01\x12\x04\xa2\x01\x1f7\
    \n\r\n\x05\x04\x06\x02\x0b\x03\x12\x04\xa2\x01:<\n*\n\x04\x04\x06\x02\
    \x0c\x12\x04\xa5\x01\x085\x1a\x1c\x20Plain\x20fine-timestamp\x20data.\n\
    \n\r\n\x05\x04\x06\x02\x0c\x06\x12\x04\xa5\x01\x08\x1a\n\r\n\x05\x04\x06\
    \x02\x0c\x01\x12\x04\xa5\x01\x1b/\n\r\n\x05\x04\x06\x02\x0c\x03\x12\x04\
    \xa5\x0124\n)\n\x04\x04\x06\x02\r\x12\x04\xa9\x01\x04\x17\x1a\x1b\x20Gat\
    eway\x20specific\x20context.\n\n\x0f\n\x05\x04\x06\x02\r\x04\x12\x06\xa9\
    \x01\x04\xa6\x01\x05\n\r\n\x05\x04\x06\x02\r\x05\x12\x04\xa9\x01\x04\t\n\
    \r\n\x05\x04\x06\x02\r\x01\x12\x04\xa9\x01\n\x11\n\r\n\x05\x04\x06\x02\r\
    \x03\x12\x04\xa9\x01\x14\x16\n}\n\x04\x04\x06\x02\x0e\x12\x04\xad\x01\
    \x042\x1ao\x20Uplink\x20ID\x20(UUID\x20bytes).\n\x20Unique\x20and\x20ran\
    dom\x20ID\x20which\x20can\x20be\x20used\x20to\x20correlate\x20the\x20upl\
    ink\x20across\x20multiple\x20logs.\n\n\x0f\n\x05\x04\x06\x02\x0e\x04\x12\
    \x06\xad\x01\x04\xa9\x01\x17\n\r\n\x05\x04\x06\x02\x0e\x05\x12\x04\xad\
    \x01\x04\t\n\r\n\x05\x04\x06\x02\x0e\x01\x12\x04\xad\x01\n\x13\n\r\n\x05\
    \x04\x06\x02\x0e\x03\x12\x04\xad\x01\x16\x18\n\r\n\x05\x04\x06\x02\x0e\
    \x08\x12\x04\xad\x01\x191\n\r\n\x05\x04\x06\x02\x0e\n\x12\x04\xad\x01&0\
    \n\x0c\n\x02\x04\x07\x12\x06\xb0\x01\0\xdc\x01\x01\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xb0\x01\x08\x16\n\x1b\n\x04\x04\x07\x02\0\x12\x04\xb2\x01\
    \x043\x1a\r\x20Gateway\x20ID.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\
    \xb2\x01\x04\xb0\x01\x18\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xb2\x01\x04\
    \t\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb2\x01\n\x14\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xb2\x01\x17\x18\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\
    \xb2\x01\x192\n\r\n\x05\x04\x07\x02\0\n\x12\x04\xb2\x01&1\n%\n\x04\x04\
    \x07\x02\x01\x12\x04\xb5\x01\x04\x19\x1a\x17\x20TX\x20frequency\x20(in\
    \x20Hz).\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xb5\x01\x04\xb2\x013\
    \n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xb5\x01\x04\n\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xb5\x01\x0b\x14\n\r\n\x05\x04\x07\x02\x01\x03\x12\
    \x04\xb5\x01\x17\x18\n\"\n\x04\x04\x07\x02\x02\x12\x04\xb8\x01\x04\x14\
    \x1a\x14\x20TX\x20power\x20(in\x20dBm).\n\n\x0f\n\x05\x04\x07\x02\x02\
    \x04\x12\x06\xb8\x01\x04\xb5\x01\x19\n\r\n\x05\x04\x07\x02\x02\x05\x12\
    \x04\xb8\x01\x04\t\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xb8\x01\n\x0f\n\
    \r\n\x05\x04\x07\x02\x02\x03\x12\x04\xb8\x01\x12\x13\n\x1b\n\x04\x04\x07\
    \x02\x03\x12\x04\xbb\x01\x04%\x1a\r\x20Modulation.\n\n\x0f\n\x05\x04\x07\
    \x02\x03\x04\x12\x06\xbb\x01\x04\xb8\x01\x14\n\r\n\x05\x04\x07\x02\x03\
    \x06\x12\x04\xbb\x01\x04\x15\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xbb\
    \x01\x16\x20\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xbb\x01#$\n\x0e\n\x04\
    \x04\x07\x08\0\x12\x06\xbd\x01\x04\xc3\x01\x05\n\r\n\x05\x04\x07\x08\0\
    \x01\x12\x04\xbd\x01\n\x19\n,\n\x04\x04\x07\x02\x04\x12\x04\xbf\x01\x08W\
    \x1a\x1e\x20LoRa\x20modulation\x20information.\n\n\r\n\x05\x04\x07\x02\
    \x04\x06\x12\x04\xbf\x01\x08\x1a\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\
    \xbf\x01\x1b/\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\xbf\x0123\n\r\n\x05\
    \x04\x07\x02\x04\x08\x12\x04\xbf\x014V\n\r\n\x05\x04\x07\x02\x04\n\x12\
    \x04\xbf\x01AU\n+\n\x04\x04\x07\x02\x05\x12\x04\xc2\x01\x082\x1a\x1d\x20\
    FSK\x20modulation\x20information.\n\n\r\n\x05\x04\x07\x02\x05\x06\x12\
    \x04\xc2\x01\x08\x19\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\xc2\x01\x1a-\
    \n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\xc2\x0101\n<\n\x04\x04\x07\x02\
    \x06\x12\x04\xc6\x01\x04\x16\x1a.\x20The\x20board\x20identifier\x20for\
    \x20emitting\x20the\x20frame.\n\n\x0f\n\x05\x04\x07\x02\x06\x04\x12\x06\
    \xc6\x01\x04\xc3\x01\x05\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\xc6\x01\
    \x04\n\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xc6\x01\x0b\x10\n\r\n\x05\
    \x04\x07\x02\x06\x03\x12\x04\xc6\x01\x13\x15\n>\n\x04\x04\x07\x02\x07\
    \x12\x04\xc9\x01\x04\x18\x1a0\x20The\x20antenna\x20identifier\x20for\x20\
    emitting\x20the\x20frame.\n\n\x0f\n\x05\x04\x07\x02\x07\x04\x12\x06\xc9\
    \x01\x04\xc6\x01\x16\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\xc9\x01\x04\n\
    \n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xc9\x01\x0b\x12\n\r\n\x05\x04\x07\
    \x02\x07\x03\x12\x04\xc9\x01\x15\x17\n:\n\x04\x04\x07\x02\x08\x12\x04\
    \xcc\x01\x04\x1f\x1a,\x20Timing\x20defines\x20the\x20downlink\x20timing\
    \x20to\x20use.\n\n\x0f\n\x05\x04\x07\x02\x08\x04\x12\x06\xcc\x01\x04\xc9\
    \x01\x18\n\r\n\x05\x04\x07\x02\x08\x06\x12\x04\xcc\x01\x04\x12\n\r\n\x05\
    \x04\x07\x02\x08\x01\x12\x04\xcc\x01\x13\x19\n\r\n\x05\x04\x07\x02\x08\
    \x03\x12\x04\xcc\x01\x1c\x1e\n\x0e\n\x04\x04\x07\x08\x01\x12\x06\xce\x01\
    \x04\xd7\x01\x05\n\r\n\x05\x04\x07\x08\x01\x01\x12\x04\xce\x01\n\x15\n/\
    \n\x04\x04\x07\x02\t\x12\x04\xd0\x01\x08;\x1a!\x20Immediately\x20timing\
    \x20information.\n\n\r\n\x05\x04\x07\x02\t\x06\x12\x04\xd0\x01\x08\x1d\n\
    \r\n\x05\x04\x07\x02\t\x01\x12\x04\xd0\x01\x1e5\n\r\n\x05\x04\x07\x02\t\
    \x03\x12\x04\xd0\x018:\n7\n\x04\x04\x07\x02\n\x12\x04\xd3\x01\x08/\x1a)\
    \x20Context\x20based\x20delay\x20timing\x20information.\n\n\r\n\x05\x04\
    \x07\x02\n\x06\x12\x04\xd3\x01\x08\x17\n\r\n\x05\x04\x07\x02\n\x01\x12\
    \x04\xd3\x01\x18)\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xd3\x01,.\n-\n\x04\
    \x04\x07\x02\x0b\x12\x04\xd6\x01\x086\x1a\x1f\x20GPS\x20Epoch\x20timing\
    \x20information.\n\n\r\n\x05\x04\x07\x02\x0b\x06\x12\x04\xd6\x01\x08\x1a\
    \n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xd6\x01\x1b0\n\r\n\x05\x04\x07\
    \x02\x0b\x03\x12\x04\xd6\x0135\nu\n\x04\x04\x07\x02\x0c\x12\x04\xdb\x01\
    \x04\x17\x1ag\x20Gateway\x20specific\x20context.\n\x20In\x20case\x20of\
    \x20a\x20Class-A\x20downlink,\x20this\x20contains\x20a\x20copy\x20of\x20\
    the\x20uplink\x20context.\n\n\x0f\n\x05\x04\x07\x02\x0c\x04\x12\x06\xdb\
    \x01\x04\xd7\x01\x05\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\xdb\x01\x04\t\
    \n\r\n\x05\x04\x07\x02\x0c\x01\x12\x04\xdb\x01\n\x11\n\r\n\x05\x04\x07\
    \x02\x0c\x03\x12\x04\xdb\x01\x14\x16\n$\n\x02\x04\x08\x12\x06\xde\x01\0\
    \xe0\x01\x01\"\x16\x20Not\x20implemented\x20yet.\n\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\xde\x01\x08\x1d\n\x0c\n\x02\x04\t\x12\x06\xe3\x01\0\xe7\x01\
    \x01\n\x0b\n\x03\x04\t\x01\x12\x04\xe3\x01\x08\x17\nz\n\x04\x04\t\x02\0\
    \x12\x04\xe6\x01\x04'\x1al\x20Delay\x20(duration).\n\x20The\x20delay\x20\
    will\x20be\x20added\x20to\x20the\x20gateway\x20internal\x20timing,\x20pr\
    ovided\x20by\x20the\x20context\x20object.\n\n\x0f\n\x05\x04\t\x02\0\x04\
    \x12\x06\xe6\x01\x04\xe3\x01\x19\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xe6\
    \x01\x04\x1c\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xe6\x01\x1d\"\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xe6\x01%&\n\x0c\n\x02\x04\n\x12\x06\xe9\x01\0\
    \xec\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xe9\x01\x08\x1a\n)\n\x04\x04\
    \n\x02\0\x12\x04\xeb\x01\x04X\x1a\x1b\x20Duration\x20since\x20GPS\x20Epo\
    ch.\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\xeb\x01\x04\xe9\x01\x1c\n\r\n\
    \x05\x04\n\x02\0\x06\x12\x04\xeb\x01\x04\x1c\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\xeb\x01\x1d1\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xeb\x0145\n\r\n\
    \x05\x04\n\x02\0\x08\x12\x04\xeb\x016W\n\r\n\x05\x04\n\x02\0\n\x12\x04\
    \xeb\x01CV\n\x0c\n\x02\x04\x0b\x12\x06\xee\x01\0\xf7\x01\x01\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xee\x01\x08\x13\n\x1b\n\x04\x04\x0b\x02\0\x12\x04\
    \xf0\x01\x04\x1a\x1a\r\x20PHYPayload.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\
    \x12\x06\xf0\x01\x04\xee\x01\x15\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xf0\
    \x01\x04\t\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xf0\x01\n\x15\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xf0\x01\x18\x19\n\x1d\n\x04\x04\x0b\x02\x01\
    \x12\x04\xf3\x01\x04\x1d\x1a\x0f\x20TX\x20meta-data.\n\n\x0f\n\x05\x04\
    \x0b\x02\x01\x04\x12\x06\xf3\x01\x04\xf0\x01\x1a\n\r\n\x05\x04\x0b\x02\
    \x01\x06\x12\x04\xf3\x01\x04\x10\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\
    \xf3\x01\x11\x18\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xf3\x01\x1b\x1c\n\
    \x1d\n\x04\x04\x0b\x02\x02\x12\x04\xf6\x01\x04\x1d\x1a\x0f\x20RX\x20meta\
    -data.\n\n\x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\xf6\x01\x04\xf3\x01\x1d\
    \n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xf6\x01\x04\x10\n\r\n\x05\x04\x0b\
    \x02\x02\x01\x12\x04\xf6\x01\x11\x18\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\xf6\x01\x1b\x1c\n\x0c\n\x02\x04\x0c\x12\x06\xf9\x01\0\x82\x02\x01\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\xf9\x01\x08\x16\n\x1b\n\x04\x04\x0c\x02\0\
    \x12\x04\xfb\x01\x04\x1a\x1a\r\x20PHYPayload.\n\n\x0f\n\x05\x04\x0c\x02\
    \0\x04\x12\x06\xfb\x01\x04\xf9\x01\x18\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\xfb\x01\x04\t\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xfb\x01\n\x15\n\r\
    \n\x05\x04\x0c\x02\0\x03\x12\x04\xfb\x01\x18\x19\n\x1d\n\x04\x04\x0c\x02\
    \x01\x12\x04\xfe\x01\x04\x1d\x1a\x0f\x20TX\x20meta-data.\n\n\x0f\n\x05\
    \x04\x0c\x02\x01\x04\x12\x06\xfe\x01\x04\xfb\x01\x1a\n\r\n\x05\x04\x0c\
    \x02\x01\x06\x12\x04\xfe\x01\x04\x10\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xfe\x01\x11\x18\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xfe\x01\x1b\
    \x1c\n!\n\x04\x04\x0c\x02\x02\x12\x04\x81\x02\x04&\x1a\x13\x20RX\x20meta\
    -data\x20set.\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\x81\x02\x04\x0c\n\
    \r\n\x05\x04\x0c\x02\x02\x06\x12\x04\x81\x02\r\x19\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\x81\x02\x1a!\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x81\
    \x02$%\n\x0c\n\x02\x04\r\x12\x06\x84\x02\0\x91\x02\x01\n\x0b\n\x03\x04\r\
    \x01\x12\x04\x84\x02\x08\x15\n\x1b\n\x04\x04\r\x02\0\x12\x04\x86\x02\x04\
    \x1a\x1a\r\x20PHYPayload.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\x86\x02\
    \x04\x84\x02\x17\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x86\x02\x04\t\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\x86\x02\n\x15\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\x86\x02\x18\x19\n\x1d\n\x04\x04\r\x02\x01\x12\x04\x89\x02\x04\x1f\
    \x1a\x0f\x20TX\x20meta-data.\n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x89\
    \x02\x04\x86\x02\x1a\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x89\x02\x04\x12\
    \n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x89\x02\x13\x1a\n\r\n\x05\x04\r\x02\
    \x01\x03\x12\x04\x89\x02\x1d\x1e\nS\n\x04\x04\r\x02\x02\x12\x04\x8d\x02\
    \x04\x15\x1aE\x20Token\x20(uint16\x20value).\n\x20Deprecated:\x20will\
    \x20be\x20replaced\x20by\x20downlink_id.\n\n\x0f\n\x05\x04\r\x02\x02\x04\
    \x12\x06\x8d\x02\x04\x89\x02\x1f\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x8d\
    \x02\x04\n\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\x8d\x02\x0b\x10\n\r\n\x05\
    \x04\r\x02\x02\x03\x12\x04\x8d\x02\x13\x14\n#\n\x04\x04\r\x02\x03\x12\
    \x04\x90\x02\x045\x1a\x15\x20Downlink\x20ID\x20(UUID).\n\n\x0f\n\x05\x04\
    \r\x02\x03\x04\x12\x06\x90\x02\x04\x8d\x02\x15\n\r\n\x05\x04\r\x02\x03\
    \x05\x12\x04\x90\x02\x04\t\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\x90\x02\n\
    \x15\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x90\x02\x18\x19\n\r\n\x05\x04\r\
    \x02\x03\x08\x12\x04\x90\x02\x1a4\n\r\n\x05\x04\r\x02\x03\n\x12\x04\x90\
    \x02'3\n\x0c\n\x02\x04\x0e\x12\x06\x93\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x93\x02\x08\x15\n\x1b\n\x04\x04\x0e\x02\0\x12\x04\x95\
    \x02\x043\x1a\r\x20Gateway\x20ID.\n\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\
    \x06\x95\x02\x04\x93\x02\x17\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x95\x02\
    \x04\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x95\x02\n\x14\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\x95\x02\x17\x18\n\r\n\x05\x04\x0e\x02\0\x08\x12\
    \x04\x95\x02\x192\n\r\n\x05\x04\x0e\x02\0\n\x12\x04\x95\x02&1\n%\n\x04\
    \x04\x0e\x02\x01\x12\x04\x98\x02\x04\x15\x1a\x17\x20Token\x20(uint16\x20\
    value).\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\x98\x02\x04\x95\x023\n\
    \r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x98\x02\x04\n\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\x98\x02\x0b\x10\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \x98\x02\x13\x14\n\x16\n\x04\x04\x0e\x02\x02\x12\x04\x9b\x02\x04\x15\x1a\
    \x08\x20Error.\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\x9b\x02\x04\x98\
    \x02\x15\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\x9b\x02\x04\n\n\r\n\x05\
    \x04\x0e\x02\x02\x01\x12\x04\x9b\x02\x0b\x10\n\r\n\x05\x04\x0e\x02\x02\
    \x03\x12\x04\x9b\x02\x13\x14\n#\n\x04\x04\x0e\x02\x03\x12\x04\x9e\x02\
    \x045\x1a\x15\x20Downlink\x20ID\x20(UUID).\n\n\x0f\n\x05\x04\x0e\x02\x03\
    \x04\x12\x06\x9e\x02\x04\x9b\x02\x15\n\r\n\x05\x04\x0e\x02\x03\x05\x12\
    \x04\x9e\x02\x04\t\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x9e\x02\n\x15\n\
    \r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x9e\x02\x18\x19\n\r\n\x05\x04\x0e\
    \x02\x03\x08\x12\x04\x9e\x02\x1a4\n\r\n\x05\x04\x0e\x02\x03\n\x12\x04\
    \x9e\x02'3\n\x0c\n\x02\x04\x0f\x12\x06\xa1\x02\0\xaa\x02\x01\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\xa1\x02\x08\x1c\n\x1b\n\x04\x04\x0f\x02\0\x12\x04\
    \xa3\x02\x043\x1a\r\x20Gateway\x20ID.\n\n\x0f\n\x05\x04\x0f\x02\0\x04\
    \x12\x06\xa3\x02\x04\xa1\x02\x1e\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xa3\
    \x02\x04\t\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa3\x02\n\x14\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xa3\x02\x17\x18\n\r\n\x05\x04\x0f\x02\0\x08\
    \x12\x04\xa3\x02\x192\n\r\n\x05\x04\x0f\x02\0\n\x12\x04\xa3\x02&1\n&\n\
    \x04\x04\x0f\x02\x01\x12\x04\xa6\x02\x04\x17\x1a\x18\x20Configuration\
    \x20version.\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\xa6\x02\x04\xa3\
    \x023\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xa6\x02\x04\n\n\r\n\x05\x04\
    \x0f\x02\x01\x01\x12\x04\xa6\x02\x0b\x12\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xa6\x02\x15\x16\n\x19\n\x04\x04\x0f\x02\x02\x12\x04\xa9\x02\x04\
    /\x1a\x0b\x20Channels.\n\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xa9\x02\
    \x04\x0c\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xa9\x02\r!\n\r\n\x05\x04\
    \x0f\x02\x02\x01\x12\x04\xa9\x02\"*\n\r\n\x05\x04\x0f\x02\x02\x03\x12\
    \x04\xa9\x02-.\n\x0c\n\x02\x04\x10\x12\x06\xac\x02\0\xc0\x02\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xac\x02\x08\x1c\n\x1f\n\x04\x04\x10\x02\0\x12\
    \x04\xae\x02\x04\x19\x1a\x11\x20Frequency\x20(Hz).\n\n\x0f\n\x05\x04\x10\
    \x02\0\x04\x12\x06\xae\x02\x04\xac\x02\x1e\n\r\n\x05\x04\x10\x02\0\x05\
    \x12\x04\xae\x02\x04\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xae\x02\x0b\
    \x14\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xae\x02\x17\x18\n#\n\x04\x04\
    \x10\x02\x01\x12\x04\xb1\x02\x04%\x1a\x15\x20Channel\x20modulation.\n\n\
    \x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\xb1\x02\x04\xae\x02\x19\n\r\n\x05\
    \x04\x10\x02\x01\x06\x12\x04\xb1\x02\x04\x15\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\xb1\x02\x16\x20\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb1\
    \x02#$\n\x0e\n\x04\x04\x10\x08\0\x12\x06\xb3\x02\x04\xb9\x02\x05\n\r\n\
    \x05\x04\x10\x08\0\x01\x12\x04\xb3\x02\n\x1b\n'\n\x04\x04\x10\x02\x02\
    \x12\x04\xb5\x02\x08]\x1a\x19\x20LoRa\x20modulation\x20config.\n\n\r\n\
    \x05\x04\x10\x02\x02\x06\x12\x04\xb5\x02\x08\x1c\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\xb5\x02\x1d3\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xb5\
    \x0267\n\r\n\x05\x04\x10\x02\x02\x08\x12\x04\xb5\x028\\\n\r\n\x05\x04\
    \x10\x02\x02\n\x12\x04\xb5\x02E[\n&\n\x04\x04\x10\x02\x03\x12\x04\xb8\
    \x02\x086\x1a\x18\x20FSK\x20modulation\x20config.\n\n\r\n\x05\x04\x10\
    \x02\x03\x06\x12\x04\xb8\x02\x08\x1b\n\r\n\x05\x04\x10\x02\x03\x01\x12\
    \x04\xb8\x02\x1c1\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xb8\x0245\n\x1c\
    \n\x04\x04\x10\x02\x04\x12\x04\xbc\x02\x04\x15\x1a\x0e\x20Board\x20index\
    .\n\n\x0f\n\x05\x04\x10\x02\x04\x04\x12\x06\xbc\x02\x04\xb9\x02\x05\n\r\
    \n\x05\x04\x10\x02\x04\x05\x12\x04\xbc\x02\x04\n\n\r\n\x05\x04\x10\x02\
    \x04\x01\x12\x04\xbc\x02\x0b\x10\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\
    \xbc\x02\x13\x14\n7\n\x04\x04\x10\x02\x05\x12\x04\xbf\x02\x04\x1b\x1a)\
    \x20Demodulator\x20index\x20(of\x20the\x20given\x20board).\n\n\x0f\n\x05\
    \x04\x10\x02\x05\x04\x12\x06\xbf\x02\x04\xbc\x02\x15\n\r\n\x05\x04\x10\
    \x02\x05\x05\x12\x04\xbf\x02\x04\n\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\
    \xbf\x02\x0b\x16\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xbf\x02\x19\x1a\n\
    \x0c\n\x02\x04\x11\x12\x06\xc2\x02\0\xc8\x02\x01\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xc2\x02\x08\x1c\n\x1a\n\x04\x04\x11\x02\0\x12\x04\xc4\x02\x04\
    \x19\x1a\x0c\x20Bandwidth.\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xc4\
    \x02\x04\xc2\x02\x1e\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xc4\x02\x04\n\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xc4\x02\x0b\x14\n\r\n\x05\x04\x11\x02\
    \0\x03\x12\x04\xc4\x02\x17\x18\n\"\n\x04\x04\x11\x02\x01\x12\x04\xc7\x02\
    \x04*\x1a\x14\x20Spreading-factors.\n\n\r\n\x05\x04\x11\x02\x01\x04\x12\
    \x04\xc7\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xc7\x02\r\x13\
    \n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xc7\x02\x14%\n\r\n\x05\x04\x11\
    \x02\x01\x03\x12\x04\xc7\x02()\n\x0c\n\x02\x04\x12\x12\x06\xca\x02\0\xd0\
    \x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xca\x02\x08\x1b\n\x1a\n\x04\x04\
    \x12\x02\0\x12\x04\xcc\x02\x04\x19\x1a\x0c\x20Bandwidth.\n\n\x0f\n\x05\
    \x04\x12\x02\0\x04\x12\x06\xcc\x02\x04\xca\x02\x1d\n\r\n\x05\x04\x12\x02\
    \0\x05\x12\x04\xcc\x02\x04\n\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xcc\x02\
    \x0b\x14\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xcc\x02\x17\x18\n\x18\n\x04\
    \x04\x12\x02\x01\x12\x04\xcf\x02\x04\x17\x1a\n\x20Bitrate.\n\n\x0f\n\x05\
    \x04\x12\x02\x01\x04\x12\x06\xcf\x02\x04\xcc\x02\x19\n\r\n\x05\x04\x12\
    \x02\x01\x05\x12\x04\xcf\x02\x04\n\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xcf\x02\x0b\x12\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xcf\x02\x15\x16\n\
    \x0c\n\x02\x04\x13\x12\x06\xd2\x02\0\xe4\x02\x01\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\xd2\x02\x08!\n\x1b\n\x04\x04\x13\x02\0\x12\x04\xd4\x02\x043\x1a\
    \r\x20Gateway\x20ID.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xd4\x02\x04\
    \xd2\x02#\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xd4\x02\x04\t\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\xd4\x02\n\x14\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\xd4\x02\x17\x18\n\r\n\x05\x04\x13\x02\0\x08\x12\x04\xd4\x02\x192\n\
    \r\n\x05\x04\x13\x02\0\n\x12\x04\xd4\x02&1\nr\n\x04\x04\x13\x02\x01\x12\
    \x04\xd8\x02\x04\x17\x1ad\x20Command\x20to\x20execute.\n\x20This\x20comm\
    and\x20must\x20be\x20pre-configured\x20in\x20the\x20LoRa\x20Gateway\x20B\
    ridge\x20configuration.\n\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\xd8\
    \x02\x04\xd4\x023\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xd8\x02\x04\n\n\
    \r\n\x05\x04\x13\x02\x01\x01\x12\x04\xd8\x02\x0b\x12\n\r\n\x05\x04\x13\
    \x02\x01\x03\x12\x04\xd8\x02\x15\x16\n\x7f\n\x04\x04\x13\x02\x02\x12\x04\
    \xdd\x02\x04,\x1aq\x20Execution\x20request\x20ID\x20(UUID).\n\x20The\x20\
    same\x20token\x20will\x20be\x20returned\x20when\x20the\x20execution\x20o\
    f\x20the\x20command\x20has\n\x20completed.\n\n\x0f\n\x05\x04\x13\x02\x02\
    \x04\x12\x06\xdd\x02\x04\xd8\x02\x17\n\r\n\x05\x04\x13\x02\x02\x05\x12\
    \x04\xdd\x02\x04\t\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xdd\x02\n\x10\n\
    \r\n\x05\x04\x13\x02\x02\x03\x12\x04\xdd\x02\x13\x14\n\r\n\x05\x04\x13\
    \x02\x02\x08\x12\x04\xdd\x02\x15+\n\r\n\x05\x04\x13\x02\x02\n\x12\x04\
    \xdd\x02\"*\n\x1f\n\x04\x04\x13\x02\x03\x12\x04\xe0\x02\x04\x14\x1a\x11\
    \x20Standard\x20input.\n\n\x0f\n\x05\x04\x13\x02\x03\x04\x12\x06\xe0\x02\
    \x04\xdd\x02,\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\xe0\x02\x04\t\n\r\n\
    \x05\x04\x13\x02\x03\x01\x12\x04\xe0\x02\n\x0f\n\r\n\x05\x04\x13\x02\x03\
    \x03\x12\x04\xe0\x02\x12\x13\n&\n\x04\x04\x13\x02\x04\x12\x04\xe3\x02\
    \x04(\x1a\x18\x20Environment\x20variables.\n\n\x0f\n\x05\x04\x13\x02\x04\
    \x04\x12\x06\xe3\x02\x04\xe0\x02\x14\n\r\n\x05\x04\x13\x02\x04\x06\x12\
    \x04\xe3\x02\x04\x17\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xe3\x02\x18#\
    \n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xe3\x02&'\n\x0c\n\x02\x04\x14\x12\
    \x06\xe6\x02\0\xf5\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xe6\x02\x08\"\
    \n\x1b\n\x04\x04\x14\x02\0\x12\x04\xe8\x02\x043\x1a\r\x20Gateway\x20ID.\
    \n\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xe8\x02\x04\xe6\x02$\n\r\n\x05\
    \x04\x14\x02\0\x05\x12\x04\xe8\x02\x04\t\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\xe8\x02\n\x14\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xe8\x02\x17\x18\n\
    \r\n\x05\x04\x14\x02\0\x08\x12\x04\xe8\x02\x192\n\r\n\x05\x04\x14\x02\0\
    \n\x12\x04\xe8\x02&1\n,\n\x04\x04\x14\x02\x01\x12\x04\xeb\x02\x04-\x1a\
    \x1e\x20Execution\x20request\x20ID\x20(UUID).\n\n\x0f\n\x05\x04\x14\x02\
    \x01\x04\x12\x06\xeb\x02\x04\xe8\x023\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\xeb\x02\x04\t\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xeb\x02\n\x11\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\xeb\x02\x14\x15\n\r\n\x05\x04\x14\
    \x02\x01\x08\x12\x04\xeb\x02\x16,\n\r\n\x05\x04\x14\x02\x01\n\x12\x04\
    \xeb\x02#+\n\x20\n\x04\x04\x14\x02\x02\x12\x04\xee\x02\x04\x15\x1a\x12\
    \x20Standard\x20output.\n\n\x0f\n\x05\x04\x14\x02\x02\x04\x12\x06\xee\
    \x02\x04\xeb\x02-\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xee\x02\x04\t\n\
    \r\n\x05\x04\x14\x02\x02\x01\x12\x04\xee\x02\n\x10\n\r\n\x05\x04\x14\x02\
    \x02\x03\x12\x04\xee\x02\x13\x14\n\x1f\n\x04\x04\x14\x02\x03\x12\x04\xf1\
    \x02\x04\x15\x1a\x11\x20Standard\x20error.\n\n\x0f\n\x05\x04\x14\x02\x03\
    \x04\x12\x06\xf1\x02\x04\xee\x02\x15\n\r\n\x05\x04\x14\x02\x03\x05\x12\
    \x04\xf1\x02\x04\t\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xf1\x02\n\x10\n\
    \r\n\x05\x04\x14\x02\x03\x03\x12\x04\xf1\x02\x13\x14\n\x1e\n\x04\x04\x14\
    \x02\x04\x12\x04\xf4\x02\x04\x15\x1a\x10\x20Error\x20message.\n\n\x0f\n\
    \x05\x04\x14\x02\x04\x04\x12\x06\xf4\x02\x04\xf1\x02\x15\n\r\n\x05\x04\
    \x14\x02\x04\x05\x12\x04\xf4\x02\x04\n\n\r\n\x05\x04\x14\x02\x04\x01\x12\
    \x04\xf4\x02\x0b\x10\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xf4\x02\x13\
    \x14\n\xc8\x01\n\x02\x04\x15\x12\x06\xfa\x02\0\x83\x03\x01\x1a\xb9\x01\
    \x20RawPacketForwarderEvent\x20contains\x20a\x20raw\x20packet-forwarder\
    \x20event.\n\x20It\x20can\x20be\x20used\x20to\x20access\x20packet-forwar\
    der\x20features\x20that\x20are\x20not\x20(fully)\n\x20integrated\x20with\
    \x20the\x20ChirpStack\x20Gateway\x20Bridge.\n\n\x0b\n\x03\x04\x15\x01\
    \x12\x04\xfa\x02\x08\x1f\n\x1b\n\x04\x04\x15\x02\0\x12\x04\xfc\x02\x043\
    \x1a\r\x20Gateway\x20ID.\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xfc\x02\
    \x04\xfa\x02!\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xfc\x02\x04\t\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\xfc\x02\n\x14\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\xfc\x02\x17\x18\n\r\n\x05\x04\x15\x02\0\x08\x12\x04\xfc\x02\x19\
    2\n\r\n\x05\x04\x15\x02\0\n\x12\x04\xfc\x02&1\n\x1e\n\x04\x04\x15\x02\
    \x01\x12\x04\xff\x02\x04+\x1a\x10\x20Raw\x20ID\x20(UUID).\n\n\x0f\n\x05\
    \x04\x15\x02\x01\x04\x12\x06\xff\x02\x04\xfc\x023\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\xff\x02\x04\t\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xff\
    \x02\n\x10\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xff\x02\x13\x14\n\r\n\
    \x05\x04\x15\x02\x01\x08\x12\x04\xff\x02\x15*\n\r\n\x05\x04\x15\x02\x01\
    \n\x12\x04\xff\x02\")\n1\n\x04\x04\x15\x02\x02\x12\x04\x82\x03\x04\x16\
    \x1a#\x20Payload\x20contains\x20the\x20raw\x20payload.\n\n\x0f\n\x05\x04\
    \x15\x02\x02\x04\x12\x06\x82\x03\x04\xff\x02+\n\r\n\x05\x04\x15\x02\x02\
    \x05\x12\x04\x82\x03\x04\t\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x82\x03\
    \n\x11\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\x82\x03\x14\x15\n\xca\x01\n\
    \x02\x04\x16\x12\x06\x88\x03\0\x91\x03\x01\x1a\xbb\x01\x20RawPacketForwa\
    rderEvent\x20contains\x20a\x20raw\x20packet-forwarder\x20command.\n\x20I\
    t\x20can\x20be\x20used\x20to\x20access\x20packet-forwarder\x20features\
    \x20that\x20are\x20not\x20(fully)\n\x20integrated\x20with\x20the\x20Chir\
    pStack\x20Gateway\x20Bridge.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\x88\x03\
    \x08!\n\x1b\n\x04\x04\x16\x02\0\x12\x04\x8a\x03\x043\x1a\r\x20Gateway\
    \x20ID.\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\x8a\x03\x04\x88\x03#\n\r\
    \n\x05\x04\x16\x02\0\x05\x12\x04\x8a\x03\x04\t\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\x8a\x03\n\x14\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x8a\x03\
    \x17\x18\n\r\n\x05\x04\x16\x02\0\x08\x12\x04\x8a\x03\x192\n\r\n\x05\x04\
    \x16\x02\0\n\x12\x04\x8a\x03&1\n\x1e\n\x04\x04\x16\x02\x01\x12\x04\x8d\
    \x03\x04+\x1a\x10\x20Raw\x20ID\x20(UUID).\n\n\x0f\n\x05\x04\x16\x02\x01\
    \x04\x12\x06\x8d\x03\x04\x8a\x033\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \x8d\x03\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x8d\x03\n\x10\n\r\n\
    \x05\x04\x16\x02\x01\x03\x12\x04\x8d\x03\x13\x14\n\r\n\x05\x04\x16\x02\
    \x01\x08\x12\x04\x8d\x03\x15*\n\r\n\x05\x04\x16\x02\x01\n\x12\x04\x8d\
    \x03\")\n1\n\x04\x04\x16\x02\x02\x12\x04\x90\x03\x04\x16\x1a#\x20Payload\
    \x20contains\x20the\x20raw\x20payload.\n\n\x0f\n\x05\x04\x16\x02\x02\x04\
    \x12\x06\x90\x03\x04\x8d\x03+\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x90\
    \x03\x04\t\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x90\x03\n\x11\n\r\n\x05\
    \x04\x16\x02\x02\x03\x12\x04\x90\x03\x14\x15b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
