// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `as/external/api/fuotaDeployment.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct FUOTADeployment {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub group_type: super::multicastGroup::MulticastGroupType,
    pub dr: u32,
    pub frequency: u32,
    pub payload: ::std::vec::Vec<u8>,
    pub redundancy: u32,
    pub multicast_timeout: u32,
    pub unicast_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub state: ::std::string::String,
    pub next_step_after: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FUOTADeployment {
    fn default() -> &'a FUOTADeployment {
        <FUOTADeployment as ::protobuf::Message>::default_instance()
    }
}

impl FUOTADeployment {
    pub fn new() -> FUOTADeployment {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .api.MulticastGroupType group_type = 3;


    pub fn get_group_type(&self) -> super::multicastGroup::MulticastGroupType {
        self.group_type
    }
    pub fn clear_group_type(&mut self) {
        self.group_type = super::multicastGroup::MulticastGroupType::CLASS_C;
    }

    // Param is passed by value, moved
    pub fn set_group_type(&mut self, v: super::multicastGroup::MulticastGroupType) {
        self.group_type = v;
    }

    // uint32 dr = 4;


    pub fn get_dr(&self) -> u32 {
        self.dr
    }
    pub fn clear_dr(&mut self) {
        self.dr = 0;
    }

    // Param is passed by value, moved
    pub fn set_dr(&mut self, v: u32) {
        self.dr = v;
    }

    // uint32 frequency = 5;


    pub fn get_frequency(&self) -> u32 {
        self.frequency
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = v;
    }

    // bytes payload = 6;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    // uint32 redundancy = 7;


    pub fn get_redundancy(&self) -> u32 {
        self.redundancy
    }
    pub fn clear_redundancy(&mut self) {
        self.redundancy = 0;
    }

    // Param is passed by value, moved
    pub fn set_redundancy(&mut self, v: u32) {
        self.redundancy = v;
    }

    // uint32 multicast_timeout = 8;


    pub fn get_multicast_timeout(&self) -> u32 {
        self.multicast_timeout
    }
    pub fn clear_multicast_timeout(&mut self) {
        self.multicast_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_multicast_timeout(&mut self, v: u32) {
        self.multicast_timeout = v;
    }

    // .google.protobuf.Duration unicast_timeout = 9;


    pub fn get_unicast_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.unicast_timeout.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_unicast_timeout(&mut self) {
        self.unicast_timeout.clear();
    }

    pub fn has_unicast_timeout(&self) -> bool {
        self.unicast_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unicast_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.unicast_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unicast_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.unicast_timeout.is_none() {
            self.unicast_timeout.set_default();
        }
        self.unicast_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_unicast_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.unicast_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // string state = 10;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp next_step_after = 11;


    pub fn get_next_step_after(&self) -> &::protobuf::well_known_types::Timestamp {
        self.next_step_after.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_next_step_after(&mut self) {
        self.next_step_after.clear();
    }

    pub fn has_next_step_after(&self) -> bool {
        self.next_step_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_step_after(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.next_step_after = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_step_after(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.next_step_after.is_none() {
            self.next_step_after.set_default();
        }
        self.next_step_after.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_step_after(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.next_step_after.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for FUOTADeployment {
    fn is_initialized(&self) -> bool {
        for v in &self.unicast_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.next_step_after {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.group_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dr = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.redundancy = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.multicast_timeout = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unicast_timeout)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.next_step_after)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.group_type != super::multicastGroup::MulticastGroupType::CLASS_C {
            my_size += ::protobuf::rt::enum_size(3, self.group_type);
        }
        if self.dr != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dr, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frequency != 0 {
            my_size += ::protobuf::rt::value_size(5, self.frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.payload);
        }
        if self.redundancy != 0 {
            my_size += ::protobuf::rt::value_size(7, self.redundancy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.multicast_timeout != 0 {
            my_size += ::protobuf::rt::value_size(8, self.multicast_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unicast_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.state);
        }
        if let Some(ref v) = self.next_step_after.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.group_type != super::multicastGroup::MulticastGroupType::CLASS_C {
            os.write_enum(3, self.group_type.value())?;
        }
        if self.dr != 0 {
            os.write_uint32(4, self.dr)?;
        }
        if self.frequency != 0 {
            os.write_uint32(5, self.frequency)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(6, &self.payload)?;
        }
        if self.redundancy != 0 {
            os.write_uint32(7, self.redundancy)?;
        }
        if self.multicast_timeout != 0 {
            os.write_uint32(8, self.multicast_timeout)?;
        }
        if let Some(ref v) = self.unicast_timeout.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.state.is_empty() {
            os.write_string(10, &self.state)?;
        }
        if let Some(ref v) = self.next_step_after.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FUOTADeployment {
        FUOTADeployment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &FUOTADeployment| { &m.id },
                    |m: &mut FUOTADeployment| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &FUOTADeployment| { &m.name },
                    |m: &mut FUOTADeployment| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::multicastGroup::MulticastGroupType>>(
                    "group_type",
                    |m: &FUOTADeployment| { &m.group_type },
                    |m: &mut FUOTADeployment| { &mut m.group_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dr",
                    |m: &FUOTADeployment| { &m.dr },
                    |m: &mut FUOTADeployment| { &mut m.dr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "frequency",
                    |m: &FUOTADeployment| { &m.frequency },
                    |m: &mut FUOTADeployment| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &FUOTADeployment| { &m.payload },
                    |m: &mut FUOTADeployment| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "redundancy",
                    |m: &FUOTADeployment| { &m.redundancy },
                    |m: &mut FUOTADeployment| { &mut m.redundancy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "multicast_timeout",
                    |m: &FUOTADeployment| { &m.multicast_timeout },
                    |m: &mut FUOTADeployment| { &mut m.multicast_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "unicast_timeout",
                    |m: &FUOTADeployment| { &m.unicast_timeout },
                    |m: &mut FUOTADeployment| { &mut m.unicast_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "state",
                    |m: &FUOTADeployment| { &m.state },
                    |m: &mut FUOTADeployment| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "next_step_after",
                    |m: &FUOTADeployment| { &m.next_step_after },
                    |m: &mut FUOTADeployment| { &mut m.next_step_after },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FUOTADeployment>(
                    "FUOTADeployment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FUOTADeployment {
        static mut instance: ::protobuf::lazy::Lazy<FUOTADeployment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FUOTADeployment,
        };
        unsafe {
            instance.get(FUOTADeployment::new)
        }
    }
}

impl ::protobuf::Clear for FUOTADeployment {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.group_type = super::multicastGroup::MulticastGroupType::CLASS_C;
        self.dr = 0;
        self.frequency = 0;
        self.payload.clear();
        self.redundancy = 0;
        self.multicast_timeout = 0;
        self.unicast_timeout.clear();
        self.state.clear();
        self.next_step_after.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FUOTADeployment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FUOTADeployment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FUOTADeploymentListItem {
    // message fields
    pub id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub name: ::std::string::String,
    pub state: ::std::string::String,
    pub next_step_after: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FUOTADeploymentListItem {
    fn default() -> &'a FUOTADeploymentListItem {
        <FUOTADeploymentListItem as ::protobuf::Message>::default_instance()
    }
}

impl FUOTADeploymentListItem {
    pub fn new() -> FUOTADeploymentListItem {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string state = 5;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp next_step_after = 6;


    pub fn get_next_step_after(&self) -> &::protobuf::well_known_types::Timestamp {
        self.next_step_after.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_next_step_after(&mut self) {
        self.next_step_after.clear();
    }

    pub fn has_next_step_after(&self) -> bool {
        self.next_step_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_step_after(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.next_step_after = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_step_after(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.next_step_after.is_none() {
            self.next_step_after.set_default();
        }
        self.next_step_after.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_step_after(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.next_step_after.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for FUOTADeploymentListItem {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.next_step_after {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.next_step_after)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.state);
        }
        if let Some(ref v) = self.next_step_after.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.state.is_empty() {
            os.write_string(5, &self.state)?;
        }
        if let Some(ref v) = self.next_step_after.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FUOTADeploymentListItem {
        FUOTADeploymentListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &FUOTADeploymentListItem| { &m.id },
                    |m: &mut FUOTADeploymentListItem| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created_at",
                    |m: &FUOTADeploymentListItem| { &m.created_at },
                    |m: &mut FUOTADeploymentListItem| { &mut m.created_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated_at",
                    |m: &FUOTADeploymentListItem| { &m.updated_at },
                    |m: &mut FUOTADeploymentListItem| { &mut m.updated_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &FUOTADeploymentListItem| { &m.name },
                    |m: &mut FUOTADeploymentListItem| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "state",
                    |m: &FUOTADeploymentListItem| { &m.state },
                    |m: &mut FUOTADeploymentListItem| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "next_step_after",
                    |m: &FUOTADeploymentListItem| { &m.next_step_after },
                    |m: &mut FUOTADeploymentListItem| { &mut m.next_step_after },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FUOTADeploymentListItem>(
                    "FUOTADeploymentListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FUOTADeploymentListItem {
        static mut instance: ::protobuf::lazy::Lazy<FUOTADeploymentListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FUOTADeploymentListItem,
        };
        unsafe {
            instance.get(FUOTADeploymentListItem::new)
        }
    }
}

impl ::protobuf::Clear for FUOTADeploymentListItem {
    fn clear(&mut self) {
        self.id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.name.clear();
        self.state.clear();
        self.next_step_after.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FUOTADeploymentListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FUOTADeploymentListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFUOTADeploymentForDeviceRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    pub fuota_deployment: ::protobuf::SingularPtrField<FUOTADeployment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFUOTADeploymentForDeviceRequest {
    fn default() -> &'a CreateFUOTADeploymentForDeviceRequest {
        <CreateFUOTADeploymentForDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateFUOTADeploymentForDeviceRequest {
    pub fn new() -> CreateFUOTADeploymentForDeviceRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // .api.FUOTADeployment fuota_deployment = 2;


    pub fn get_fuota_deployment(&self) -> &FUOTADeployment {
        self.fuota_deployment.as_ref().unwrap_or_else(|| FUOTADeployment::default_instance())
    }
    pub fn clear_fuota_deployment(&mut self) {
        self.fuota_deployment.clear();
    }

    pub fn has_fuota_deployment(&self) -> bool {
        self.fuota_deployment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fuota_deployment(&mut self, v: FUOTADeployment) {
        self.fuota_deployment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fuota_deployment(&mut self) -> &mut FUOTADeployment {
        if self.fuota_deployment.is_none() {
            self.fuota_deployment.set_default();
        }
        self.fuota_deployment.as_mut().unwrap()
    }

    // Take field
    pub fn take_fuota_deployment(&mut self) -> FUOTADeployment {
        self.fuota_deployment.take().unwrap_or_else(|| FUOTADeployment::new())
    }
}

impl ::protobuf::Message for CreateFUOTADeploymentForDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fuota_deployment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fuota_deployment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if let Some(ref v) = self.fuota_deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if let Some(ref v) = self.fuota_deployment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFUOTADeploymentForDeviceRequest {
        CreateFUOTADeploymentForDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &CreateFUOTADeploymentForDeviceRequest| { &m.dev_eui },
                    |m: &mut CreateFUOTADeploymentForDeviceRequest| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FUOTADeployment>>(
                    "fuota_deployment",
                    |m: &CreateFUOTADeploymentForDeviceRequest| { &m.fuota_deployment },
                    |m: &mut CreateFUOTADeploymentForDeviceRequest| { &mut m.fuota_deployment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateFUOTADeploymentForDeviceRequest>(
                    "CreateFUOTADeploymentForDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFUOTADeploymentForDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateFUOTADeploymentForDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateFUOTADeploymentForDeviceRequest,
        };
        unsafe {
            instance.get(CreateFUOTADeploymentForDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateFUOTADeploymentForDeviceRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.fuota_deployment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFUOTADeploymentForDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFUOTADeploymentForDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFUOTADeploymentForDeviceResponse {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFUOTADeploymentForDeviceResponse {
    fn default() -> &'a CreateFUOTADeploymentForDeviceResponse {
        <CreateFUOTADeploymentForDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateFUOTADeploymentForDeviceResponse {
    pub fn new() -> CreateFUOTADeploymentForDeviceResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateFUOTADeploymentForDeviceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFUOTADeploymentForDeviceResponse {
        CreateFUOTADeploymentForDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &CreateFUOTADeploymentForDeviceResponse| { &m.id },
                    |m: &mut CreateFUOTADeploymentForDeviceResponse| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateFUOTADeploymentForDeviceResponse>(
                    "CreateFUOTADeploymentForDeviceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateFUOTADeploymentForDeviceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateFUOTADeploymentForDeviceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateFUOTADeploymentForDeviceResponse,
        };
        unsafe {
            instance.get(CreateFUOTADeploymentForDeviceResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateFUOTADeploymentForDeviceResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFUOTADeploymentForDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFUOTADeploymentForDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFUOTADeploymentRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFUOTADeploymentRequest {
    fn default() -> &'a GetFUOTADeploymentRequest {
        <GetFUOTADeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFUOTADeploymentRequest {
    pub fn new() -> GetFUOTADeploymentRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFUOTADeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFUOTADeploymentRequest {
        GetFUOTADeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &GetFUOTADeploymentRequest| { &m.id },
                    |m: &mut GetFUOTADeploymentRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFUOTADeploymentRequest>(
                    "GetFUOTADeploymentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFUOTADeploymentRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetFUOTADeploymentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFUOTADeploymentRequest,
        };
        unsafe {
            instance.get(GetFUOTADeploymentRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetFUOTADeploymentRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFUOTADeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFUOTADeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFUOTADeploymentResponse {
    // message fields
    pub fuota_deployment: ::protobuf::SingularPtrField<FUOTADeployment>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFUOTADeploymentResponse {
    fn default() -> &'a GetFUOTADeploymentResponse {
        <GetFUOTADeploymentResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFUOTADeploymentResponse {
    pub fn new() -> GetFUOTADeploymentResponse {
        ::std::default::Default::default()
    }

    // .api.FUOTADeployment fuota_deployment = 1;


    pub fn get_fuota_deployment(&self) -> &FUOTADeployment {
        self.fuota_deployment.as_ref().unwrap_or_else(|| FUOTADeployment::default_instance())
    }
    pub fn clear_fuota_deployment(&mut self) {
        self.fuota_deployment.clear();
    }

    pub fn has_fuota_deployment(&self) -> bool {
        self.fuota_deployment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fuota_deployment(&mut self, v: FUOTADeployment) {
        self.fuota_deployment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fuota_deployment(&mut self) -> &mut FUOTADeployment {
        if self.fuota_deployment.is_none() {
            self.fuota_deployment.set_default();
        }
        self.fuota_deployment.as_mut().unwrap()
    }

    // Take field
    pub fn take_fuota_deployment(&mut self) -> FUOTADeployment {
        self.fuota_deployment.take().unwrap_or_else(|| FUOTADeployment::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for GetFUOTADeploymentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.fuota_deployment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fuota_deployment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fuota_deployment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fuota_deployment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFUOTADeploymentResponse {
        GetFUOTADeploymentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FUOTADeployment>>(
                    "fuota_deployment",
                    |m: &GetFUOTADeploymentResponse| { &m.fuota_deployment },
                    |m: &mut GetFUOTADeploymentResponse| { &mut m.fuota_deployment },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created_at",
                    |m: &GetFUOTADeploymentResponse| { &m.created_at },
                    |m: &mut GetFUOTADeploymentResponse| { &mut m.created_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated_at",
                    |m: &GetFUOTADeploymentResponse| { &m.updated_at },
                    |m: &mut GetFUOTADeploymentResponse| { &mut m.updated_at },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFUOTADeploymentResponse>(
                    "GetFUOTADeploymentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFUOTADeploymentResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetFUOTADeploymentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFUOTADeploymentResponse,
        };
        unsafe {
            instance.get(GetFUOTADeploymentResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetFUOTADeploymentResponse {
    fn clear(&mut self) {
        self.fuota_deployment.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFUOTADeploymentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFUOTADeploymentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFUOTADeploymentRequest {
    // message fields
    pub limit: i64,
    pub offset: i64,
    pub application_id: i64,
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFUOTADeploymentRequest {
    fn default() -> &'a ListFUOTADeploymentRequest {
        <ListFUOTADeploymentRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListFUOTADeploymentRequest {
    pub fn new() -> ListFUOTADeploymentRequest {
        ::std::default::Default::default()
    }

    // int64 limit = 1;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 application_id = 3;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string dev_eui = 4;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListFUOTADeploymentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_int64(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.application_id != 0 {
            os.write_int64(3, self.application_id)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_string(4, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFUOTADeploymentRequest {
        ListFUOTADeploymentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ListFUOTADeploymentRequest| { &m.limit },
                    |m: &mut ListFUOTADeploymentRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &ListFUOTADeploymentRequest| { &m.offset },
                    |m: &mut ListFUOTADeploymentRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &ListFUOTADeploymentRequest| { &m.application_id },
                    |m: &mut ListFUOTADeploymentRequest| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &ListFUOTADeploymentRequest| { &m.dev_eui },
                    |m: &mut ListFUOTADeploymentRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListFUOTADeploymentRequest>(
                    "ListFUOTADeploymentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListFUOTADeploymentRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListFUOTADeploymentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListFUOTADeploymentRequest,
        };
        unsafe {
            instance.get(ListFUOTADeploymentRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListFUOTADeploymentRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.application_id = 0;
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFUOTADeploymentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFUOTADeploymentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFUOTADeploymentResponse {
    // message fields
    pub total_count: i64,
    pub result: ::protobuf::RepeatedField<FUOTADeploymentListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFUOTADeploymentResponse {
    fn default() -> &'a ListFUOTADeploymentResponse {
        <ListFUOTADeploymentResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListFUOTADeploymentResponse {
    pub fn new() -> ListFUOTADeploymentResponse {
        ::std::default::Default::default()
    }

    // int64 total_count = 1;


    pub fn get_total_count(&self) -> i64 {
        self.total_count
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i64) {
        self.total_count = v;
    }

    // repeated .api.FUOTADeploymentListItem result = 2;


    pub fn get_result(&self) -> &[FUOTADeploymentListItem] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<FUOTADeploymentListItem>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<FUOTADeploymentListItem> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<FUOTADeploymentListItem> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListFUOTADeploymentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_count != 0 {
            os.write_int64(1, self.total_count)?;
        }
        for v in &self.result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFUOTADeploymentResponse {
        ListFUOTADeploymentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_count",
                    |m: &ListFUOTADeploymentResponse| { &m.total_count },
                    |m: &mut ListFUOTADeploymentResponse| { &mut m.total_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FUOTADeploymentListItem>>(
                    "result",
                    |m: &ListFUOTADeploymentResponse| { &m.result },
                    |m: &mut ListFUOTADeploymentResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListFUOTADeploymentResponse>(
                    "ListFUOTADeploymentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListFUOTADeploymentResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListFUOTADeploymentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListFUOTADeploymentResponse,
        };
        unsafe {
            instance.get(ListFUOTADeploymentResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListFUOTADeploymentResponse {
    fn clear(&mut self) {
        self.total_count = 0;
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFUOTADeploymentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFUOTADeploymentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFUOTADeploymentDevicesRequest {
    // message fields
    pub fuota_deployment_id: ::std::string::String,
    pub limit: i64,
    pub offset: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFUOTADeploymentDevicesRequest {
    fn default() -> &'a ListFUOTADeploymentDevicesRequest {
        <ListFUOTADeploymentDevicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListFUOTADeploymentDevicesRequest {
    pub fn new() -> ListFUOTADeploymentDevicesRequest {
        ::std::default::Default::default()
    }

    // string fuota_deployment_id = 1;


    pub fn get_fuota_deployment_id(&self) -> &str {
        &self.fuota_deployment_id
    }
    pub fn clear_fuota_deployment_id(&mut self) {
        self.fuota_deployment_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_fuota_deployment_id(&mut self, v: ::std::string::String) {
        self.fuota_deployment_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fuota_deployment_id(&mut self) -> &mut ::std::string::String {
        &mut self.fuota_deployment_id
    }

    // Take field
    pub fn take_fuota_deployment_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fuota_deployment_id, ::std::string::String::new())
    }

    // int64 limit = 2;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 offset = 3;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }
}

impl ::protobuf::Message for ListFUOTADeploymentDevicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fuota_deployment_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fuota_deployment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fuota_deployment_id);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fuota_deployment_id.is_empty() {
            os.write_string(1, &self.fuota_deployment_id)?;
        }
        if self.limit != 0 {
            os.write_int64(2, self.limit)?;
        }
        if self.offset != 0 {
            os.write_int64(3, self.offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFUOTADeploymentDevicesRequest {
        ListFUOTADeploymentDevicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fuota_deployment_id",
                    |m: &ListFUOTADeploymentDevicesRequest| { &m.fuota_deployment_id },
                    |m: &mut ListFUOTADeploymentDevicesRequest| { &mut m.fuota_deployment_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ListFUOTADeploymentDevicesRequest| { &m.limit },
                    |m: &mut ListFUOTADeploymentDevicesRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &ListFUOTADeploymentDevicesRequest| { &m.offset },
                    |m: &mut ListFUOTADeploymentDevicesRequest| { &mut m.offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListFUOTADeploymentDevicesRequest>(
                    "ListFUOTADeploymentDevicesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListFUOTADeploymentDevicesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListFUOTADeploymentDevicesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListFUOTADeploymentDevicesRequest,
        };
        unsafe {
            instance.get(ListFUOTADeploymentDevicesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListFUOTADeploymentDevicesRequest {
    fn clear(&mut self) {
        self.fuota_deployment_id.clear();
        self.limit = 0;
        self.offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFUOTADeploymentDevicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFUOTADeploymentDevicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFUOTADeploymentDeviceRequest {
    // message fields
    pub fuota_deployment_id: ::std::string::String,
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFUOTADeploymentDeviceRequest {
    fn default() -> &'a GetFUOTADeploymentDeviceRequest {
        <GetFUOTADeploymentDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFUOTADeploymentDeviceRequest {
    pub fn new() -> GetFUOTADeploymentDeviceRequest {
        ::std::default::Default::default()
    }

    // string fuota_deployment_id = 1;


    pub fn get_fuota_deployment_id(&self) -> &str {
        &self.fuota_deployment_id
    }
    pub fn clear_fuota_deployment_id(&mut self) {
        self.fuota_deployment_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_fuota_deployment_id(&mut self, v: ::std::string::String) {
        self.fuota_deployment_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fuota_deployment_id(&mut self) -> &mut ::std::string::String {
        &mut self.fuota_deployment_id
    }

    // Take field
    pub fn take_fuota_deployment_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fuota_deployment_id, ::std::string::String::new())
    }

    // string dev_eui = 2;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFUOTADeploymentDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fuota_deployment_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fuota_deployment_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.fuota_deployment_id);
        }
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fuota_deployment_id.is_empty() {
            os.write_string(1, &self.fuota_deployment_id)?;
        }
        if !self.dev_eui.is_empty() {
            os.write_string(2, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFUOTADeploymentDeviceRequest {
        GetFUOTADeploymentDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fuota_deployment_id",
                    |m: &GetFUOTADeploymentDeviceRequest| { &m.fuota_deployment_id },
                    |m: &mut GetFUOTADeploymentDeviceRequest| { &mut m.fuota_deployment_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &GetFUOTADeploymentDeviceRequest| { &m.dev_eui },
                    |m: &mut GetFUOTADeploymentDeviceRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFUOTADeploymentDeviceRequest>(
                    "GetFUOTADeploymentDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFUOTADeploymentDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetFUOTADeploymentDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFUOTADeploymentDeviceRequest,
        };
        unsafe {
            instance.get(GetFUOTADeploymentDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetFUOTADeploymentDeviceRequest {
    fn clear(&mut self) {
        self.fuota_deployment_id.clear();
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFUOTADeploymentDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFUOTADeploymentDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFUOTADeploymentDeviceResponse {
    // message fields
    pub deployment_device: ::protobuf::SingularPtrField<FUOTADeploymentDeviceListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFUOTADeploymentDeviceResponse {
    fn default() -> &'a GetFUOTADeploymentDeviceResponse {
        <GetFUOTADeploymentDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFUOTADeploymentDeviceResponse {
    pub fn new() -> GetFUOTADeploymentDeviceResponse {
        ::std::default::Default::default()
    }

    // .api.FUOTADeploymentDeviceListItem deployment_device = 1;


    pub fn get_deployment_device(&self) -> &FUOTADeploymentDeviceListItem {
        self.deployment_device.as_ref().unwrap_or_else(|| FUOTADeploymentDeviceListItem::default_instance())
    }
    pub fn clear_deployment_device(&mut self) {
        self.deployment_device.clear();
    }

    pub fn has_deployment_device(&self) -> bool {
        self.deployment_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deployment_device(&mut self, v: FUOTADeploymentDeviceListItem) {
        self.deployment_device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deployment_device(&mut self) -> &mut FUOTADeploymentDeviceListItem {
        if self.deployment_device.is_none() {
            self.deployment_device.set_default();
        }
        self.deployment_device.as_mut().unwrap()
    }

    // Take field
    pub fn take_deployment_device(&mut self) -> FUOTADeploymentDeviceListItem {
        self.deployment_device.take().unwrap_or_else(|| FUOTADeploymentDeviceListItem::new())
    }
}

impl ::protobuf::Message for GetFUOTADeploymentDeviceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.deployment_device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deployment_device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deployment_device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deployment_device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFUOTADeploymentDeviceResponse {
        GetFUOTADeploymentDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FUOTADeploymentDeviceListItem>>(
                    "deployment_device",
                    |m: &GetFUOTADeploymentDeviceResponse| { &m.deployment_device },
                    |m: &mut GetFUOTADeploymentDeviceResponse| { &mut m.deployment_device },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFUOTADeploymentDeviceResponse>(
                    "GetFUOTADeploymentDeviceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFUOTADeploymentDeviceResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetFUOTADeploymentDeviceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFUOTADeploymentDeviceResponse,
        };
        unsafe {
            instance.get(GetFUOTADeploymentDeviceResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetFUOTADeploymentDeviceResponse {
    fn clear(&mut self) {
        self.deployment_device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFUOTADeploymentDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFUOTADeploymentDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFUOTADeploymentDevicesResponse {
    // message fields
    pub total_count: i64,
    pub result: ::protobuf::RepeatedField<FUOTADeploymentDeviceListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListFUOTADeploymentDevicesResponse {
    fn default() -> &'a ListFUOTADeploymentDevicesResponse {
        <ListFUOTADeploymentDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListFUOTADeploymentDevicesResponse {
    pub fn new() -> ListFUOTADeploymentDevicesResponse {
        ::std::default::Default::default()
    }

    // int64 total_count = 1;


    pub fn get_total_count(&self) -> i64 {
        self.total_count
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i64) {
        self.total_count = v;
    }

    // repeated .api.FUOTADeploymentDeviceListItem result = 2;


    pub fn get_result(&self) -> &[FUOTADeploymentDeviceListItem] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<FUOTADeploymentDeviceListItem>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<FUOTADeploymentDeviceListItem> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<FUOTADeploymentDeviceListItem> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListFUOTADeploymentDevicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_count != 0 {
            os.write_int64(1, self.total_count)?;
        }
        for v in &self.result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFUOTADeploymentDevicesResponse {
        ListFUOTADeploymentDevicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_count",
                    |m: &ListFUOTADeploymentDevicesResponse| { &m.total_count },
                    |m: &mut ListFUOTADeploymentDevicesResponse| { &mut m.total_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FUOTADeploymentDeviceListItem>>(
                    "result",
                    |m: &ListFUOTADeploymentDevicesResponse| { &m.result },
                    |m: &mut ListFUOTADeploymentDevicesResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListFUOTADeploymentDevicesResponse>(
                    "ListFUOTADeploymentDevicesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListFUOTADeploymentDevicesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListFUOTADeploymentDevicesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListFUOTADeploymentDevicesResponse,
        };
        unsafe {
            instance.get(ListFUOTADeploymentDevicesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListFUOTADeploymentDevicesResponse {
    fn clear(&mut self) {
        self.total_count = 0;
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFUOTADeploymentDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFUOTADeploymentDevicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FUOTADeploymentDeviceListItem {
    // message fields
    pub dev_eui: ::std::string::String,
    pub device_name: ::std::string::String,
    pub state: FUOTADeploymentDeviceState,
    pub error_message: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FUOTADeploymentDeviceListItem {
    fn default() -> &'a FUOTADeploymentDeviceListItem {
        <FUOTADeploymentDeviceListItem as ::protobuf::Message>::default_instance()
    }
}

impl FUOTADeploymentDeviceListItem {
    pub fn new() -> FUOTADeploymentDeviceListItem {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // string device_name = 2;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_name, ::std::string::String::new())
    }

    // .api.FUOTADeploymentDeviceState state = 3;


    pub fn get_state(&self) -> FUOTADeploymentDeviceState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = FUOTADeploymentDeviceState::PENDING;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: FUOTADeploymentDeviceState) {
        self.state = v;
    }

    // string error_message = 4;


    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 5;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 6;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for FUOTADeploymentDeviceListItem {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device_name);
        }
        if self.state != FUOTADeploymentDeviceState::PENDING {
            my_size += ::protobuf::rt::enum_size(3, self.state);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error_message);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if !self.device_name.is_empty() {
            os.write_string(2, &self.device_name)?;
        }
        if self.state != FUOTADeploymentDeviceState::PENDING {
            os.write_enum(3, self.state.value())?;
        }
        if !self.error_message.is_empty() {
            os.write_string(4, &self.error_message)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FUOTADeploymentDeviceListItem {
        FUOTADeploymentDeviceListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &FUOTADeploymentDeviceListItem| { &m.dev_eui },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_name",
                    |m: &FUOTADeploymentDeviceListItem| { &m.device_name },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.device_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FUOTADeploymentDeviceState>>(
                    "state",
                    |m: &FUOTADeploymentDeviceListItem| { &m.state },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_message",
                    |m: &FUOTADeploymentDeviceListItem| { &m.error_message },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.error_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created_at",
                    |m: &FUOTADeploymentDeviceListItem| { &m.created_at },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.created_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated_at",
                    |m: &FUOTADeploymentDeviceListItem| { &m.updated_at },
                    |m: &mut FUOTADeploymentDeviceListItem| { &mut m.updated_at },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FUOTADeploymentDeviceListItem>(
                    "FUOTADeploymentDeviceListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FUOTADeploymentDeviceListItem {
        static mut instance: ::protobuf::lazy::Lazy<FUOTADeploymentDeviceListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FUOTADeploymentDeviceListItem,
        };
        unsafe {
            instance.get(FUOTADeploymentDeviceListItem::new)
        }
    }
}

impl ::protobuf::Clear for FUOTADeploymentDeviceListItem {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.device_name.clear();
        self.state = FUOTADeploymentDeviceState::PENDING;
        self.error_message.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FUOTADeploymentDeviceListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FUOTADeploymentDeviceListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FUOTADeploymentDeviceState {
    PENDING = 0,
    SUCCESS = 1,
    ERROR = 2,
}

impl ::protobuf::ProtobufEnum for FUOTADeploymentDeviceState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FUOTADeploymentDeviceState> {
        match value {
            0 => ::std::option::Option::Some(FUOTADeploymentDeviceState::PENDING),
            1 => ::std::option::Option::Some(FUOTADeploymentDeviceState::SUCCESS),
            2 => ::std::option::Option::Some(FUOTADeploymentDeviceState::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FUOTADeploymentDeviceState] = &[
            FUOTADeploymentDeviceState::PENDING,
            FUOTADeploymentDeviceState::SUCCESS,
            FUOTADeploymentDeviceState::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FUOTADeploymentDeviceState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FUOTADeploymentDeviceState {
}

impl ::std::default::Default for FUOTADeploymentDeviceState {
    fn default() -> Self {
        FUOTADeploymentDeviceState::PENDING
    }
}

impl ::protobuf::reflect::ProtobufValue for FUOTADeploymentDeviceState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%as/external/api/fuotaDeployment.proto\x12\x03api\x1a\x1cgoogle/api/an\
    notations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/pro\
    tobuf/duration.proto\x1a$as/external/api/multicastGroup.proto\"\xa0\x03\
    \n\x0fFUOTADeployment\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x126\n\ngroup_type\x18\x03\x20\
    \x01(\x0e2\x17.api.MulticastGroupTypeR\tgroupType\x12\x0e\n\x02dr\x18\
    \x04\x20\x01(\rR\x02dr\x12\x1c\n\tfrequency\x18\x05\x20\x01(\rR\tfrequen\
    cy\x12\x18\n\x07payload\x18\x06\x20\x01(\x0cR\x07payload\x12\x1e\n\nredu\
    ndancy\x18\x07\x20\x01(\rR\nredundancy\x12+\n\x11multicast_timeout\x18\
    \x08\x20\x01(\rR\x10multicastTimeout\x12B\n\x0funicast_timeout\x18\t\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x0eunicastTimeout\x12\x14\n\x05\
    state\x18\n\x20\x01(\tR\x05state\x12B\n\x0fnext_step_after\x18\x0b\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\rnextStepAfter\"\x8d\x02\n\x17\
    FUOTADeploymentListItem\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\
    \ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreat\
    edAt\x129\n\nupdated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\tupdatedAt\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x14\n\
    \x05state\x18\x05\x20\x01(\tR\x05state\x12B\n\x0fnext_step_after\x18\x06\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\rnextStepAfter\"\x81\x01\n\
    %CreateFUOTADeploymentForDeviceRequest\x12\x17\n\x07dev_eui\x18\x01\x20\
    \x01(\tR\x06devEUI\x12?\n\x10fuota_deployment\x18\x02\x20\x01(\x0b2\x14.\
    api.FUOTADeploymentR\x0ffuotaDeployment\"8\n&CreateFUOTADeploymentForDev\
    iceResponse\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"+\n\x19GetFUOTADe\
    ploymentRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\xd3\x01\n\
    \x1aGetFUOTADeploymentResponse\x12?\n\x10fuota_deployment\x18\x01\x20\
    \x01(\x0b2\x14.api.FUOTADeploymentR\x0ffuotaDeployment\x129\n\ncreated_a\
    t\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\
    \nupdated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdat\
    edAt\"\x8a\x01\n\x1aListFUOTADeploymentRequest\x12\x14\n\x05limit\x18\
    \x01\x20\x01(\x03R\x05limit\x12\x16\n\x06offset\x18\x02\x20\x01(\x03R\
    \x06offset\x12%\n\x0eapplication_id\x18\x03\x20\x01(\x03R\rapplicationID\
    \x12\x17\n\x07dev_eui\x18\x04\x20\x01(\tR\x06devEUI\"t\n\x1bListFUOTADep\
    loymentResponse\x12\x1f\n\x0btotal_count\x18\x01\x20\x01(\x03R\ntotalCou\
    nt\x124\n\x06result\x18\x02\x20\x03(\x0b2\x1c.api.FUOTADeploymentListIte\
    mR\x06result\"\x81\x01\n!ListFUOTADeploymentDevicesRequest\x12.\n\x13fuo\
    ta_deployment_id\x18\x01\x20\x01(\tR\x11fuotaDeploymentID\x12\x14\n\x05l\
    imit\x18\x02\x20\x01(\x03R\x05limit\x12\x16\n\x06offset\x18\x03\x20\x01(\
    \x03R\x06offset\"j\n\x1fGetFUOTADeploymentDeviceRequest\x12.\n\x13fuota_\
    deployment_id\x18\x01\x20\x01(\tR\x11fuotaDeploymentID\x12\x17\n\x07dev_\
    eui\x18\x02\x20\x01(\tR\x06devEUI\"s\n\x20GetFUOTADeploymentDeviceRespon\
    se\x12O\n\x11deployment_device\x18\x01\x20\x01(\x0b2\".api.FUOTADeployme\
    ntDeviceListItemR\x10deploymentDevice\"\x81\x01\n\"ListFUOTADeploymentDe\
    vicesResponse\x12\x1f\n\x0btotal_count\x18\x01\x20\x01(\x03R\ntotalCount\
    \x12:\n\x06result\x18\x02\x20\x03(\x0b2\".api.FUOTADeploymentDeviceListI\
    temR\x06result\"\xab\x02\n\x1dFUOTADeploymentDeviceListItem\x12\x17\n\
    \x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\x12\x1f\n\x0bdevice_name\x18\
    \x02\x20\x01(\tR\ndeviceName\x125\n\x05state\x18\x03\x20\x01(\x0e2\x1f.a\
    pi.FUOTADeploymentDeviceStateR\x05state\x12#\n\rerror_message\x18\x04\
    \x20\x01(\tR\x0cerrorMessage\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\nupdated_at\x18\x06\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdatedAt*A\n\x1aFUOTADep\
    loymentDeviceState\x12\x0b\n\x07PENDING\x10\0\x12\x0b\n\x07SUCCESS\x10\
    \x01\x12\t\n\x05ERROR\x10\x022\xe8\x05\n\x16FUOTADeploymentService\x12\
    \x9f\x01\n\x0fCreateForDevice\x12*.api.CreateFUOTADeploymentForDeviceReq\
    uest\x1a+.api.CreateFUOTADeploymentForDeviceResponse\"3\x82\xd3\xe4\x93\
    \x02-\"(/api/devices/{dev_eui}/fuota-deployments:\x01*\x12k\n\x03Get\x12\
    \x1e.api.GetFUOTADeploymentRequest\x1a\x1f.api.GetFUOTADeploymentRespons\
    e\"#\x82\xd3\xe4\x93\x02\x1d\x12\x1b/api/fuota-deployments/{id}\x12i\n\
    \x04List\x12\x1f.api.ListFUOTADeploymentRequest\x1a\x20.api.ListFUOTADep\
    loymentResponse\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/api/fuota-deployme\
    nts\x12\xaa\x01\n\x13GetDeploymentDevice\x12$.api.GetFUOTADeploymentDevi\
    ceRequest\x1a%.api.GetFUOTADeploymentDeviceResponse\"F\x82\xd3\xe4\x93\
    \x02@\x12>/api/fuota-deployments/{fuota_deployment_id}/devices/{dev_eui}\
    \x12\xa6\x01\n\x15ListDeploymentDevices\x12&.api.ListFUOTADeploymentDevi\
    cesRequest\x1a'.api.ListFUOTADeploymentDevicesResponse\"<\x82\xd3\xe4\
    \x93\x026\x124/api/fuota-deployments/{fuota_deployment_id}/devicesB9Z7gi\
    thub.com/brocaar/chirpstack-api/go/v3/as/external/apiJ\x8c6\n\x07\x12\
    \x05\0\0\xe3\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\
    \x03\x02\x08\x0b\n\x08\n\x01\x08\x12\x03\x04\0N\n\t\n\x02\x08\x0b\x12\
    \x03\x04\0N\n\t\n\x02\x03\0\x12\x03\x06\x07%\n\t\n\x02\x03\x01\x12\x03\
    \x07\x07(\n\t\n\x02\x03\x02\x12\x03\x08\x07'\n\t\n\x02\x03\x03\x12\x03\t\
    \x07-\nO\n\x02\x06\0\x12\x04\r\01\x01\x1aC\x20FUOTADeploymentService\x20\
    is\x20the\x20service\x20managing\x20FUOTA\x20deployments.\n\n\n\n\x03\
    \x06\0\x01\x12\x03\r\x08\x1e\nJ\n\x04\x06\0\x02\0\x12\x04\x0f\x04\x14\
    \x05\x1a<\x20CreateForDevice\x20creates\x20a\x20deployment\x20for\x20the\
    \x20given\x20DevEUI.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x0f\x08\x17\n\
    \x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0f\x18=\n\x0c\n\x05\x06\0\x02\0\x03\
    \x12\x03\x0fHn\n\r\n\x05\x06\0\x02\0\x04\x12\x04\x10\x08\x13\n\n\x11\n\t\
    \x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04\x10\x08\x13\n\nB\n\x04\x06\0\x02\
    \x01\x12\x04\x17\x04\x1b\x05\x1a4\x20Get\x20returns\x20the\x20fuota\x20d\
    eployment\x20for\x20the\x20given\x20id.\n\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03\x17\x08\x0b\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x17\x0c%\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x170J\n\r\n\x05\x06\0\x02\x01\x04\
    \x12\x04\x18\x08\x1a\n\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04\
    \x18\x08\x1a\n\n1\n\x04\x06\0\x02\x02\x12\x04\x1e\x04\"\x05\x1a#\x20List\
    \x20lists\x20the\x20fuota\x20deployments.\n\n\x0c\n\x05\x06\0\x02\x02\
    \x01\x12\x03\x1e\x08\x0c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1e\r'\n\
    \x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1e2M\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04\x1f\x08!\n\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04\
    \x1f\x08!\n\nB\n\x04\x06\0\x02\x03\x12\x04%\x04)\x05\x1a4\x20GetDeployme\
    ntDevice\x20returns\x20the\x20deployment\x20device.\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03%\x08\x1b\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03%\x1c\
    ;\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03%Ff\n\r\n\x05\x06\0\x02\x03\x04\
    \x12\x04&\x08(\n\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04&\x08(\
    \n\ng\n\x04\x06\0\x02\x04\x12\x04,\x040\x05\x1aY\x20ListDeploymentDevice\
    s\x20lists\x20the\x20devices\x20(and\x20status)\x20for\x20the\x20given\
    \x20fuota\x20deployment\x20ID.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03,\
    \x08\x1d\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03,\x1e?\n\x0c\n\x05\x06\0\
    \x02\x04\x03\x12\x03,Jl\n\r\n\x05\x06\0\x02\x04\x04\x12\x04-\x08/\n\n\
    \x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04-\x08/\n\n\n\n\x02\x05\0\
    \x12\x043\0<\x01\n\n\n\x03\x05\0\x01\x12\x033\x05\x1f\n\x17\n\x04\x05\0\
    \x02\0\x12\x035\x04\x10\x1a\n\x20Pending.\n\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x035\x04\x0b\n\x0c\n\x05\x05\0\x02\0\x02\x12\x035\x0e\x0f\n\x17\n\
    \x04\x05\0\x02\x01\x12\x038\x04\x10\x1a\n\x20Success.\n\n\x0c\n\x05\x05\
    \0\x02\x01\x01\x12\x038\x04\x0b\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x038\
    \x0e\x0f\n\x15\n\x04\x05\0\x02\x02\x12\x03;\x04\x0e\x1a\x08\x20Error.\n\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03;\x04\t\n\x0c\n\x05\x05\0\x02\x02\
    \x02\x12\x03;\x0c\r\n\n\n\x02\x04\0\x12\x04>\0h\x01\n\n\n\x03\x04\0\x01\
    \x12\x03>\x08\x17\nr\n\x04\x04\0\x02\0\x12\x03A\x04\x12\x1ae\x20ID\x20of\
    \x20the\x20deployment\x20(string\x20formatted\x20UUID).\n\x20This\x20val\
    ue\x20will\x20be\x20automatically\x20assigned\x20on\x20create.\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04A\x04>\x19\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03A\x04\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03A\x0b\r\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03A\x10\x11\n&\n\x04\x04\0\x02\x01\x12\x03D\x04\x14\x1a\
    \x19\x20Name\x20of\x20the\x20deployment.\n\n\r\n\x05\x04\0\x02\x01\x04\
    \x12\x04D\x04A\x12\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03D\x04\n\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03D\x0b\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03D\x12\x13\nD\n\x04\x04\0\x02\x02\x12\x03H\x04&\x1a7\x20Multicast\
    \x20type.\n\x20Currently\x20only\x20Class-C\x20is\x20supported!\n\n\r\n\
    \x05\x04\0\x02\x02\x04\x12\x04H\x04D\x14\n\x0c\n\x05\x04\0\x02\x02\x06\
    \x12\x03H\x04\x16\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03H\x17!\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03H$%\n\x19\n\x04\x04\0\x02\x03\x12\x03K\x04\
    \x12\x1a\x0c\x20Data-rate.\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04K\x04H&\
    \n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03K\x04\n\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03K\x0b\r\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03K\x10\x11\n\x1e\
    \n\x04\x04\0\x02\x04\x12\x03N\x04\x19\x1a\x11\x20Frequency\x20(Hz).\n\n\
    \r\n\x05\x04\0\x02\x04\x04\x12\x04N\x04K\x12\n\x0c\n\x05\x04\0\x02\x04\
    \x05\x12\x03N\x04\n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03N\x0b\x14\n\x0c\
    \n\x05\x04\0\x02\x04\x03\x12\x03N\x17\x18\n\x17\n\x04\x04\0\x02\x05\x12\
    \x03Q\x04\x16\x1a\n\x20Payload.\n\n\r\n\x05\x04\0\x02\x05\x04\x12\x04Q\
    \x04N\x19\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03Q\x04\t\n\x0c\n\x05\x04\0\
    \x02\x05\x01\x12\x03Q\n\x11\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03Q\x14\
    \x15\n/\n\x04\x04\0\x02\x06\x12\x03T\x04\x1a\x1a\"\x20Redundancy\x20(num\
    ber\x20of\x20packages).\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x04T\x04Q\x16\
    \n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03T\x04\n\n\x0c\n\x05\x04\0\x02\x06\
    \x01\x12\x03T\x0b\x15\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03T\x18\x19\n\
    \xa4\x01\n\x04\x04\0\x02\x07\x12\x03Y\x04!\x1a\x96\x01\x20Multicast\x20t\
    ime-out.\n\x20Please\x20refer\x20to\x20the\x20Remote\x20Multicast\x20Set\
    up\x20specification\x20as\x20this\x20field\n\x20has\x20a\x20different\
    \x20meaning\x20for\x20Class-B\x20and\x20Class-C\x20groups.\n\n\r\n\x05\
    \x04\0\x02\x07\x04\x12\x04Y\x04T\x1a\n\x0c\n\x05\x04\0\x02\x07\x05\x12\
    \x03Y\x04\n\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03Y\x0b\x1c\n\x0c\n\x05\
    \x04\0\x02\x07\x03\x12\x03Y\x1f\x20\n\xe1\x01\n\x04\x04\0\x02\x08\x12\
    \x03_\x041\x1a\xd3\x01\x20Unicast\x20time-out.\n\x20Set\x20this\x20to\
    \x20the\x20value\x20in\x20which\x20you\x20at\x20least\x20expect\x20an\
    \x20uplink\x20frame\x20from\x20the\n\x20device.\x20The\x20FUOTA\x20deplo\
    yment\x20engine\x20will\x20wait\x20at\x20least\x20for\x20the\x20given\
    \x20time\n\x20before\x20proceeding\x20with\x20the\x20next\x20steps.\n\n\
    \r\n\x05\x04\0\x02\x08\x04\x12\x04_\x04Y!\n\x0c\n\x05\x04\0\x02\x08\x06\
    \x12\x03_\x04\x1c\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03_\x1d,\n\x0c\n\
    \x05\x04\0\x02\x08\x03\x12\x03_/0\nQ\n\x04\x04\0\x02\t\x12\x03c\x04\x16\
    \x1aD\x20Deployment\x20state.\n\x20This\x20value\x20will\x20be\x20automa\
    tically\x20set\x20on\x20create.\n\n\r\n\x05\x04\0\x02\t\x04\x12\x04c\x04\
    _1\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03c\x04\n\n\x0c\n\x05\x04\0\x02\t\
    \x01\x12\x03c\x0b\x10\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03c\x13\x15\nP\n\
    \x04\x04\0\x02\n\x12\x03g\x043\x1aC\x20Next\x20step\x20after.\n\x20This\
    \x20value\x20will\x20be\x20automatically\x20set\x20on\x20create.\n\n\r\n\
    \x05\x04\0\x02\n\x04\x12\x04g\x04c\x16\n\x0c\n\x05\x04\0\x02\n\x06\x12\
    \x03g\x04\x1d\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03g\x1e-\n\x0c\n\x05\x04\
    \0\x02\n\x03\x12\x03g02\n\n\n\x02\x04\x01\x12\x04j\0|\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03j\x08\x1f\n<\n\x04\x04\x01\x02\0\x12\x03l\x04\x12\x1a/\
    \x20ID\x20of\x20the\x20deployment\x20(string\x20formatted\x20UUID).\n\n\
    \r\n\x05\x04\x01\x02\0\x04\x12\x04l\x04j!\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03l\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03l\x0b\r\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03l\x10\x11\n$\n\x04\x04\x01\x02\x01\x12\x03o\
    \x04-\x1a\x17\x20Created\x20at\x20timestamp.\n\n\r\n\x05\x04\x01\x02\x01\
    \x04\x12\x04o\x04l\x12\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03o\x04\x1d\
    \n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03o\x1e(\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03o+,\n%\n\x04\x04\x01\x02\x02\x12\x03r\x04-\x1a\x18\x20La\
    st\x20update\x20timestamp.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04r\x04o\
    -\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03r\x04\x1d\n\x0c\n\x05\x04\x01\
    \x02\x02\x01\x12\x03r\x1e(\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03r+,\n&\
    \n\x04\x04\x01\x02\x03\x12\x03u\x04\x14\x1a\x19\x20Name\x20of\x20the\x20\
    deployment.\n\n\r\n\x05\x04\x01\x02\x03\x04\x12\x04u\x04r-\n\x0c\n\x05\
    \x04\x01\x02\x03\x05\x12\x03u\x04\n\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\
    \x03u\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03u\x12\x13\n\x20\n\
    \x04\x04\x01\x02\x04\x12\x03x\x04\x15\x1a\x13\x20Deployment\x20state.\n\
    \n\r\n\x05\x04\x01\x02\x04\x04\x12\x04x\x04u\x14\n\x0c\n\x05\x04\x01\x02\
    \x04\x05\x12\x03x\x04\n\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03x\x0b\x10\
    \n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03x\x13\x14\n\x1f\n\x04\x04\x01\
    \x02\x05\x12\x03{\x042\x1a\x12\x20Next\x20step\x20after.\n\n\r\n\x05\x04\
    \x01\x02\x05\x04\x12\x04{\x04x\x15\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\
    \x03{\x04\x1d\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03{\x1e-\n\x0c\n\x05\
    \x04\x01\x02\x05\x03\x12\x03{01\n\x0b\n\x02\x04\x02\x12\x05~\0\x84\x01\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03~\x08-\n)\n\x04\x04\x02\x02\0\x12\x04\
    \x80\x01\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0e\n\
    \x05\x04\x02\x02\0\x04\x12\x05\x80\x01\x04~/\n\r\n\x05\x04\x02\x02\0\x05\
    \x12\x04\x80\x01\x04\n\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x80\x01\x0b\
    \x12\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x80\x01\x15\x16\n\r\n\x05\x04\
    \x02\x02\0\x08\x12\x04\x80\x01\x17-\n\r\n\x05\x04\x02\x02\0\n\x12\x04\
    \x80\x01$,\n!\n\x04\x04\x02\x02\x01\x12\x04\x83\x01\x04)\x1a\x13\x20FUOT\
    A\x20deployment.\n\n\x0f\n\x05\x04\x02\x02\x01\x04\x12\x06\x83\x01\x04\
    \x80\x01.\n\r\n\x05\x04\x02\x02\x01\x06\x12\x04\x83\x01\x04\x13\n\r\n\
    \x05\x04\x02\x02\x01\x01\x12\x04\x83\x01\x14$\n\r\n\x05\x04\x02\x02\x01\
    \x03\x12\x04\x83\x01'(\n\x0c\n\x02\x04\x03\x12\x06\x86\x01\0\x89\x01\x01\
    \n\x0b\n\x03\x04\x03\x01\x12\x04\x86\x01\x08.\nE\n\x04\x04\x03\x02\0\x12\
    \x04\x88\x01\x04\x12\x1a7\x20ID\x20of\x20the\x20created\x20deployment\
    \x20(string\x20formatted\x20UUID).\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\
    \x06\x88\x01\x04\x86\x010\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x88\x01\
    \x04\n\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x88\x01\x0b\r\n\r\n\x05\x04\
    \x03\x02\0\x03\x12\x04\x88\x01\x10\x11\n\x0c\n\x02\x04\x04\x12\x06\x8b\
    \x01\0\x8f\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x8b\x01\x08!\ns\n\x04\
    \x04\x04\x02\0\x12\x04\x8e\x01\x04\x12\x1ae\x20ID\x20of\x20the\x20deploy\
    ment\x20(string\x20formatted\x20UUID).\n\x20This\x20value\x20will\x20be\
    \x20automatically\x20assigned\x20on\x20create.\n\n\x0f\n\x05\x04\x04\x02\
    \0\x04\x12\x06\x8e\x01\x04\x8b\x01#\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\
    \x8e\x01\x04\n\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\x8e\x01\x0b\r\n\r\n\
    \x05\x04\x04\x02\0\x03\x12\x04\x8e\x01\x10\x11\n\x0c\n\x02\x04\x05\x12\
    \x06\x91\x01\0\x99\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x91\x01\x08\"\
    \n\x0c\n\x04\x04\x05\x02\0\x12\x04\x92\x01\x04)\n\x0f\n\x05\x04\x05\x02\
    \0\x04\x12\x06\x92\x01\x04\x91\x01$\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\
    \x92\x01\x04\x13\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x92\x01\x14$\n\r\n\
    \x05\x04\x05\x02\0\x03\x12\x04\x92\x01'(\n%\n\x04\x04\x05\x02\x01\x12\
    \x04\x95\x01\x04-\x1a\x17\x20Created\x20at\x20timestamp.\n\n\x0f\n\x05\
    \x04\x05\x02\x01\x04\x12\x06\x95\x01\x04\x92\x01)\n\r\n\x05\x04\x05\x02\
    \x01\x06\x12\x04\x95\x01\x04\x1d\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \x95\x01\x1e(\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x95\x01+,\n&\n\x04\
    \x04\x05\x02\x02\x12\x04\x98\x01\x04-\x1a\x18\x20Last\x20update\x20times\
    tamp.\n\n\x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\x98\x01\x04\x95\x01-\n\r\
    \n\x05\x04\x05\x02\x02\x06\x12\x04\x98\x01\x04\x1d\n\r\n\x05\x04\x05\x02\
    \x02\x01\x12\x04\x98\x01\x1e(\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x98\
    \x01+,\n\x0c\n\x02\x04\x06\x12\x06\x9b\x01\0\xa7\x01\x01\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\x9b\x01\x08\"\nF\n\x04\x04\x06\x02\0\x12\x04\x9d\x01\
    \x04\x14\x1a8\x20Max\x20number\x20of\x20deployments\x20to\x20return\x20i\
    n\x20the\x20result-set.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\x9d\x01\
    \x04\x9b\x01$\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x9d\x01\x04\t\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\x9d\x01\n\x0f\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\x9d\x01\x12\x13\n:\n\x04\x04\x06\x02\x01\x12\x04\xa0\x01\x04\
    \x15\x1a,\x20Offset\x20in\x20the\x20result-set\x20(for\x20pagination).\n\
    \n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\xa0\x01\x04\x9d\x01\x14\n\r\n\
    \x05\x04\x06\x02\x01\x05\x12\x04\xa0\x01\x04\t\n\r\n\x05\x04\x06\x02\x01\
    \x01\x12\x04\xa0\x01\n\x10\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa0\x01\
    \x13\x14\n7\n\x04\x04\x06\x02\x02\x12\x04\xa3\x01\x04;\x1a)\x20Applicati\
    on\x20ID\x20to\x20filter\x20on\x20(optional).\n\n\x0f\n\x05\x04\x06\x02\
    \x02\x04\x12\x06\xa3\x01\x04\xa0\x01\x15\n\r\n\x05\x04\x06\x02\x02\x05\
    \x12\x04\xa3\x01\x04\t\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xa3\x01\n\
    \x18\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xa3\x01\x1b\x1c\n\r\n\x05\x04\
    \x06\x02\x02\x08\x12\x04\xa3\x01\x1d:\n\r\n\x05\x04\x06\x02\x02\n\x12\
    \x04\xa3\x01*9\n4\n\x04\x04\x06\x02\x03\x12\x04\xa6\x01\x04.\x1a&\x20Dev\
    ice\x20EUI\x20(HEX\x20encoded)\x20(optional).\n\n\x0f\n\x05\x04\x06\x02\
    \x03\x04\x12\x06\xa6\x01\x04\xa3\x01;\n\r\n\x05\x04\x06\x02\x03\x05\x12\
    \x04\xa6\x01\x04\n\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xa6\x01\x0b\x12\
    \n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xa6\x01\x15\x16\n\r\n\x05\x04\x06\
    \x02\x03\x08\x12\x04\xa6\x01\x17-\n\r\n\x05\x04\x06\x02\x03\n\x12\x04\
    \xa6\x01$,\n\x0c\n\x02\x04\x07\x12\x06\xa9\x01\0\xaf\x01\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xa9\x01\x08#\nL\n\x04\x04\x07\x02\0\x12\x04\xab\x01\
    \x04\x1a\x1a>\x20Total\x20number\x20of\x20deployments\x20available\x20wi\
    thin\x20the\x20result-set.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xab\
    \x01\x04\xa9\x01%\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xab\x01\x04\t\n\r\
    \n\x05\x04\x07\x02\0\x01\x12\x04\xab\x01\n\x15\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\xab\x01\x18\x19\n3\n\x04\x04\x07\x02\x01\x12\x04\xae\x01\
    \x040\x1a%\x20Deployments\x20within\x20this\x20result-set.\n\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04\xae\x01\x04\x0c\n\r\n\x05\x04\x07\x02\x01\
    \x06\x12\x04\xae\x01\r$\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xae\x01%+\
    \n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xae\x01./\n\x0c\n\x02\x04\x08\x12\
    \x06\xb1\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xb1\x01\x08)\
    \ns\n\x04\x04\x08\x02\0\x12\x04\xb4\x01\x04E\x1ae\x20ID\x20of\x20the\x20\
    deployment\x20(string\x20formatted\x20UUID).\n\x20This\x20value\x20will\
    \x20be\x20automatically\x20assigned\x20on\x20create.\n\n\x0f\n\x05\x04\
    \x08\x02\0\x04\x12\x06\xb4\x01\x04\xb1\x01+\n\r\n\x05\x04\x08\x02\0\x05\
    \x12\x04\xb4\x01\x04\n\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xb4\x01\x0b\
    \x1e\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xb4\x01!\"\n\r\n\x05\x04\x08\
    \x02\0\x08\x12\x04\xb4\x01#D\n\r\n\x05\x04\x08\x02\0\n\x12\x04\xb4\x010C\
    \n.\n\x04\x04\x08\x02\x01\x12\x04\xb7\x01\x04\x14\x1a\x20\x20Max\x20numb\
    er\x20of\x20items\x20to\x20return.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\
    \x06\xb7\x01\x04\xb4\x01E\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xb7\x01\
    \x04\t\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xb7\x01\n\x0f\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\xb7\x01\x12\x13\n:\n\x04\x04\x08\x02\x02\x12\
    \x04\xba\x01\x04\x15\x1a,\x20Offset\x20in\x20the\x20result-set\x20(for\
    \x20pagination).\n\n\x0f\n\x05\x04\x08\x02\x02\x04\x12\x06\xba\x01\x04\
    \xb7\x01\x14\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xba\x01\x04\t\n\r\n\
    \x05\x04\x08\x02\x02\x01\x12\x04\xba\x01\n\x10\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\xba\x01\x13\x14\n\x0c\n\x02\x04\t\x12\x06\xbd\x01\0\xc4\x01\
    \x01\n\x0b\n\x03\x04\t\x01\x12\x04\xbd\x01\x08'\ns\n\x04\x04\t\x02\0\x12\
    \x04\xc0\x01\x04E\x1ae\x20ID\x20of\x20the\x20deployment\x20(string\x20fo\
    rmatted\x20UUID).\n\x20This\x20value\x20will\x20be\x20automatically\x20a\
    ssigned\x20on\x20create.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xc0\x01\
    \x04\xbd\x01)\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xc0\x01\x04\n\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\xc0\x01\x0b\x1e\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\xc0\x01!\"\n\r\n\x05\x04\t\x02\0\x08\x12\x04\xc0\x01#D\n\r\n\x05\
    \x04\t\x02\0\n\x12\x04\xc0\x010C\n)\n\x04\x04\t\x02\x01\x12\x04\xc3\x01\
    \x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\t\
    \x02\x01\x04\x12\x06\xc3\x01\x04\xc0\x01E\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xc3\x01\x04\n\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xc3\x01\x0b\
    \x12\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xc3\x01\x15\x16\n\r\n\x05\x04\t\
    \x02\x01\x08\x12\x04\xc3\x01\x17-\n\r\n\x05\x04\t\x02\x01\n\x12\x04\xc3\
    \x01$,\n\x0c\n\x02\x04\n\x12\x06\xc6\x01\0\xc8\x01\x01\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xc6\x01\x08(\n\x0c\n\x04\x04\n\x02\0\x12\x04\xc7\x01\x048\n\
    \x0f\n\x05\x04\n\x02\0\x04\x12\x06\xc7\x01\x04\xc6\x01*\n\r\n\x05\x04\n\
    \x02\0\x06\x12\x04\xc7\x01\x04!\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xc7\
    \x01\"3\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xc7\x0167\n\x0c\n\x02\x04\x0b\
    \x12\x06\xca\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xca\x01\
    \x08*\nA\n\x04\x04\x0b\x02\0\x12\x04\xcc\x01\x04\x1a\x1a3\x20Total\x20nu\
    mber\x20of\x20devices\x20for\x20the\x20FUOTA\x20deployment.\n\n\x0f\n\
    \x05\x04\x0b\x02\0\x04\x12\x06\xcc\x01\x04\xca\x01,\n\r\n\x05\x04\x0b\
    \x02\0\x05\x12\x04\xcc\x01\x04\t\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xcc\
    \x01\n\x15\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xcc\x01\x18\x19\n\x0c\n\
    \x04\x04\x0b\x02\x01\x12\x04\xce\x01\x046\n\r\n\x05\x04\x0b\x02\x01\x04\
    \x12\x04\xce\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\xce\x01\r\
    *\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xce\x01+1\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\xce\x0145\n\x0c\n\x02\x04\x0c\x12\x06\xd1\x01\0\xe3\x01\
    \x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd1\x01\x08%\n)\n\x04\x04\x0c\x02\0\
    \x12\x04\xd3\x01\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\
    \x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xd3\x01\x04\xd1\x01'\n\r\n\x05\x04\
    \x0c\x02\0\x05\x12\x04\xd3\x01\x04\n\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\
    \xd3\x01\x0b\x12\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xd3\x01\x15\x16\n\r\
    \n\x05\x04\x0c\x02\0\x08\x12\x04\xd3\x01\x17-\n\r\n\x05\x04\x0c\x02\0\n\
    \x12\x04\xd3\x01$,\n\x1c\n\x04\x04\x0c\x02\x01\x12\x04\xd6\x01\x04\x1b\
    \x1a\x0e\x20Device\x20name.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\
    \xd6\x01\x04\xd3\x01.\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xd6\x01\x04\
    \n\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xd6\x01\x0b\x16\n\r\n\x05\x04\
    \x0c\x02\x01\x03\x12\x04\xd6\x01\x19\x1a\n\x1d\n\x04\x04\x0c\x02\x02\x12\
    \x04\xd9\x01\x04)\x1a\x0f\x20Device\x20state.\n\n\x0f\n\x05\x04\x0c\x02\
    \x02\x04\x12\x06\xd9\x01\x04\xd6\x01\x1b\n\r\n\x05\x04\x0c\x02\x02\x06\
    \x12\x04\xd9\x01\x04\x1e\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xd9\x01\
    \x1f$\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xd9\x01'(\n7\n\x04\x04\x0c\
    \x02\x03\x12\x04\xdc\x01\x04\x1d\x1a)\x20Error\x20message\x20(in\x20case\
    \x20of\x20error\x20state).\n\n\x0f\n\x05\x04\x0c\x02\x03\x04\x12\x06\xdc\
    \x01\x04\xd9\x01)\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xdc\x01\x04\n\n\
    \r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xdc\x01\x0b\x18\n\r\n\x05\x04\x0c\
    \x02\x03\x03\x12\x04\xdc\x01\x1b\x1c\n%\n\x04\x04\x0c\x02\x04\x12\x04\
    \xdf\x01\x04-\x1a\x17\x20Created\x20at\x20timestamp.\n\n\x0f\n\x05\x04\
    \x0c\x02\x04\x04\x12\x06\xdf\x01\x04\xdc\x01\x1d\n\r\n\x05\x04\x0c\x02\
    \x04\x06\x12\x04\xdf\x01\x04\x1d\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\
    \xdf\x01\x1e(\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xdf\x01+,\n%\n\x04\
    \x04\x0c\x02\x05\x12\x04\xe2\x01\x04-\x1a\x17\x20Updated\x20at\x20timest\
    amp.\n\n\x0f\n\x05\x04\x0c\x02\x05\x04\x12\x06\xe2\x01\x04\xdf\x01-\n\r\
    \n\x05\x04\x0c\x02\x05\x06\x12\x04\xe2\x01\x04\x1d\n\r\n\x05\x04\x0c\x02\
    \x05\x01\x12\x04\xe2\x01\x1e(\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xe2\
    \x01+,b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
