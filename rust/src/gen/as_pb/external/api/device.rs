// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `as/external/api/device.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Device {
    // message fields
    pub dev_eui: ::std::string::String,
    pub name: ::std::string::String,
    pub application_id: i64,
    pub description: ::std::string::String,
    pub device_profile_id: ::std::string::String,
    pub skip_f_cnt_check: bool,
    pub reference_altitude: f64,
    pub variables: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub tags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 application_id = 3;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string device_profile_id = 5;


    pub fn get_device_profile_id(&self) -> &str {
        &self.device_profile_id
    }
    pub fn clear_device_profile_id(&mut self) {
        self.device_profile_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_profile_id(&mut self, v: ::std::string::String) {
        self.device_profile_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_profile_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_profile_id
    }

    // Take field
    pub fn take_device_profile_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_profile_id, ::std::string::String::new())
    }

    // bool skip_f_cnt_check = 6;


    pub fn get_skip_f_cnt_check(&self) -> bool {
        self.skip_f_cnt_check
    }
    pub fn clear_skip_f_cnt_check(&mut self) {
        self.skip_f_cnt_check = false;
    }

    // Param is passed by value, moved
    pub fn set_skip_f_cnt_check(&mut self, v: bool) {
        self.skip_f_cnt_check = v;
    }

    // double reference_altitude = 7;


    pub fn get_reference_altitude(&self) -> f64 {
        self.reference_altitude
    }
    pub fn clear_reference_altitude(&mut self) {
        self.reference_altitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_reference_altitude(&mut self, v: f64) {
        self.reference_altitude = v;
    }

    // repeated .api.Device.VariablesEntry variables = 8;


    pub fn get_variables(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.variables
    }
    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.variables, ::std::collections::HashMap::new())
    }

    // repeated .api.Device.TagsEntry tags = 9;


    pub fn get_tags(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Device {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_profile_id)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_f_cnt_check = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.reference_altitude = tmp;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.variables)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if !self.device_profile_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_profile_id);
        }
        if self.skip_f_cnt_check != false {
            my_size += 2;
        }
        if self.reference_altitude != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.variables);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.tags);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.application_id != 0 {
            os.write_int64(3, self.application_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if !self.device_profile_id.is_empty() {
            os.write_string(5, &self.device_profile_id)?;
        }
        if self.skip_f_cnt_check != false {
            os.write_bool(6, self.skip_f_cnt_check)?;
        }
        if self.reference_altitude != 0. {
            os.write_double(7, self.reference_altitude)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.variables, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.tags, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Device {
        Device::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &Device| { &m.dev_eui },
                    |m: &mut Device| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Device| { &m.name },
                    |m: &mut Device| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &Device| { &m.application_id },
                    |m: &mut Device| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Device| { &m.description },
                    |m: &mut Device| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_profile_id",
                    |m: &Device| { &m.device_profile_id },
                    |m: &mut Device| { &mut m.device_profile_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "skip_f_cnt_check",
                    |m: &Device| { &m.skip_f_cnt_check },
                    |m: &mut Device| { &mut m.skip_f_cnt_check },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "reference_altitude",
                    |m: &Device| { &m.reference_altitude },
                    |m: &mut Device| { &mut m.reference_altitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "variables",
                    |m: &Device| { &m.variables },
                    |m: &mut Device| { &mut m.variables },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &Device| { &m.tags },
                    |m: &mut Device| { &mut m.tags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Device>(
                    "Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Device {
        static mut instance: ::protobuf::lazy::Lazy<Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Device,
        };
        unsafe {
            instance.get(Device::new)
        }
    }
}

impl ::protobuf::Clear for Device {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.name.clear();
        self.application_id = 0;
        self.description.clear();
        self.device_profile_id.clear();
        self.skip_f_cnt_check = false;
        self.reference_altitude = 0.;
        self.variables.clear();
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceListItem {
    // message fields
    pub dev_eui: ::std::string::String,
    pub name: ::std::string::String,
    pub application_id: i64,
    pub description: ::std::string::String,
    pub device_profile_id: ::std::string::String,
    pub device_profile_name: ::std::string::String,
    pub device_status_battery: u32,
    pub device_status_margin: i32,
    pub device_status_external_power_source: bool,
    pub device_status_battery_level_unavailable: bool,
    pub device_status_battery_level: f32,
    pub last_seen_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceListItem {
    fn default() -> &'a DeviceListItem {
        <DeviceListItem as ::protobuf::Message>::default_instance()
    }
}

impl DeviceListItem {
    pub fn new() -> DeviceListItem {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 application_id = 3;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string device_profile_id = 5;


    pub fn get_device_profile_id(&self) -> &str {
        &self.device_profile_id
    }
    pub fn clear_device_profile_id(&mut self) {
        self.device_profile_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_profile_id(&mut self, v: ::std::string::String) {
        self.device_profile_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_profile_id(&mut self) -> &mut ::std::string::String {
        &mut self.device_profile_id
    }

    // Take field
    pub fn take_device_profile_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_profile_id, ::std::string::String::new())
    }

    // string device_profile_name = 6;


    pub fn get_device_profile_name(&self) -> &str {
        &self.device_profile_name
    }
    pub fn clear_device_profile_name(&mut self) {
        self.device_profile_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_profile_name(&mut self, v: ::std::string::String) {
        self.device_profile_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_profile_name(&mut self) -> &mut ::std::string::String {
        &mut self.device_profile_name
    }

    // Take field
    pub fn take_device_profile_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_profile_name, ::std::string::String::new())
    }

    // uint32 device_status_battery = 7;


    pub fn get_device_status_battery(&self) -> u32 {
        self.device_status_battery
    }
    pub fn clear_device_status_battery(&mut self) {
        self.device_status_battery = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_status_battery(&mut self, v: u32) {
        self.device_status_battery = v;
    }

    // int32 device_status_margin = 8;


    pub fn get_device_status_margin(&self) -> i32 {
        self.device_status_margin
    }
    pub fn clear_device_status_margin(&mut self) {
        self.device_status_margin = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_status_margin(&mut self, v: i32) {
        self.device_status_margin = v;
    }

    // bool device_status_external_power_source = 10;


    pub fn get_device_status_external_power_source(&self) -> bool {
        self.device_status_external_power_source
    }
    pub fn clear_device_status_external_power_source(&mut self) {
        self.device_status_external_power_source = false;
    }

    // Param is passed by value, moved
    pub fn set_device_status_external_power_source(&mut self, v: bool) {
        self.device_status_external_power_source = v;
    }

    // bool device_status_battery_level_unavailable = 11;


    pub fn get_device_status_battery_level_unavailable(&self) -> bool {
        self.device_status_battery_level_unavailable
    }
    pub fn clear_device_status_battery_level_unavailable(&mut self) {
        self.device_status_battery_level_unavailable = false;
    }

    // Param is passed by value, moved
    pub fn set_device_status_battery_level_unavailable(&mut self, v: bool) {
        self.device_status_battery_level_unavailable = v;
    }

    // float device_status_battery_level = 12;


    pub fn get_device_status_battery_level(&self) -> f32 {
        self.device_status_battery_level
    }
    pub fn clear_device_status_battery_level(&mut self) {
        self.device_status_battery_level = 0.;
    }

    // Param is passed by value, moved
    pub fn set_device_status_battery_level(&mut self, v: f32) {
        self.device_status_battery_level = v;
    }

    // .google.protobuf.Timestamp last_seen_at = 9;


    pub fn get_last_seen_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_seen_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_last_seen_at(&mut self) {
        self.last_seen_at.clear();
    }

    pub fn has_last_seen_at(&self) -> bool {
        self.last_seen_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_seen_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_seen_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_seen_at.is_none() {
            self.last_seen_at.set_default();
        }
        self.last_seen_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_seen_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_seen_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for DeviceListItem {
    fn is_initialized(&self) -> bool {
        for v in &self.last_seen_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_profile_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_profile_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.device_status_battery = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_status_margin = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.device_status_external_power_source = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.device_status_battery_level_unavailable = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.device_status_battery_level = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_seen_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if !self.device_profile_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_profile_id);
        }
        if !self.device_profile_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.device_profile_name);
        }
        if self.device_status_battery != 0 {
            my_size += ::protobuf::rt::value_size(7, self.device_status_battery, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_status_margin != 0 {
            my_size += ::protobuf::rt::value_size(8, self.device_status_margin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_status_external_power_source != false {
            my_size += 2;
        }
        if self.device_status_battery_level_unavailable != false {
            my_size += 2;
        }
        if self.device_status_battery_level != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.last_seen_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.application_id != 0 {
            os.write_int64(3, self.application_id)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if !self.device_profile_id.is_empty() {
            os.write_string(5, &self.device_profile_id)?;
        }
        if !self.device_profile_name.is_empty() {
            os.write_string(6, &self.device_profile_name)?;
        }
        if self.device_status_battery != 0 {
            os.write_uint32(7, self.device_status_battery)?;
        }
        if self.device_status_margin != 0 {
            os.write_int32(8, self.device_status_margin)?;
        }
        if self.device_status_external_power_source != false {
            os.write_bool(10, self.device_status_external_power_source)?;
        }
        if self.device_status_battery_level_unavailable != false {
            os.write_bool(11, self.device_status_battery_level_unavailable)?;
        }
        if self.device_status_battery_level != 0. {
            os.write_float(12, self.device_status_battery_level)?;
        }
        if let Some(ref v) = self.last_seen_at.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceListItem {
        DeviceListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeviceListItem| { &m.dev_eui },
                    |m: &mut DeviceListItem| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeviceListItem| { &m.name },
                    |m: &mut DeviceListItem| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &DeviceListItem| { &m.application_id },
                    |m: &mut DeviceListItem| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &DeviceListItem| { &m.description },
                    |m: &mut DeviceListItem| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_profile_id",
                    |m: &DeviceListItem| { &m.device_profile_id },
                    |m: &mut DeviceListItem| { &mut m.device_profile_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_profile_name",
                    |m: &DeviceListItem| { &m.device_profile_name },
                    |m: &mut DeviceListItem| { &mut m.device_profile_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "device_status_battery",
                    |m: &DeviceListItem| { &m.device_status_battery },
                    |m: &mut DeviceListItem| { &mut m.device_status_battery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_status_margin",
                    |m: &DeviceListItem| { &m.device_status_margin },
                    |m: &mut DeviceListItem| { &mut m.device_status_margin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "device_status_external_power_source",
                    |m: &DeviceListItem| { &m.device_status_external_power_source },
                    |m: &mut DeviceListItem| { &mut m.device_status_external_power_source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "device_status_battery_level_unavailable",
                    |m: &DeviceListItem| { &m.device_status_battery_level_unavailable },
                    |m: &mut DeviceListItem| { &mut m.device_status_battery_level_unavailable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "device_status_battery_level",
                    |m: &DeviceListItem| { &m.device_status_battery_level },
                    |m: &mut DeviceListItem| { &mut m.device_status_battery_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "last_seen_at",
                    |m: &DeviceListItem| { &m.last_seen_at },
                    |m: &mut DeviceListItem| { &mut m.last_seen_at },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceListItem>(
                    "DeviceListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceListItem {
        static mut instance: ::protobuf::lazy::Lazy<DeviceListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceListItem,
        };
        unsafe {
            instance.get(DeviceListItem::new)
        }
    }
}

impl ::protobuf::Clear for DeviceListItem {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.name.clear();
        self.application_id = 0;
        self.description.clear();
        self.device_profile_id.clear();
        self.device_profile_name.clear();
        self.device_status_battery = 0;
        self.device_status_margin = 0;
        self.device_status_external_power_source = false;
        self.device_status_battery_level_unavailable = false;
        self.device_status_battery_level = 0.;
        self.last_seen_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceKeys {
    // message fields
    pub dev_eui: ::std::string::String,
    pub nwk_key: ::std::string::String,
    pub app_key: ::std::string::String,
    pub gen_app_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceKeys {
    fn default() -> &'a DeviceKeys {
        <DeviceKeys as ::protobuf::Message>::default_instance()
    }
}

impl DeviceKeys {
    pub fn new() -> DeviceKeys {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // string nwk_key = 2;


    pub fn get_nwk_key(&self) -> &str {
        &self.nwk_key
    }
    pub fn clear_nwk_key(&mut self) {
        self.nwk_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_nwk_key(&mut self, v: ::std::string::String) {
        self.nwk_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nwk_key(&mut self) -> &mut ::std::string::String {
        &mut self.nwk_key
    }

    // Take field
    pub fn take_nwk_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nwk_key, ::std::string::String::new())
    }

    // string app_key = 3;


    pub fn get_app_key(&self) -> &str {
        &self.app_key
    }
    pub fn clear_app_key(&mut self) {
        self.app_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_key(&mut self, v: ::std::string::String) {
        self.app_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_key(&mut self) -> &mut ::std::string::String {
        &mut self.app_key
    }

    // Take field
    pub fn take_app_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_key, ::std::string::String::new())
    }

    // string gen_app_key = 4;


    pub fn get_gen_app_key(&self) -> &str {
        &self.gen_app_key
    }
    pub fn clear_gen_app_key(&mut self) {
        self.gen_app_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_gen_app_key(&mut self, v: ::std::string::String) {
        self.gen_app_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gen_app_key(&mut self) -> &mut ::std::string::String {
        &mut self.gen_app_key
    }

    // Take field
    pub fn take_gen_app_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gen_app_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeviceKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nwk_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gen_app_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if !self.nwk_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nwk_key);
        }
        if !self.app_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.app_key);
        }
        if !self.gen_app_key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gen_app_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if !self.nwk_key.is_empty() {
            os.write_string(2, &self.nwk_key)?;
        }
        if !self.app_key.is_empty() {
            os.write_string(3, &self.app_key)?;
        }
        if !self.gen_app_key.is_empty() {
            os.write_string(4, &self.gen_app_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceKeys {
        DeviceKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeviceKeys| { &m.dev_eui },
                    |m: &mut DeviceKeys| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nwk_key",
                    |m: &DeviceKeys| { &m.nwk_key },
                    |m: &mut DeviceKeys| { &mut m.nwk_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_key",
                    |m: &DeviceKeys| { &m.app_key },
                    |m: &mut DeviceKeys| { &mut m.app_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gen_app_key",
                    |m: &DeviceKeys| { &m.gen_app_key },
                    |m: &mut DeviceKeys| { &mut m.gen_app_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceKeys>(
                    "DeviceKeys",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceKeys {
        static mut instance: ::protobuf::lazy::Lazy<DeviceKeys> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceKeys,
        };
        unsafe {
            instance.get(DeviceKeys::new)
        }
    }
}

impl ::protobuf::Clear for DeviceKeys {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.nwk_key.clear();
        self.app_key.clear();
        self.gen_app_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDeviceRequest {
    // message fields
    pub device: ::protobuf::SingularPtrField<Device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDeviceRequest {
    fn default() -> &'a CreateDeviceRequest {
        <CreateDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateDeviceRequest {
    pub fn new() -> CreateDeviceRequest {
        ::std::default::Default::default()
    }

    // .api.Device device = 1;


    pub fn get_device(&self) -> &Device {
        self.device.as_ref().unwrap_or_else(|| Device::default_instance())
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device {
        self.device.take().unwrap_or_else(|| Device::new())
    }
}

impl ::protobuf::Message for CreateDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDeviceRequest {
        CreateDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "device",
                    |m: &CreateDeviceRequest| { &m.device },
                    |m: &mut CreateDeviceRequest| { &mut m.device },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateDeviceRequest>(
                    "CreateDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateDeviceRequest,
        };
        unsafe {
            instance.get(CreateDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateDeviceRequest {
    fn clear(&mut self) {
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceRequest {
    fn default() -> &'a GetDeviceRequest {
        <GetDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceRequest {
    pub fn new() -> GetDeviceRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceRequest {
        GetDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &GetDeviceRequest| { &m.dev_eui },
                    |m: &mut GetDeviceRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceRequest>(
                    "GetDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceRequest,
        };
        unsafe {
            instance.get(GetDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceResponse {
    // message fields
    pub device: ::protobuf::SingularPtrField<Device>,
    pub last_seen_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub device_status_battery: u32,
    pub device_status_margin: i32,
    pub location: ::protobuf::SingularPtrField<super::common::Location>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceResponse {
    fn default() -> &'a GetDeviceResponse {
        <GetDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceResponse {
    pub fn new() -> GetDeviceResponse {
        ::std::default::Default::default()
    }

    // .api.Device device = 1;


    pub fn get_device(&self) -> &Device {
        self.device.as_ref().unwrap_or_else(|| Device::default_instance())
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device {
        self.device.take().unwrap_or_else(|| Device::new())
    }

    // .google.protobuf.Timestamp last_seen_at = 5;


    pub fn get_last_seen_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_seen_at.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_last_seen_at(&mut self) {
        self.last_seen_at.clear();
    }

    pub fn has_last_seen_at(&self) -> bool {
        self.last_seen_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_seen_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_seen_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_seen_at.is_none() {
            self.last_seen_at.set_default();
        }
        self.last_seen_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_seen_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_seen_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // uint32 device_status_battery = 6;


    pub fn get_device_status_battery(&self) -> u32 {
        self.device_status_battery
    }
    pub fn clear_device_status_battery(&mut self) {
        self.device_status_battery = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_status_battery(&mut self, v: u32) {
        self.device_status_battery = v;
    }

    // int32 device_status_margin = 20;


    pub fn get_device_status_margin(&self) -> i32 {
        self.device_status_margin
    }
    pub fn clear_device_status_margin(&mut self) {
        self.device_status_margin = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_status_margin(&mut self, v: i32) {
        self.device_status_margin = v;
    }

    // .common.Location location = 21;


    pub fn get_location(&self) -> &super::common::Location {
        self.location.as_ref().unwrap_or_else(|| super::common::Location::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: super::common::Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut super::common::Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> super::common::Location {
        self.location.take().unwrap_or_else(|| super::common::Location::new())
    }
}

impl ::protobuf::Message for GetDeviceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_seen_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_seen_at)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.device_status_battery = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_status_margin = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_seen_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.device_status_battery != 0 {
            my_size += ::protobuf::rt::value_size(6, self.device_status_battery, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_status_margin != 0 {
            my_size += ::protobuf::rt::value_size(20, self.device_status_margin, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_seen_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.device_status_battery != 0 {
            os.write_uint32(6, self.device_status_battery)?;
        }
        if self.device_status_margin != 0 {
            os.write_int32(20, self.device_status_margin)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceResponse {
        GetDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "device",
                    |m: &GetDeviceResponse| { &m.device },
                    |m: &mut GetDeviceResponse| { &mut m.device },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "last_seen_at",
                    |m: &GetDeviceResponse| { &m.last_seen_at },
                    |m: &mut GetDeviceResponse| { &mut m.last_seen_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "device_status_battery",
                    |m: &GetDeviceResponse| { &m.device_status_battery },
                    |m: &mut GetDeviceResponse| { &mut m.device_status_battery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "device_status_margin",
                    |m: &GetDeviceResponse| { &m.device_status_margin },
                    |m: &mut GetDeviceResponse| { &mut m.device_status_margin },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Location>>(
                    "location",
                    |m: &GetDeviceResponse| { &m.location },
                    |m: &mut GetDeviceResponse| { &mut m.location },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceResponse>(
                    "GetDeviceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceResponse,
        };
        unsafe {
            instance.get(GetDeviceResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceResponse {
    fn clear(&mut self) {
        self.device.clear();
        self.last_seen_at.clear();
        self.device_status_battery = 0;
        self.device_status_margin = 0;
        self.location.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDeviceRequest {
    // message fields
    pub limit: i64,
    pub offset: i64,
    pub application_id: i64,
    pub search: ::std::string::String,
    pub multicast_group_id: ::std::string::String,
    pub service_profile_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDeviceRequest {
    fn default() -> &'a ListDeviceRequest {
        <ListDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDeviceRequest {
    pub fn new() -> ListDeviceRequest {
        ::std::default::Default::default()
    }

    // int64 limit = 1;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 application_id = 3;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string search = 4;


    pub fn get_search(&self) -> &str {
        &self.search
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: ::std::string::String) {
        self.search = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut ::std::string::String {
        &mut self.search
    }

    // Take field
    pub fn take_search(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.search, ::std::string::String::new())
    }

    // string multicast_group_id = 5;


    pub fn get_multicast_group_id(&self) -> &str {
        &self.multicast_group_id
    }
    pub fn clear_multicast_group_id(&mut self) {
        self.multicast_group_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_multicast_group_id(&mut self, v: ::std::string::String) {
        self.multicast_group_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multicast_group_id(&mut self) -> &mut ::std::string::String {
        &mut self.multicast_group_id
    }

    // Take field
    pub fn take_multicast_group_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.multicast_group_id, ::std::string::String::new())
    }

    // string service_profile_id = 6;


    pub fn get_service_profile_id(&self) -> &str {
        &self.service_profile_id
    }
    pub fn clear_service_profile_id(&mut self) {
        self.service_profile_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_profile_id(&mut self, v: ::std::string::String) {
        self.service_profile_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_profile_id(&mut self) -> &mut ::std::string::String {
        &mut self.service_profile_id
    }

    // Take field
    pub fn take_service_profile_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_profile_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.search)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.multicast_group_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_profile_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.search);
        }
        if !self.multicast_group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.multicast_group_id);
        }
        if !self.service_profile_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.service_profile_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_int64(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.application_id != 0 {
            os.write_int64(3, self.application_id)?;
        }
        if !self.search.is_empty() {
            os.write_string(4, &self.search)?;
        }
        if !self.multicast_group_id.is_empty() {
            os.write_string(5, &self.multicast_group_id)?;
        }
        if !self.service_profile_id.is_empty() {
            os.write_string(6, &self.service_profile_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDeviceRequest {
        ListDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ListDeviceRequest| { &m.limit },
                    |m: &mut ListDeviceRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &ListDeviceRequest| { &m.offset },
                    |m: &mut ListDeviceRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &ListDeviceRequest| { &m.application_id },
                    |m: &mut ListDeviceRequest| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "search",
                    |m: &ListDeviceRequest| { &m.search },
                    |m: &mut ListDeviceRequest| { &mut m.search },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "multicast_group_id",
                    |m: &ListDeviceRequest| { &m.multicast_group_id },
                    |m: &mut ListDeviceRequest| { &mut m.multicast_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service_profile_id",
                    |m: &ListDeviceRequest| { &m.service_profile_id },
                    |m: &mut ListDeviceRequest| { &mut m.service_profile_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDeviceRequest>(
                    "ListDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDeviceRequest,
        };
        unsafe {
            instance.get(ListDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListDeviceRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.application_id = 0;
        self.search.clear();
        self.multicast_group_id.clear();
        self.service_profile_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDeviceResponse {
    // message fields
    pub total_count: i64,
    pub result: ::protobuf::RepeatedField<DeviceListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDeviceResponse {
    fn default() -> &'a ListDeviceResponse {
        <ListDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDeviceResponse {
    pub fn new() -> ListDeviceResponse {
        ::std::default::Default::default()
    }

    // int64 total_count = 1;


    pub fn get_total_count(&self) -> i64 {
        self.total_count
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i64) {
        self.total_count = v;
    }

    // repeated .api.DeviceListItem result = 2;


    pub fn get_result(&self) -> &[DeviceListItem] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<DeviceListItem>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<DeviceListItem> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<DeviceListItem> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListDeviceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_count != 0 {
            os.write_int64(1, self.total_count)?;
        }
        for v in &self.result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDeviceResponse {
        ListDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_count",
                    |m: &ListDeviceResponse| { &m.total_count },
                    |m: &mut ListDeviceResponse| { &mut m.total_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceListItem>>(
                    "result",
                    |m: &ListDeviceResponse| { &m.result },
                    |m: &mut ListDeviceResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDeviceResponse>(
                    "ListDeviceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDeviceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListDeviceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDeviceResponse,
        };
        unsafe {
            instance.get(ListDeviceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListDeviceResponse {
    fn clear(&mut self) {
        self.total_count = 0;
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDeviceRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDeviceRequest {
    fn default() -> &'a DeleteDeviceRequest {
        <DeleteDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDeviceRequest {
    pub fn new() -> DeleteDeviceRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDeviceRequest {
        DeleteDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeleteDeviceRequest| { &m.dev_eui },
                    |m: &mut DeleteDeviceRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteDeviceRequest>(
                    "DeleteDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteDeviceRequest,
        };
        unsafe {
            instance.get(DeleteDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteDeviceRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDeviceRequest {
    // message fields
    pub device: ::protobuf::SingularPtrField<Device>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDeviceRequest {
    fn default() -> &'a UpdateDeviceRequest {
        <UpdateDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDeviceRequest {
    pub fn new() -> UpdateDeviceRequest {
        ::std::default::Default::default()
    }

    // .api.Device device = 1;


    pub fn get_device(&self) -> &Device {
        self.device.as_ref().unwrap_or_else(|| Device::default_instance())
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Device) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut Device {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Device {
        self.device.take().unwrap_or_else(|| Device::new())
    }
}

impl ::protobuf::Message for UpdateDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDeviceRequest {
        UpdateDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Device>>(
                    "device",
                    |m: &UpdateDeviceRequest| { &m.device },
                    |m: &mut UpdateDeviceRequest| { &mut m.device },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateDeviceRequest>(
                    "UpdateDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateDeviceRequest,
        };
        unsafe {
            instance.get(UpdateDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateDeviceRequest {
    fn clear(&mut self) {
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDeviceKeysRequest {
    // message fields
    pub device_keys: ::protobuf::SingularPtrField<DeviceKeys>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDeviceKeysRequest {
    fn default() -> &'a CreateDeviceKeysRequest {
        <CreateDeviceKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateDeviceKeysRequest {
    pub fn new() -> CreateDeviceKeysRequest {
        ::std::default::Default::default()
    }

    // .api.DeviceKeys device_keys = 1;


    pub fn get_device_keys(&self) -> &DeviceKeys {
        self.device_keys.as_ref().unwrap_or_else(|| DeviceKeys::default_instance())
    }
    pub fn clear_device_keys(&mut self) {
        self.device_keys.clear();
    }

    pub fn has_device_keys(&self) -> bool {
        self.device_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_keys(&mut self, v: DeviceKeys) {
        self.device_keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_keys(&mut self) -> &mut DeviceKeys {
        if self.device_keys.is_none() {
            self.device_keys.set_default();
        }
        self.device_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_keys(&mut self) -> DeviceKeys {
        self.device_keys.take().unwrap_or_else(|| DeviceKeys::new())
    }
}

impl ::protobuf::Message for CreateDeviceKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_keys.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDeviceKeysRequest {
        CreateDeviceKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceKeys>>(
                    "device_keys",
                    |m: &CreateDeviceKeysRequest| { &m.device_keys },
                    |m: &mut CreateDeviceKeysRequest| { &mut m.device_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateDeviceKeysRequest>(
                    "CreateDeviceKeysRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateDeviceKeysRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateDeviceKeysRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateDeviceKeysRequest,
        };
        unsafe {
            instance.get(CreateDeviceKeysRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateDeviceKeysRequest {
    fn clear(&mut self) {
        self.device_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDeviceKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDeviceKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceKeysRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceKeysRequest {
    fn default() -> &'a GetDeviceKeysRequest {
        <GetDeviceKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceKeysRequest {
    pub fn new() -> GetDeviceKeysRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDeviceKeysRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceKeysRequest {
        GetDeviceKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &GetDeviceKeysRequest| { &m.dev_eui },
                    |m: &mut GetDeviceKeysRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceKeysRequest>(
                    "GetDeviceKeysRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceKeysRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceKeysRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceKeysRequest,
        };
        unsafe {
            instance.get(GetDeviceKeysRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceKeysRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceKeysResponse {
    // message fields
    pub device_keys: ::protobuf::SingularPtrField<DeviceKeys>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceKeysResponse {
    fn default() -> &'a GetDeviceKeysResponse {
        <GetDeviceKeysResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceKeysResponse {
    pub fn new() -> GetDeviceKeysResponse {
        ::std::default::Default::default()
    }

    // .api.DeviceKeys device_keys = 1;


    pub fn get_device_keys(&self) -> &DeviceKeys {
        self.device_keys.as_ref().unwrap_or_else(|| DeviceKeys::default_instance())
    }
    pub fn clear_device_keys(&mut self) {
        self.device_keys.clear();
    }

    pub fn has_device_keys(&self) -> bool {
        self.device_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_keys(&mut self, v: DeviceKeys) {
        self.device_keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_keys(&mut self) -> &mut DeviceKeys {
        if self.device_keys.is_none() {
            self.device_keys.set_default();
        }
        self.device_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_keys(&mut self) -> DeviceKeys {
        self.device_keys.take().unwrap_or_else(|| DeviceKeys::new())
    }
}

impl ::protobuf::Message for GetDeviceKeysResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_keys.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceKeysResponse {
        GetDeviceKeysResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceKeys>>(
                    "device_keys",
                    |m: &GetDeviceKeysResponse| { &m.device_keys },
                    |m: &mut GetDeviceKeysResponse| { &mut m.device_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceKeysResponse>(
                    "GetDeviceKeysResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceKeysResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceKeysResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceKeysResponse,
        };
        unsafe {
            instance.get(GetDeviceKeysResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceKeysResponse {
    fn clear(&mut self) {
        self.device_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceKeysResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceKeysResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDeviceKeysRequest {
    // message fields
    pub device_keys: ::protobuf::SingularPtrField<DeviceKeys>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDeviceKeysRequest {
    fn default() -> &'a UpdateDeviceKeysRequest {
        <UpdateDeviceKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDeviceKeysRequest {
    pub fn new() -> UpdateDeviceKeysRequest {
        ::std::default::Default::default()
    }

    // .api.DeviceKeys device_keys = 1;


    pub fn get_device_keys(&self) -> &DeviceKeys {
        self.device_keys.as_ref().unwrap_or_else(|| DeviceKeys::default_instance())
    }
    pub fn clear_device_keys(&mut self) {
        self.device_keys.clear();
    }

    pub fn has_device_keys(&self) -> bool {
        self.device_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_keys(&mut self, v: DeviceKeys) {
        self.device_keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_keys(&mut self) -> &mut DeviceKeys {
        if self.device_keys.is_none() {
            self.device_keys.set_default();
        }
        self.device_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_keys(&mut self) -> DeviceKeys {
        self.device_keys.take().unwrap_or_else(|| DeviceKeys::new())
    }
}

impl ::protobuf::Message for UpdateDeviceKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_keys.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDeviceKeysRequest {
        UpdateDeviceKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceKeys>>(
                    "device_keys",
                    |m: &UpdateDeviceKeysRequest| { &m.device_keys },
                    |m: &mut UpdateDeviceKeysRequest| { &mut m.device_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateDeviceKeysRequest>(
                    "UpdateDeviceKeysRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateDeviceKeysRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateDeviceKeysRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateDeviceKeysRequest,
        };
        unsafe {
            instance.get(UpdateDeviceKeysRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateDeviceKeysRequest {
    fn clear(&mut self) {
        self.device_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDeviceKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDeviceKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDeviceKeysRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDeviceKeysRequest {
    fn default() -> &'a DeleteDeviceKeysRequest {
        <DeleteDeviceKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDeviceKeysRequest {
    pub fn new() -> DeleteDeviceKeysRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteDeviceKeysRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDeviceKeysRequest {
        DeleteDeviceKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeleteDeviceKeysRequest| { &m.dev_eui },
                    |m: &mut DeleteDeviceKeysRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteDeviceKeysRequest>(
                    "DeleteDeviceKeysRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteDeviceKeysRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteDeviceKeysRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteDeviceKeysRequest,
        };
        unsafe {
            instance.get(DeleteDeviceKeysRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteDeviceKeysRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDeviceKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDeviceKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceActivation {
    // message fields
    pub dev_eui: ::std::string::String,
    pub dev_addr: ::std::string::String,
    pub app_s_key: ::std::string::String,
    pub nwk_s_enc_key: ::std::string::String,
    pub s_nwk_s_int_key: ::std::string::String,
    pub f_nwk_s_int_key: ::std::string::String,
    pub f_cnt_up: u32,
    pub n_f_cnt_down: u32,
    pub a_f_cnt_down: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceActivation {
    fn default() -> &'a DeviceActivation {
        <DeviceActivation as ::protobuf::Message>::default_instance()
    }
}

impl DeviceActivation {
    pub fn new() -> DeviceActivation {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }

    // string dev_addr = 2;


    pub fn get_dev_addr(&self) -> &str {
        &self.dev_addr
    }
    pub fn clear_dev_addr(&mut self) {
        self.dev_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_addr(&mut self, v: ::std::string::String) {
        self.dev_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_addr(&mut self) -> &mut ::std::string::String {
        &mut self.dev_addr
    }

    // Take field
    pub fn take_dev_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_addr, ::std::string::String::new())
    }

    // string app_s_key = 3;


    pub fn get_app_s_key(&self) -> &str {
        &self.app_s_key
    }
    pub fn clear_app_s_key(&mut self) {
        self.app_s_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_s_key(&mut self, v: ::std::string::String) {
        self.app_s_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_s_key(&mut self) -> &mut ::std::string::String {
        &mut self.app_s_key
    }

    // Take field
    pub fn take_app_s_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.app_s_key, ::std::string::String::new())
    }

    // string nwk_s_enc_key = 4;


    pub fn get_nwk_s_enc_key(&self) -> &str {
        &self.nwk_s_enc_key
    }
    pub fn clear_nwk_s_enc_key(&mut self) {
        self.nwk_s_enc_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_nwk_s_enc_key(&mut self, v: ::std::string::String) {
        self.nwk_s_enc_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nwk_s_enc_key(&mut self) -> &mut ::std::string::String {
        &mut self.nwk_s_enc_key
    }

    // Take field
    pub fn take_nwk_s_enc_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nwk_s_enc_key, ::std::string::String::new())
    }

    // string s_nwk_s_int_key = 8;


    pub fn get_s_nwk_s_int_key(&self) -> &str {
        &self.s_nwk_s_int_key
    }
    pub fn clear_s_nwk_s_int_key(&mut self) {
        self.s_nwk_s_int_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_s_nwk_s_int_key(&mut self, v: ::std::string::String) {
        self.s_nwk_s_int_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s_nwk_s_int_key(&mut self) -> &mut ::std::string::String {
        &mut self.s_nwk_s_int_key
    }

    // Take field
    pub fn take_s_nwk_s_int_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s_nwk_s_int_key, ::std::string::String::new())
    }

    // string f_nwk_s_int_key = 9;


    pub fn get_f_nwk_s_int_key(&self) -> &str {
        &self.f_nwk_s_int_key
    }
    pub fn clear_f_nwk_s_int_key(&mut self) {
        self.f_nwk_s_int_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_f_nwk_s_int_key(&mut self, v: ::std::string::String) {
        self.f_nwk_s_int_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f_nwk_s_int_key(&mut self) -> &mut ::std::string::String {
        &mut self.f_nwk_s_int_key
    }

    // Take field
    pub fn take_f_nwk_s_int_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.f_nwk_s_int_key, ::std::string::String::new())
    }

    // uint32 f_cnt_up = 5;


    pub fn get_f_cnt_up(&self) -> u32 {
        self.f_cnt_up
    }
    pub fn clear_f_cnt_up(&mut self) {
        self.f_cnt_up = 0;
    }

    // Param is passed by value, moved
    pub fn set_f_cnt_up(&mut self, v: u32) {
        self.f_cnt_up = v;
    }

    // uint32 n_f_cnt_down = 6;


    pub fn get_n_f_cnt_down(&self) -> u32 {
        self.n_f_cnt_down
    }
    pub fn clear_n_f_cnt_down(&mut self) {
        self.n_f_cnt_down = 0;
    }

    // Param is passed by value, moved
    pub fn set_n_f_cnt_down(&mut self, v: u32) {
        self.n_f_cnt_down = v;
    }

    // uint32 a_f_cnt_down = 10;


    pub fn get_a_f_cnt_down(&self) -> u32 {
        self.a_f_cnt_down
    }
    pub fn clear_a_f_cnt_down(&mut self) {
        self.a_f_cnt_down = 0;
    }

    // Param is passed by value, moved
    pub fn set_a_f_cnt_down(&mut self, v: u32) {
        self.a_f_cnt_down = v;
    }
}

impl ::protobuf::Message for DeviceActivation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.app_s_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nwk_s_enc_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s_nwk_s_int_key)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.f_nwk_s_int_key)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f_cnt_up = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.n_f_cnt_down = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.a_f_cnt_down = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        if !self.dev_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dev_addr);
        }
        if !self.app_s_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.app_s_key);
        }
        if !self.nwk_s_enc_key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.nwk_s_enc_key);
        }
        if !self.s_nwk_s_int_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.s_nwk_s_int_key);
        }
        if !self.f_nwk_s_int_key.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.f_nwk_s_int_key);
        }
        if self.f_cnt_up != 0 {
            my_size += ::protobuf::rt::value_size(5, self.f_cnt_up, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.n_f_cnt_down != 0 {
            my_size += ::protobuf::rt::value_size(6, self.n_f_cnt_down, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.a_f_cnt_down != 0 {
            my_size += ::protobuf::rt::value_size(10, self.a_f_cnt_down, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        if !self.dev_addr.is_empty() {
            os.write_string(2, &self.dev_addr)?;
        }
        if !self.app_s_key.is_empty() {
            os.write_string(3, &self.app_s_key)?;
        }
        if !self.nwk_s_enc_key.is_empty() {
            os.write_string(4, &self.nwk_s_enc_key)?;
        }
        if !self.s_nwk_s_int_key.is_empty() {
            os.write_string(8, &self.s_nwk_s_int_key)?;
        }
        if !self.f_nwk_s_int_key.is_empty() {
            os.write_string(9, &self.f_nwk_s_int_key)?;
        }
        if self.f_cnt_up != 0 {
            os.write_uint32(5, self.f_cnt_up)?;
        }
        if self.n_f_cnt_down != 0 {
            os.write_uint32(6, self.n_f_cnt_down)?;
        }
        if self.a_f_cnt_down != 0 {
            os.write_uint32(10, self.a_f_cnt_down)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceActivation {
        DeviceActivation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeviceActivation| { &m.dev_eui },
                    |m: &mut DeviceActivation| { &mut m.dev_eui },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_addr",
                    |m: &DeviceActivation| { &m.dev_addr },
                    |m: &mut DeviceActivation| { &mut m.dev_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_s_key",
                    |m: &DeviceActivation| { &m.app_s_key },
                    |m: &mut DeviceActivation| { &mut m.app_s_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nwk_s_enc_key",
                    |m: &DeviceActivation| { &m.nwk_s_enc_key },
                    |m: &mut DeviceActivation| { &mut m.nwk_s_enc_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "s_nwk_s_int_key",
                    |m: &DeviceActivation| { &m.s_nwk_s_int_key },
                    |m: &mut DeviceActivation| { &mut m.s_nwk_s_int_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "f_nwk_s_int_key",
                    |m: &DeviceActivation| { &m.f_nwk_s_int_key },
                    |m: &mut DeviceActivation| { &mut m.f_nwk_s_int_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "f_cnt_up",
                    |m: &DeviceActivation| { &m.f_cnt_up },
                    |m: &mut DeviceActivation| { &mut m.f_cnt_up },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "n_f_cnt_down",
                    |m: &DeviceActivation| { &m.n_f_cnt_down },
                    |m: &mut DeviceActivation| { &mut m.n_f_cnt_down },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "a_f_cnt_down",
                    |m: &DeviceActivation| { &m.a_f_cnt_down },
                    |m: &mut DeviceActivation| { &mut m.a_f_cnt_down },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceActivation>(
                    "DeviceActivation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceActivation {
        static mut instance: ::protobuf::lazy::Lazy<DeviceActivation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceActivation,
        };
        unsafe {
            instance.get(DeviceActivation::new)
        }
    }
}

impl ::protobuf::Clear for DeviceActivation {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.dev_addr.clear();
        self.app_s_key.clear();
        self.nwk_s_enc_key.clear();
        self.s_nwk_s_int_key.clear();
        self.f_nwk_s_int_key.clear();
        self.f_cnt_up = 0;
        self.n_f_cnt_down = 0;
        self.a_f_cnt_down = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceActivation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceActivation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActivateDeviceRequest {
    // message fields
    pub device_activation: ::protobuf::SingularPtrField<DeviceActivation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActivateDeviceRequest {
    fn default() -> &'a ActivateDeviceRequest {
        <ActivateDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivateDeviceRequest {
    pub fn new() -> ActivateDeviceRequest {
        ::std::default::Default::default()
    }

    // .api.DeviceActivation device_activation = 1;


    pub fn get_device_activation(&self) -> &DeviceActivation {
        self.device_activation.as_ref().unwrap_or_else(|| DeviceActivation::default_instance())
    }
    pub fn clear_device_activation(&mut self) {
        self.device_activation.clear();
    }

    pub fn has_device_activation(&self) -> bool {
        self.device_activation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_activation(&mut self, v: DeviceActivation) {
        self.device_activation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_activation(&mut self) -> &mut DeviceActivation {
        if self.device_activation.is_none() {
            self.device_activation.set_default();
        }
        self.device_activation.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_activation(&mut self) -> DeviceActivation {
        self.device_activation.take().unwrap_or_else(|| DeviceActivation::new())
    }
}

impl ::protobuf::Message for ActivateDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device_activation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_activation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_activation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_activation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivateDeviceRequest {
        ActivateDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceActivation>>(
                    "device_activation",
                    |m: &ActivateDeviceRequest| { &m.device_activation },
                    |m: &mut ActivateDeviceRequest| { &mut m.device_activation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActivateDeviceRequest>(
                    "ActivateDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActivateDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ActivateDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActivateDeviceRequest,
        };
        unsafe {
            instance.get(ActivateDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ActivateDeviceRequest {
    fn clear(&mut self) {
        self.device_activation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivateDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivateDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeactivateDeviceRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeactivateDeviceRequest {
    fn default() -> &'a DeactivateDeviceRequest {
        <DeactivateDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeactivateDeviceRequest {
    pub fn new() -> DeactivateDeviceRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeactivateDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeactivateDeviceRequest {
        DeactivateDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &DeactivateDeviceRequest| { &m.dev_eui },
                    |m: &mut DeactivateDeviceRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeactivateDeviceRequest>(
                    "DeactivateDeviceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeactivateDeviceRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeactivateDeviceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeactivateDeviceRequest,
        };
        unsafe {
            instance.get(DeactivateDeviceRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeactivateDeviceRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeactivateDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeactivateDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceActivationRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceActivationRequest {
    fn default() -> &'a GetDeviceActivationRequest {
        <GetDeviceActivationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceActivationRequest {
    pub fn new() -> GetDeviceActivationRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDeviceActivationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceActivationRequest {
        GetDeviceActivationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &GetDeviceActivationRequest| { &m.dev_eui },
                    |m: &mut GetDeviceActivationRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceActivationRequest>(
                    "GetDeviceActivationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceActivationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceActivationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceActivationRequest,
        };
        unsafe {
            instance.get(GetDeviceActivationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceActivationRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceActivationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceActivationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceActivationResponse {
    // message fields
    pub device_activation: ::protobuf::SingularPtrField<DeviceActivation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceActivationResponse {
    fn default() -> &'a GetDeviceActivationResponse {
        <GetDeviceActivationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceActivationResponse {
    pub fn new() -> GetDeviceActivationResponse {
        ::std::default::Default::default()
    }

    // .api.DeviceActivation device_activation = 1;


    pub fn get_device_activation(&self) -> &DeviceActivation {
        self.device_activation.as_ref().unwrap_or_else(|| DeviceActivation::default_instance())
    }
    pub fn clear_device_activation(&mut self) {
        self.device_activation.clear();
    }

    pub fn has_device_activation(&self) -> bool {
        self.device_activation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_activation(&mut self, v: DeviceActivation) {
        self.device_activation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_activation(&mut self) -> &mut DeviceActivation {
        if self.device_activation.is_none() {
            self.device_activation.set_default();
        }
        self.device_activation.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_activation(&mut self) -> DeviceActivation {
        self.device_activation.take().unwrap_or_else(|| DeviceActivation::new())
    }
}

impl ::protobuf::Message for GetDeviceActivationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device_activation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_activation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_activation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_activation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceActivationResponse {
        GetDeviceActivationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceActivation>>(
                    "device_activation",
                    |m: &GetDeviceActivationResponse| { &m.device_activation },
                    |m: &mut GetDeviceActivationResponse| { &mut m.device_activation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeviceActivationResponse>(
                    "GetDeviceActivationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeviceActivationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDeviceActivationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeviceActivationResponse,
        };
        unsafe {
            instance.get(GetDeviceActivationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDeviceActivationResponse {
    fn clear(&mut self) {
        self.device_activation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceActivationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceActivationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRandomDevAddrRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRandomDevAddrRequest {
    fn default() -> &'a GetRandomDevAddrRequest {
        <GetRandomDevAddrRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRandomDevAddrRequest {
    pub fn new() -> GetRandomDevAddrRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetRandomDevAddrRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRandomDevAddrRequest {
        GetRandomDevAddrRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &GetRandomDevAddrRequest| { &m.dev_eui },
                    |m: &mut GetRandomDevAddrRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRandomDevAddrRequest>(
                    "GetRandomDevAddrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRandomDevAddrRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetRandomDevAddrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRandomDevAddrRequest,
        };
        unsafe {
            instance.get(GetRandomDevAddrRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetRandomDevAddrRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRandomDevAddrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRandomDevAddrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRandomDevAddrResponse {
    // message fields
    pub dev_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRandomDevAddrResponse {
    fn default() -> &'a GetRandomDevAddrResponse {
        <GetRandomDevAddrResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRandomDevAddrResponse {
    pub fn new() -> GetRandomDevAddrResponse {
        ::std::default::Default::default()
    }

    // string dev_addr = 1;


    pub fn get_dev_addr(&self) -> &str {
        &self.dev_addr
    }
    pub fn clear_dev_addr(&mut self) {
        self.dev_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_addr(&mut self, v: ::std::string::String) {
        self.dev_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_addr(&mut self) -> &mut ::std::string::String {
        &mut self.dev_addr
    }

    // Take field
    pub fn take_dev_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetRandomDevAddrResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_addr.is_empty() {
            os.write_string(1, &self.dev_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRandomDevAddrResponse {
        GetRandomDevAddrResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_addr",
                    |m: &GetRandomDevAddrResponse| { &m.dev_addr },
                    |m: &mut GetRandomDevAddrResponse| { &mut m.dev_addr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRandomDevAddrResponse>(
                    "GetRandomDevAddrResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRandomDevAddrResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetRandomDevAddrResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRandomDevAddrResponse,
        };
        unsafe {
            instance.get(GetRandomDevAddrResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetRandomDevAddrResponse {
    fn clear(&mut self) {
        self.dev_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRandomDevAddrResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRandomDevAddrResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamDeviceFrameLogsRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamDeviceFrameLogsRequest {
    fn default() -> &'a StreamDeviceFrameLogsRequest {
        <StreamDeviceFrameLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamDeviceFrameLogsRequest {
    pub fn new() -> StreamDeviceFrameLogsRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamDeviceFrameLogsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamDeviceFrameLogsRequest {
        StreamDeviceFrameLogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &StreamDeviceFrameLogsRequest| { &m.dev_eui },
                    |m: &mut StreamDeviceFrameLogsRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamDeviceFrameLogsRequest>(
                    "StreamDeviceFrameLogsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamDeviceFrameLogsRequest {
        static mut instance: ::protobuf::lazy::Lazy<StreamDeviceFrameLogsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamDeviceFrameLogsRequest,
        };
        unsafe {
            instance.get(StreamDeviceFrameLogsRequest::new)
        }
    }
}

impl ::protobuf::Clear for StreamDeviceFrameLogsRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamDeviceFrameLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamDeviceFrameLogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamDeviceFrameLogsResponse {
    // message oneof groups
    pub frame: ::std::option::Option<StreamDeviceFrameLogsResponse_oneof_frame>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamDeviceFrameLogsResponse {
    fn default() -> &'a StreamDeviceFrameLogsResponse {
        <StreamDeviceFrameLogsResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StreamDeviceFrameLogsResponse_oneof_frame {
    uplink_frame(super::frameLog::UplinkFrameLog),
    downlink_frame(super::frameLog::DownlinkFrameLog),
}

impl StreamDeviceFrameLogsResponse {
    pub fn new() -> StreamDeviceFrameLogsResponse {
        ::std::default::Default::default()
    }

    // .api.UplinkFrameLog uplink_frame = 1;


    pub fn get_uplink_frame(&self) -> &super::frameLog::UplinkFrameLog {
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(ref v)) => v,
            _ => super::frameLog::UplinkFrameLog::default_instance(),
        }
    }
    pub fn clear_uplink_frame(&mut self) {
        self.frame = ::std::option::Option::None;
    }

    pub fn has_uplink_frame(&self) -> bool {
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uplink_frame(&mut self, v: super::frameLog::UplinkFrameLog) {
        self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uplink_frame(&mut self) -> &mut super::frameLog::UplinkFrameLog {
        if let ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(_)) = self.frame {
        } else {
            self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(super::frameLog::UplinkFrameLog::new()));
        }
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uplink_frame(&mut self) -> super::frameLog::UplinkFrameLog {
        if self.has_uplink_frame() {
            match self.frame.take() {
                ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(v)) => v,
                _ => panic!(),
            }
        } else {
            super::frameLog::UplinkFrameLog::new()
        }
    }

    // .api.DownlinkFrameLog downlink_frame = 2;


    pub fn get_downlink_frame(&self) -> &super::frameLog::DownlinkFrameLog {
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(ref v)) => v,
            _ => super::frameLog::DownlinkFrameLog::default_instance(),
        }
    }
    pub fn clear_downlink_frame(&mut self) {
        self.frame = ::std::option::Option::None;
    }

    pub fn has_downlink_frame(&self) -> bool {
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_downlink_frame(&mut self, v: super::frameLog::DownlinkFrameLog) {
        self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_downlink_frame(&mut self) -> &mut super::frameLog::DownlinkFrameLog {
        if let ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(_)) = self.frame {
        } else {
            self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(super::frameLog::DownlinkFrameLog::new()));
        }
        match self.frame {
            ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_downlink_frame(&mut self) -> super::frameLog::DownlinkFrameLog {
        if self.has_downlink_frame() {
            match self.frame.take() {
                ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(v)) => v,
                _ => panic!(),
            }
        } else {
            super::frameLog::DownlinkFrameLog::new()
        }
    }
}

impl ::protobuf::Message for StreamDeviceFrameLogsResponse {
    fn is_initialized(&self) -> bool {
        if let Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(ref v)) = self.frame {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(ref v)) = self.frame {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame = ::std::option::Option::Some(StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.frame {
            match v {
                &StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.frame {
            match v {
                &StreamDeviceFrameLogsResponse_oneof_frame::uplink_frame(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamDeviceFrameLogsResponse_oneof_frame::downlink_frame(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamDeviceFrameLogsResponse {
        StreamDeviceFrameLogsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::frameLog::UplinkFrameLog>(
                    "uplink_frame",
                    StreamDeviceFrameLogsResponse::has_uplink_frame,
                    StreamDeviceFrameLogsResponse::get_uplink_frame,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::frameLog::DownlinkFrameLog>(
                    "downlink_frame",
                    StreamDeviceFrameLogsResponse::has_downlink_frame,
                    StreamDeviceFrameLogsResponse::get_downlink_frame,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamDeviceFrameLogsResponse>(
                    "StreamDeviceFrameLogsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamDeviceFrameLogsResponse {
        static mut instance: ::protobuf::lazy::Lazy<StreamDeviceFrameLogsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamDeviceFrameLogsResponse,
        };
        unsafe {
            instance.get(StreamDeviceFrameLogsResponse::new)
        }
    }
}

impl ::protobuf::Clear for StreamDeviceFrameLogsResponse {
    fn clear(&mut self) {
        self.frame = ::std::option::Option::None;
        self.frame = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamDeviceFrameLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamDeviceFrameLogsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamDeviceEventLogsRequest {
    // message fields
    pub dev_eui: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamDeviceEventLogsRequest {
    fn default() -> &'a StreamDeviceEventLogsRequest {
        <StreamDeviceEventLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamDeviceEventLogsRequest {
    pub fn new() -> StreamDeviceEventLogsRequest {
        ::std::default::Default::default()
    }

    // string dev_eui = 1;


    pub fn get_dev_eui(&self) -> &str {
        &self.dev_eui
    }
    pub fn clear_dev_eui(&mut self) {
        self.dev_eui.clear();
    }

    // Param is passed by value, moved
    pub fn set_dev_eui(&mut self, v: ::std::string::String) {
        self.dev_eui = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_eui(&mut self) -> &mut ::std::string::String {
        &mut self.dev_eui
    }

    // Take field
    pub fn take_dev_eui(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dev_eui, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamDeviceEventLogsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dev_eui)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dev_eui.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dev_eui);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dev_eui.is_empty() {
            os.write_string(1, &self.dev_eui)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamDeviceEventLogsRequest {
        StreamDeviceEventLogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dev_eui",
                    |m: &StreamDeviceEventLogsRequest| { &m.dev_eui },
                    |m: &mut StreamDeviceEventLogsRequest| { &mut m.dev_eui },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamDeviceEventLogsRequest>(
                    "StreamDeviceEventLogsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamDeviceEventLogsRequest {
        static mut instance: ::protobuf::lazy::Lazy<StreamDeviceEventLogsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamDeviceEventLogsRequest,
        };
        unsafe {
            instance.get(StreamDeviceEventLogsRequest::new)
        }
    }
}

impl ::protobuf::Clear for StreamDeviceEventLogsRequest {
    fn clear(&mut self) {
        self.dev_eui.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamDeviceEventLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamDeviceEventLogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamDeviceEventLogsResponse {
    // message fields
    pub field_type: ::std::string::String,
    pub payload_json: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamDeviceEventLogsResponse {
    fn default() -> &'a StreamDeviceEventLogsResponse {
        <StreamDeviceEventLogsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamDeviceEventLogsResponse {
    pub fn new() -> StreamDeviceEventLogsResponse {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string payload_json = 2;


    pub fn get_payload_json(&self) -> &str {
        &self.payload_json
    }
    pub fn clear_payload_json(&mut self) {
        self.payload_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_json(&mut self, v: ::std::string::String) {
        self.payload_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_json(&mut self) -> &mut ::std::string::String {
        &mut self.payload_json
    }

    // Take field
    pub fn take_payload_json(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_json, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamDeviceEventLogsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_json)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if !self.payload_json.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payload_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if !self.payload_json.is_empty() {
            os.write_string(2, &self.payload_json)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamDeviceEventLogsResponse {
        StreamDeviceEventLogsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &StreamDeviceEventLogsResponse| { &m.field_type },
                    |m: &mut StreamDeviceEventLogsResponse| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_json",
                    |m: &StreamDeviceEventLogsResponse| { &m.payload_json },
                    |m: &mut StreamDeviceEventLogsResponse| { &mut m.payload_json },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamDeviceEventLogsResponse>(
                    "StreamDeviceEventLogsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamDeviceEventLogsResponse {
        static mut instance: ::protobuf::lazy::Lazy<StreamDeviceEventLogsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamDeviceEventLogsResponse,
        };
        unsafe {
            instance.get(StreamDeviceEventLogsResponse::new)
        }
    }
}

impl ::protobuf::Clear for StreamDeviceEventLogsResponse {
    fn clear(&mut self) {
        self.field_type.clear();
        self.payload_json.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamDeviceEventLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamDeviceEventLogsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cas/external/api/device.proto\x12\x03api\x1a\x1cgoogle/api/annotati\
    ons.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/\
    empty.proto\x1a\x13common/common.proto\x1a\x1eas/external/api/frameLog.p\
    roto\"\xde\x03\n\x06Device\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06d\
    evEUI\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12%\n\x0eapplicatio\
    n_id\x18\x03\x20\x01(\x03R\rapplicationID\x12\x20\n\x0bdescription\x18\
    \x04\x20\x01(\tR\x0bdescription\x12*\n\x11device_profile_id\x18\x05\x20\
    \x01(\tR\x0fdeviceProfileID\x12'\n\x10skip_f_cnt_check\x18\x06\x20\x01(\
    \x08R\rskipFCntCheck\x12-\n\x12reference_altitude\x18\x07\x20\x01(\x01R\
    \x11referenceAltitude\x128\n\tvariables\x18\x08\x20\x03(\x0b2\x1a.api.De\
    vice.VariablesEntryR\tvariables\x12)\n\x04tags\x18\t\x20\x03(\x0b2\x15.a\
    pi.Device.TagsEntryR\x04tags\x1a<\n\x0eVariablesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a7\n\tTagsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xe9\x04\
    \n\x0eDeviceListItem\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12%\n\x0eapplication_id\
    \x18\x03\x20\x01(\x03R\rapplicationID\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12*\n\x11device_profile_id\x18\x05\x20\x01(\
    \tR\x0fdeviceProfileID\x12.\n\x13device_profile_name\x18\x06\x20\x01(\tR\
    \x11deviceProfileName\x122\n\x15device_status_battery\x18\x07\x20\x01(\r\
    R\x13deviceStatusBattery\x120\n\x14device_status_margin\x18\x08\x20\x01(\
    \x05R\x12deviceStatusMargin\x12L\n#device_status_external_power_source\
    \x18\n\x20\x01(\x08R\x1fdeviceStatusExternalPowerSource\x12T\n'device_st\
    atus_battery_level_unavailable\x18\x0b\x20\x01(\x08R#deviceStatusBattery\
    LevelUnavailable\x12=\n\x1bdevice_status_battery_level\x18\x0c\x20\x01(\
    \x02R\x18deviceStatusBatteryLevel\x12<\n\x0clast_seen_at\x18\t\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nlastSeenAt\"w\n\nDeviceKeys\x12\
    \x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\x12\x17\n\x07nwk_key\x18\
    \x02\x20\x01(\tR\x06nwkKey\x12\x17\n\x07app_key\x18\x03\x20\x01(\tR\x06a\
    ppKey\x12\x1e\n\x0bgen_app_key\x18\x04\x20\x01(\tR\tgenAppKey\":\n\x13Cr\
    eateDeviceRequest\x12#\n\x06device\x18\x01\x20\x01(\x0b2\x0b.api.DeviceR\
    \x06device\"+\n\x10GetDeviceRequest\x12\x17\n\x07dev_eui\x18\x01\x20\x01\
    (\tR\x06devEUI\"\x8a\x02\n\x11GetDeviceResponse\x12#\n\x06device\x18\x01\
    \x20\x01(\x0b2\x0b.api.DeviceR\x06device\x12<\n\x0clast_seen_at\x18\x05\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nlastSeenAt\x122\n\x15devi\
    ce_status_battery\x18\x06\x20\x01(\rR\x13deviceStatusBattery\x120\n\x14d\
    evice_status_margin\x18\x14\x20\x01(\x05R\x12deviceStatusMargin\x12,\n\
    \x08location\x18\x15\x20\x01(\x0b2\x10.common.LocationR\x08location\"\
    \xdc\x01\n\x11ListDeviceRequest\x12\x14\n\x05limit\x18\x01\x20\x01(\x03R\
    \x05limit\x12\x16\n\x06offset\x18\x02\x20\x01(\x03R\x06offset\x12%\n\x0e\
    application_id\x18\x03\x20\x01(\x03R\rapplicationID\x12\x16\n\x06search\
    \x18\x04\x20\x01(\tR\x06search\x12,\n\x12multicast_group_id\x18\x05\x20\
    \x01(\tR\x10multicastGroupID\x12,\n\x12service_profile_id\x18\x06\x20\
    \x01(\tR\x10serviceProfileID\"b\n\x12ListDeviceResponse\x12\x1f\n\x0btot\
    al_count\x18\x01\x20\x01(\x03R\ntotalCount\x12+\n\x06result\x18\x02\x20\
    \x03(\x0b2\x13.api.DeviceListItemR\x06result\".\n\x13DeleteDeviceRequest\
    \x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\":\n\x13UpdateDevice\
    Request\x12#\n\x06device\x18\x01\x20\x01(\x0b2\x0b.api.DeviceR\x06device\
    \"K\n\x17CreateDeviceKeysRequest\x120\n\x0bdevice_keys\x18\x01\x20\x01(\
    \x0b2\x0f.api.DeviceKeysR\ndeviceKeys\"/\n\x14GetDeviceKeysRequest\x12\
    \x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\"I\n\x15GetDeviceKeysRes\
    ponse\x120\n\x0bdevice_keys\x18\x01\x20\x01(\x0b2\x0f.api.DeviceKeysR\nd\
    eviceKeys\"K\n\x17UpdateDeviceKeysRequest\x120\n\x0bdevice_keys\x18\x01\
    \x20\x01(\x0b2\x0f.api.DeviceKeysR\ndeviceKeys\"2\n\x17DeleteDeviceKeysR\
    equest\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\"\xad\x02\n\
    \x10DeviceActivation\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\
    \x12\x19\n\x08dev_addr\x18\x02\x20\x01(\tR\x07devAddr\x12\x1a\n\tapp_s_k\
    ey\x18\x03\x20\x01(\tR\x07appSKey\x12!\n\rnwk_s_enc_key\x18\x04\x20\x01(\
    \tR\nnwkSEncKey\x12$\n\x0fs_nwk_s_int_key\x18\x08\x20\x01(\tR\x0bsNwkSIn\
    tKey\x12$\n\x0ff_nwk_s_int_key\x18\t\x20\x01(\tR\x0bfNwkSIntKey\x12\x18\
    \n\x08f_cnt_up\x18\x05\x20\x01(\rR\x06fCntUp\x12\x1f\n\x0cn_f_cnt_down\
    \x18\x06\x20\x01(\rR\tnFCntDown\x12\x1f\n\x0ca_f_cnt_down\x18\n\x20\x01(\
    \rR\taFCntDown\"[\n\x15ActivateDeviceRequest\x12B\n\x11device_activation\
    \x18\x01\x20\x01(\x0b2\x15.api.DeviceActivationR\x10deviceActivation\"2\
    \n\x17DeactivateDeviceRequest\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\
    \x06devEUI\"5\n\x1aGetDeviceActivationRequest\x12\x17\n\x07dev_eui\x18\
    \x01\x20\x01(\tR\x06devEUI\"a\n\x1bGetDeviceActivationResponse\x12B\n\
    \x11device_activation\x18\x01\x20\x01(\x0b2\x15.api.DeviceActivationR\
    \x10deviceActivation\"2\n\x17GetRandomDevAddrRequest\x12\x17\n\x07dev_eu\
    i\x18\x01\x20\x01(\tR\x06devEUI\"5\n\x18GetRandomDevAddrResponse\x12\x19\
    \n\x08dev_addr\x18\x01\x20\x01(\tR\x07devAddr\"7\n\x1cStreamDeviceFrameL\
    ogsRequest\x12\x17\n\x07dev_eui\x18\x01\x20\x01(\tR\x06devEUI\"\xa2\x01\
    \n\x1dStreamDeviceFrameLogsResponse\x128\n\x0cuplink_frame\x18\x01\x20\
    \x01(\x0b2\x13.api.UplinkFrameLogH\0R\x0buplinkFrame\x12>\n\x0edownlink_\
    frame\x18\x02\x20\x01(\x0b2\x15.api.DownlinkFrameLogH\0R\rdownlinkFrameB\
    \x07\n\x05frame\"7\n\x1cStreamDeviceEventLogsRequest\x12\x17\n\x07dev_eu\
    i\x18\x01\x20\x01(\tR\x06devEUI\"V\n\x1dStreamDeviceEventLogsResponse\
    \x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12!\n\x0cpayload_json\
    \x18\x02\x20\x01(\tR\x0bpayloadJSON2\x82\r\n\rDeviceService\x12S\n\x06Cr\
    eate\x12\x18.api.CreateDeviceRequest\x1a\x16.google.protobuf.Empty\"\x17\
    \x82\xd3\xe4\x93\x02\x11\"\x0c/api/devices:\x01*\x12T\n\x03Get\x12\x15.a\
    pi.GetDeviceRequest\x1a\x16.api.GetDeviceResponse\"\x1e\x82\xd3\xe4\x93\
    \x02\x18\x12\x16/api/devices/{dev_eui}\x12M\n\x04List\x12\x16.api.ListDe\
    viceRequest\x1a\x17.api.ListDeviceResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\
    \x12\x0c/api/devices\x12Z\n\x06Delete\x12\x18.api.DeleteDeviceRequest\
    \x1a\x16.google.protobuf.Empty\"\x1e\x82\xd3\xe4\x93\x02\x18*\x16/api/de\
    vices/{dev_eui}\x12d\n\x06Update\x12\x18.api.UpdateDeviceRequest\x1a\x16\
    .google.protobuf.Empty\"(\x82\xd3\xe4\x93\x02\"\x1a\x1d/api/devices/{dev\
    ice.dev_eui}:\x01*\x12v\n\nCreateKeys\x12\x1c.api.CreateDeviceKeysReques\
    t\x1a\x16.google.protobuf.Empty\"2\x82\xd3\xe4\x93\x02,\"'/api/devices/{\
    device_keys.dev_eui}/keys:\x01*\x12e\n\x07GetKeys\x12\x19.api.GetDeviceK\
    eysRequest\x1a\x1a.api.GetDeviceKeysResponse\"#\x82\xd3\xe4\x93\x02\x1d\
    \x12\x1b/api/devices/{dev_eui}/keys\x12v\n\nUpdateKeys\x12\x1c.api.Updat\
    eDeviceKeysRequest\x1a\x16.google.protobuf.Empty\"2\x82\xd3\xe4\x93\x02,\
    \x1a'/api/devices/{device_keys.dev_eui}/keys:\x01*\x12g\n\nDeleteKeys\
    \x12\x1c.api.DeleteDeviceKeysRequest\x1a\x16.google.protobuf.Empty\"#\
    \x82\xd3\xe4\x93\x02\x1d*\x1b/api/devices/{dev_eui}/keys\x12|\n\x08Activ\
    ate\x12\x1a.api.ActivateDeviceRequest\x1a\x16.google.protobuf.Empty\"<\
    \x82\xd3\xe4\x93\x026\"1/api/devices/{device_activation.dev_eui}/activat\
    e:\x01*\x12m\n\nDeactivate\x12\x1c.api.DeactivateDeviceRequest\x1a\x16.g\
    oogle.protobuf.Empty\")\x82\xd3\xe4\x93\x02#*!/api/devices/{dev_eui}/act\
    ivation\x12}\n\rGetActivation\x12\x1f.api.GetDeviceActivationRequest\x1a\
    \x20.api.GetDeviceActivationResponse\")\x82\xd3\xe4\x93\x02#\x12!/api/de\
    vices/{dev_eui}/activation\x12\x80\x01\n\x10GetRandomDevAddr\x12\x1c.api\
    .GetRandomDevAddrRequest\x1a\x1d.api.GetRandomDevAddrResponse\"/\x82\xd3\
    \xe4\x93\x02)\"'/api/devices/{dev_eui}/getRandomDevAddr\x12\x81\x01\n\
    \x0fStreamFrameLogs\x12!.api.StreamDeviceFrameLogsRequest\x1a\".api.Stre\
    amDeviceFrameLogsResponse\"%\x82\xd3\xe4\x93\x02\x1f\x12\x1d/api/devices\
    /{dev_eui}/frames0\x01\x12\x81\x01\n\x0fStreamEventLogs\x12!.api.StreamD\
    eviceEventLogsRequest\x1a\".api.StreamDeviceEventLogsResponse\"%\x82\xd3\
    \xe4\x93\x02\x1f\x12\x1d/api/devices/{dev_eui}/events0\x01B9Z7github.com\
    /brocaar/chirpstack-api/go/v3/as/external/apiJ\xa3i\n\x07\x12\x05\0\0\
    \xa4\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\
    \x08\x0b\n\x08\n\x01\x08\x12\x03\x04\0N\n\t\n\x02\x08\x0b\x12\x03\x04\0N\
    \n\t\n\x02\x03\0\x12\x03\x06\x07%\n\t\n\x02\x03\x01\x12\x03\x07\x07(\n\t\
    \n\x02\x03\x02\x12\x03\x08\x07$\n\t\n\x02\x03\x03\x12\x03\t\x07\x1c\n\t\
    \n\x02\x03\x04\x12\x03\n\x07'\nA\n\x02\x06\0\x12\x05\x0e\0\x80\x01\x01\
    \x1a4\x20DeviceService\x20is\x20the\x20service\x20managing\x20the\x20dev\
    ices.\n\n\n\n\x03\x06\0\x01\x12\x03\x0e\x08\x15\n0\n\x04\x06\0\x02\0\x12\
    \x04\x10\x04\x15\x05\x1a\"\x20Create\x20creates\x20the\x20given\x20devic\
    e.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x10\x08\x0e\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\x10\x0f\"\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x10-B\n\
    \r\n\x05\x06\0\x02\0\x04\x12\x04\x11\x08\x14\n\n\x11\n\t\x06\0\x02\0\x04\
    \xb0\xca\xbc\"\x12\x04\x11\x08\x14\n\nA\n\x04\x06\0\x02\x01\x12\x04\x18\
    \x04\x1c\x05\x1a3\x20Get\x20returns\x20the\x20device\x20matching\x20the\
    \x20given\x20DevEUI.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x18\x08\x0b\
    \n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x18\x0c\x1c\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03\x18'8\n\r\n\x05\x06\0\x02\x01\x04\x12\x04\x19\x08\x1b\n\
    \n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04\x19\x08\x1b\n\n3\n\
    \x04\x06\0\x02\x02\x12\x04\x1f\x04#\x05\x1a%\x20List\x20returns\x20the\
    \x20available\x20devices.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x1f\
    \x08\x0c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1f\r\x1e\n\x0c\n\x05\x06\
    \0\x02\x02\x03\x12\x03\x1f);\n\r\n\x05\x06\0\x02\x02\x04\x12\x04\x20\x08\
    \"\n\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04\x20\x08\"\n\nD\n\
    \x04\x06\0\x02\x03\x12\x04&\x04*\x05\x1a6\x20Delete\x20deletes\x20the\
    \x20device\x20matching\x20the\x20given\x20DevEUI.\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x03&\x08\x0e\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03&\x0f\
    \"\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03&-B\n\r\n\x05\x06\0\x02\x03\x04\
    \x12\x04'\x08)\n\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04'\x08)\
    \n\nD\n\x04\x06\0\x02\x04\x12\x04-\x042\x05\x1a6\x20Update\x20updates\
    \x20the\x20device\x20matching\x20the\x20given\x20DevEUI.\n\n\x0c\n\x05\
    \x06\0\x02\x04\x01\x12\x03-\x08\x0e\n\x0c\n\x05\x06\0\x02\x04\x02\x12\
    \x03-\x0f\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03--B\n\r\n\x05\x06\0\x02\
    \x04\x04\x12\x04.\x081\n\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\
    \x04.\x081\n\n9\n\x04\x06\0\x02\x05\x12\x045\x04:\x05\x1a+\x20CreateKeys\
    \x20creates\x20the\x20given\x20device-keys.\n\n\x0c\n\x05\x06\0\x02\x05\
    \x01\x12\x035\x08\x12\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x035\x13*\n\x0c\
    \n\x05\x06\0\x02\x05\x03\x12\x0355J\n\r\n\x05\x06\0\x02\x05\x04\x12\x046\
    \x089\n\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x046\x089\n\nE\n\
    \x04\x06\0\x02\x06\x12\x04=\x04A\x05\x1a7\x20GetKeys\x20returns\x20the\
    \x20device-keys\x20for\x20the\x20given\x20DevEUI.\n\n\x0c\n\x05\x06\0\
    \x02\x06\x01\x12\x03=\x08\x0f\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03=\x10\
    $\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03=/D\n\r\n\x05\x06\0\x02\x06\x04\
    \x12\x04>\x08@\n\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04>\x08@\
    \n\n3\n\x04\x06\0\x02\x07\x12\x04D\x04I\x05\x1a%\x20UpdateKeys\x20update\
    s\x20the\x20device-keys.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03D\x08\
    \x12\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03D\x13*\n\x0c\n\x05\x06\0\x02\
    \x07\x03\x12\x03D5J\n\r\n\x05\x06\0\x02\x07\x04\x12\x04E\x08H\n\n\x11\n\
    \t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x04E\x08H\n\nH\n\x04\x06\0\x02\
    \x08\x12\x04L\x04P\x05\x1a:\x20DeleteKeys\x20deletes\x20the\x20device-ke\
    ys\x20for\x20the\x20given\x20DevEUI.\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\
    \x03L\x08\x12\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03L\x13*\n\x0c\n\x05\
    \x06\0\x02\x08\x03\x12\x03L5J\n\r\n\x05\x06\0\x02\x08\x04\x12\x04M\x08O\
    \n\n\x11\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x04M\x08O\n\nQ\n\x04\
    \x06\0\x02\t\x12\x04S\x04X\x05\x1aC\x20Activate\x20(re)activates\x20the\
    \x20device\x20(only\x20when\x20ABP\x20is\x20set\x20to\x20true).\n\n\x0c\
    \n\x05\x06\0\x02\t\x01\x12\x03S\x08\x10\n\x0c\n\x05\x06\0\x02\t\x02\x12\
    \x03S\x11&\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03S1F\n\r\n\x05\x06\0\x02\t\
    \x04\x12\x04T\x08W\n\n\x11\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x04T\
    \x08W\n\n3\n\x04\x06\0\x02\n\x12\x04[\x04_\x05\x1a%\x20Deactivate\x20de-\
    activates\x20the\x20device.\n\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03[\x08\
    \x12\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03[\x13*\n\x0c\n\x05\x06\0\x02\n\
    \x03\x12\x03[5J\n\r\n\x05\x06\0\x02\n\x04\x12\x04\\\x08^\n\n\x11\n\t\x06\
    \0\x02\n\x04\xb0\xca\xbc\"\x12\x04\\\x08^\n\nb\n\x04\x06\0\x02\x0b\x12\
    \x04b\x04f\x05\x1aT\x20GetActivation\x20returns\x20the\x20current\x20act\
    ivation\x20details\x20of\x20the\x20device\x20(OTAA\x20and\x20ABP).\n\n\
    \x0c\n\x05\x06\0\x02\x0b\x01\x12\x03b\x08\x15\n\x0c\n\x05\x06\0\x02\x0b\
    \x02\x12\x03b\x160\n\x0c\n\x05\x06\0\x02\x0b\x03\x12\x03b;V\n\r\n\x05\
    \x06\0\x02\x0b\x04\x12\x04c\x08e\n\n\x11\n\t\x06\0\x02\x0b\x04\xb0\xca\
    \xbc\"\x12\x04c\x08e\n\n_\n\x04\x06\0\x02\x0c\x12\x04i\x04m\x05\x1aQ\x20\
    GetRandomDevAddr\x20returns\x20a\x20random\x20DevAddr\x20taking\x20the\
    \x20NwkID\x20prefix\x20into\x20account.\n\n\x0c\n\x05\x06\0\x02\x0c\x01\
    \x12\x03i\x08\x18\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03i\x190\n\x0c\n\
    \x05\x06\0\x02\x0c\x03\x12\x03i;S\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04j\
    \x08l\n\n\x11\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x04j\x08l\n\n\xee\
    \x01\n\x04\x06\0\x02\r\x12\x04r\x04v\x05\x1a\xdf\x01\x20StreamFrameLogs\
    \x20streams\x20the\x20uplink\x20and\x20downlink\x20frame-logs\x20for\x20\
    the\x20given\x20DevEUI.\n\x20\x20\x20*\x20These\x20are\x20the\x20raw\x20\
    LoRaWAN\x20frames\x20and\x20this\x20endpoint\x20is\x20intended\x20for\
    \x20debugging\x20only.\n\x20\x20\x20*\x20This\x20endpoint\x20does\x20not\
    \x20work\x20from\x20a\x20web-browser.\n\n\x0c\n\x05\x06\0\x02\r\x01\x12\
    \x03r\x08\x17\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03r\x184\n\x0c\n\x05\x06\
    \0\x02\r\x06\x12\x03r?E\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03rFc\n\r\n\x05\
    \x06\0\x02\r\x04\x12\x04s\x08u\n\n\x11\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\
    \x12\x04s\x08u\n\n\xc9\x01\n\x04\x06\0\x02\x0e\x12\x04{\x04\x7f\x05\x1a\
    \xba\x01\x20StreamEventLogs\x20stream\x20the\x20device\x20events\x20(upl\
    ink\x20payloads,\x20ACKs,\x20joins,\x20errors).\n\x20\x20\x20*\x20This\
    \x20endpoint\x20is\x20intended\x20for\x20debugging\x20only.\n\x20\x20\
    \x20*\x20This\x20endpoint\x20does\x20not\x20work\x20from\x20a\x20web-bro\
    wser.\n\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03{\x08\x17\n\x0c\n\x05\x06\0\
    \x02\x0e\x02\x12\x03{\x184\n\x0c\n\x05\x06\0\x02\x0e\x06\x12\x03{?E\n\
    \x0c\n\x05\x06\0\x02\x0e\x03\x12\x03{Fc\n\r\n\x05\x06\0\x02\x0e\x04\x12\
    \x04|\x08~\n\n\x11\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x04|\x08~\n\n\
    \x0c\n\x02\x04\0\x12\x06\x82\x01\0\xa8\x01\x01\n\x0b\n\x03\x04\0\x01\x12\
    \x04\x82\x01\x08\x0e\n)\n\x04\x04\0\x02\0\x12\x04\x84\x01\x04.\x1a\x1b\
    \x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\0\x02\0\x04\x12\
    \x06\x84\x01\x04\x82\x01\x10\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x84\x01\
    \x04\n\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x84\x01\x0b\x12\n\r\n\x05\x04\0\
    \x02\0\x03\x12\x04\x84\x01\x15\x16\n\r\n\x05\x04\0\x02\0\x08\x12\x04\x84\
    \x01\x17-\n\r\n\x05\x04\0\x02\0\n\x12\x04\x84\x01$,\nQ\n\x04\x04\0\x02\
    \x01\x12\x04\x87\x01\x04\x14\x1aC\x20Name\x20of\x20the\x20device\x20(if\
    \x20left\x20blank,\x20it\x20will\x20be\x20set\x20to\x20the\x20DevEUI).\n\
    \n\x0f\n\x05\x04\0\x02\x01\x04\x12\x06\x87\x01\x04\x84\x01.\n\r\n\x05\
    \x04\0\x02\x01\x05\x12\x04\x87\x01\x04\n\n\r\n\x05\x04\0\x02\x01\x01\x12\
    \x04\x87\x01\x0b\x0f\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x87\x01\x12\x13\
    \n\xe2\x01\n\x04\x04\0\x02\x02\x12\x04\x8d\x01\x04;\x1a\xd3\x01\x20ID\
    \x20of\x20the\x20application\x20to\x20which\x20the\x20device\x20must\x20\
    be\x20added.\n\x20It\x20is\x20possible\x20to\x20move\x20a\x20device\x20t\
    o\x20a\x20different\x20application\x20on\x20update,\n\x20given\x20that\
    \x20both\x20the\x20old\x20and\x20the\x20new\x20application\x20share\x20t\
    he\x20same\n\x20service-profile.\n\n\x0f\n\x05\x04\0\x02\x02\x04\x12\x06\
    \x8d\x01\x04\x87\x01\x14\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\x8d\x01\x04\
    \t\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x8d\x01\n\x18\n\r\n\x05\x04\0\x02\
    \x02\x03\x12\x04\x8d\x01\x1b\x1c\n\r\n\x05\x04\0\x02\x02\x08\x12\x04\x8d\
    \x01\x1d:\n\r\n\x05\x04\0\x02\x02\n\x12\x04\x8d\x01*9\n*\n\x04\x04\0\x02\
    \x03\x12\x04\x90\x01\x04\x1b\x1a\x1c\x20Description\x20of\x20the\x20devi\
    ce.\n\n\x0f\n\x05\x04\0\x02\x03\x04\x12\x06\x90\x01\x04\x8d\x01;\n\r\n\
    \x05\x04\0\x02\x03\x05\x12\x04\x90\x01\x04\n\n\r\n\x05\x04\0\x02\x03\x01\
    \x12\x04\x90\x01\x0b\x16\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\x90\x01\x19\
    \x1a\n7\n\x04\x04\0\x02\x04\x12\x04\x93\x01\x04A\x1a)\x20DeviceProfileID\
    \x20attached\x20to\x20the\x20device.\n\n\x0f\n\x05\x04\0\x02\x04\x04\x12\
    \x06\x93\x01\x04\x90\x01\x1b\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\x93\x01\
    \x04\n\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\x93\x01\x0b\x1c\n\r\n\x05\x04\
    \0\x02\x04\x03\x12\x04\x93\x01\x1f\x20\n\r\n\x05\x04\0\x02\x04\x08\x12\
    \x04\x93\x01!@\n\r\n\x05\x04\0\x02\x04\n\x12\x04\x93\x01.?\na\n\x04\x04\
    \0\x02\x05\x12\x04\x96\x01\x04\x1e\x1aS\x20Skip\x20frame-counter\x20chec\
    ks\x20(this\x20is\x20insecure,\x20but\x20could\x20be\x20helpful\x20for\
    \x20debugging).\n\n\x0f\n\x05\x04\0\x02\x05\x04\x12\x06\x96\x01\x04\x93\
    \x01A\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\x96\x01\x04\x08\n\r\n\x05\x04\
    \0\x02\x05\x01\x12\x04\x96\x01\t\x19\n\r\n\x05\x04\0\x02\x05\x03\x12\x04\
    \x96\x01\x1c\x1d\n\xb6\x01\n\x04\x04\0\x02\x06\x12\x04\x9c\x01\x04\"\x1a\
    \xa7\x01\x20Reference\x20altitude.\n\x20When\x20using\x20geolocation,\
    \x20this\x20altitude\x20will\x20be\x20used\x20as\x20a\x20reference\n\x20\
    (when\x20supported\x20by\x20the\x20geolocation-server)\x20to\x20increase\
    \x20geolocation\n\x20accuracy.\n\n\x0f\n\x05\x04\0\x02\x06\x04\x12\x06\
    \x9c\x01\x04\x96\x01\x1e\n\r\n\x05\x04\0\x02\x06\x05\x12\x04\x9c\x01\x04\
    \n\n\r\n\x05\x04\0\x02\x06\x01\x12\x04\x9c\x01\x0b\x1d\n\r\n\x05\x04\0\
    \x02\x06\x03\x12\x04\x9c\x01\x20!\n\xd9\x01\n\x04\x04\0\x02\x07\x12\x04\
    \xa2\x01\x04&\x1a\xca\x01\x20Variables\x20(user\x20defined).\n\x20These\
    \x20variables\x20can\x20be\x20used\x20together\x20with\x20integrations\
    \x20to\x20store\x20tokens\x20/\n\x20secrets\x20that\x20must\x20be\x20con\
    figured\x20per\x20device.\x20These\x20variables\x20are\x20not\n\x20expos\
    ed\x20in\x20the\x20event\x20payloads.\n\n\x0f\n\x05\x04\0\x02\x07\x04\
    \x12\x06\xa2\x01\x04\x9c\x01\"\n\r\n\x05\x04\0\x02\x07\x06\x12\x04\xa2\
    \x01\x04\x17\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xa2\x01\x18!\n\r\n\x05\
    \x04\0\x02\x07\x03\x12\x04\xa2\x01$%\n\x98\x01\n\x04\x04\0\x02\x08\x12\
    \x04\xa7\x01\x04!\x1a\x89\x01\x20Tags\x20(user\x20defined).\n\x20These\
    \x20tags\x20are\x20exposed\x20in\x20the\x20event\x20payloads\x20or\x20to\
    \x20integration.\x20Tags\x20are\n\x20intended\x20for\x20aggregation\x20a\
    nd\x20filtering.\n\n\x0f\n\x05\x04\0\x02\x08\x04\x12\x06\xa7\x01\x04\xa2\
    \x01&\n\r\n\x05\x04\0\x02\x08\x06\x12\x04\xa7\x01\x04\x17\n\r\n\x05\x04\
    \0\x02\x08\x01\x12\x04\xa7\x01\x18\x1c\n\r\n\x05\x04\0\x02\x08\x03\x12\
    \x04\xa7\x01\x1f\x20\n\x0c\n\x02\x04\x01\x12\x06\xaa\x01\0\xd5\x01\x01\n\
    \x0b\n\x03\x04\x01\x01\x12\x04\xaa\x01\x08\x16\n)\n\x04\x04\x01\x02\0\
    \x12\x04\xac\x01\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\
    \x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xac\x01\x04\xaa\x01\x18\n\r\n\x05\
    \x04\x01\x02\0\x05\x12\x04\xac\x01\x04\n\n\r\n\x05\x04\x01\x02\0\x01\x12\
    \x04\xac\x01\x0b\x12\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xac\x01\x15\x16\
    \n\r\n\x05\x04\x01\x02\0\x08\x12\x04\xac\x01\x17-\n\r\n\x05\x04\x01\x02\
    \0\n\x12\x04\xac\x01$,\n#\n\x04\x04\x01\x02\x01\x12\x04\xaf\x01\x04\x14\
    \x1a\x15\x20Name\x20of\x20the\x20device.\n\n\x0f\n\x05\x04\x01\x02\x01\
    \x04\x12\x06\xaf\x01\x04\xac\x01.\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\
    \xaf\x01\x04\n\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xaf\x01\x0b\x0f\n\r\
    \n\x05\x04\x01\x02\x01\x03\x12\x04\xaf\x01\x12\x13\n\x1f\n\x04\x04\x01\
    \x02\x02\x12\x04\xb2\x01\x04;\x1a\x11\x20Application\x20ID.\n\n\x0f\n\
    \x05\x04\x01\x02\x02\x04\x12\x06\xb2\x01\x04\xaf\x01\x14\n\r\n\x05\x04\
    \x01\x02\x02\x05\x12\x04\xb2\x01\x04\t\n\r\n\x05\x04\x01\x02\x02\x01\x12\
    \x04\xb2\x01\n\x18\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xb2\x01\x1b\x1c\
    \n\r\n\x05\x04\x01\x02\x02\x08\x12\x04\xb2\x01\x1d:\n\r\n\x05\x04\x01\
    \x02\x02\n\x12\x04\xb2\x01*9\n*\n\x04\x04\x01\x02\x03\x12\x04\xb5\x01\
    \x04\x1b\x1a\x1c\x20Description\x20of\x20the\x20device.\n\n\x0f\n\x05\
    \x04\x01\x02\x03\x04\x12\x06\xb5\x01\x04\xb2\x01;\n\r\n\x05\x04\x01\x02\
    \x03\x05\x12\x04\xb5\x01\x04\n\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\xb5\
    \x01\x0b\x16\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xb5\x01\x19\x1a\n9\n\
    \x04\x04\x01\x02\x04\x12\x04\xb8\x01\x04A\x1a+\x20Device-profile\x20ID\
    \x20attached\x20to\x20the\x20device.\n\n\x0f\n\x05\x04\x01\x02\x04\x04\
    \x12\x06\xb8\x01\x04\xb5\x01\x1b\n\r\n\x05\x04\x01\x02\x04\x05\x12\x04\
    \xb8\x01\x04\n\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xb8\x01\x0b\x1c\n\r\
    \n\x05\x04\x01\x02\x04\x03\x12\x04\xb8\x01\x1f\x20\n\r\n\x05\x04\x01\x02\
    \x04\x08\x12\x04\xb8\x01!@\n\r\n\x05\x04\x01\x02\x04\n\x12\x04\xb8\x01.?\
    \n$\n\x04\x04\x01\x02\x05\x12\x04\xbb\x01\x04#\x1a\x16\x20Device-profile\
    \x20name.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\x06\xbb\x01\x04\xb8\x01A\
    \n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\xbb\x01\x04\n\n\r\n\x05\x04\x01\
    \x02\x05\x01\x12\x04\xbb\x01\x0b\x1e\n\r\n\x05\x04\x01\x02\x05\x03\x12\
    \x04\xbb\x01!\"\n\xd1\x02\n\x04\x04\x01\x02\x06\x12\x04\xc2\x01\x04%\x1a\
    \xc2\x02\x20The\x20device\x20battery\x20status\x20(deprecated,\x20use\
    \x20device_status_battery_level).\n\x200:\x20\x20\x20\x20\x20\x20The\x20\
    end-device\x20is\x20connected\x20to\x20an\x20external\x20power\x20source\
    \n\x201..254:\x20The\x20battery\x20level,\x201\x20being\x20at\x20minimum\
    \x20and\x20254\x20being\x20at\x20maximum\n\x20255:\x20\x20\x20\x20The\
    \x20end-device\x20was\x20not\x20able\x20to\x20measure\x20the\x20battery\
    \x20level\n\x20256:\x20\x20\x20\x20The\x20device-status\x20is\x20not\x20\
    available.\n\n\x0f\n\x05\x04\x01\x02\x06\x04\x12\x06\xc2\x01\x04\xbb\x01\
    #\n\r\n\x05\x04\x01\x02\x06\x05\x12\x04\xc2\x01\x04\n\n\r\n\x05\x04\x01\
    \x02\x06\x01\x12\x04\xc2\x01\x0b\x20\n\r\n\x05\x04\x01\x02\x06\x03\x12\
    \x04\xc2\x01#$\n\x82\x01\n\x04\x04\x01\x02\x07\x12\x04\xc7\x01\x04$\x1at\
    \x20The\x20device\x20margin\x20status\n\x20-32..32:\x20The\x20demodulati\
    on\x20SNR\x20ration\x20in\x20dB\n\x20256:\x20\x20\x20\x20\x20The\x20devi\
    ce-status\x20is\x20not\x20available.\n\n\x0f\n\x05\x04\x01\x02\x07\x04\
    \x12\x06\xc7\x01\x04\xc2\x01%\n\r\n\x05\x04\x01\x02\x07\x05\x12\x04\xc7\
    \x01\x04\t\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xc7\x01\x0b\x1f\n\r\n\
    \x05\x04\x01\x02\x07\x03\x12\x04\xc7\x01\"#\n@\n\x04\x04\x01\x02\x08\x12\
    \x04\xca\x01\x042\x1a2\x20Device\x20is\x20connected\x20to\x20an\x20exter\
    nal\x20power\x20source.\n\n\x0f\n\x05\x04\x01\x02\x08\x04\x12\x06\xca\
    \x01\x04\xc7\x01$\n\r\n\x05\x04\x01\x02\x08\x05\x12\x04\xca\x01\x04\x08\
    \n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\xca\x01\t,\n\r\n\x05\x04\x01\x02\
    \x08\x03\x12\x04\xca\x01/1\n5\n\x04\x04\x01\x02\t\x12\x04\xcd\x01\x046\
    \x1a'\x20Device\x20battery\x20status\x20is\x20unavailable.\n\n\x0f\n\x05\
    \x04\x01\x02\t\x04\x12\x06\xcd\x01\x04\xca\x012\n\r\n\x05\x04\x01\x02\t\
    \x05\x12\x04\xcd\x01\x04\x08\n\r\n\x05\x04\x01\x02\t\x01\x12\x04\xcd\x01\
    \t0\n\r\n\x05\x04\x01\x02\t\x03\x12\x04\xcd\x0135\n5\n\x04\x04\x01\x02\n\
    \x12\x04\xd0\x01\x04+\x1a'\x20Device\x20battery\x20level\x20as\x20a\x20p\
    ercentage.\n\n\x0f\n\x05\x04\x01\x02\n\x04\x12\x06\xd0\x01\x04\xcd\x016\
    \n\r\n\x05\x04\x01\x02\n\x05\x12\x04\xd0\x01\x04\t\n\r\n\x05\x04\x01\x02\
    \n\x01\x12\x04\xd0\x01\n%\n\r\n\x05\x04\x01\x02\n\x03\x12\x04\xd0\x01(*\
    \n\x91\x01\n\x04\x04\x01\x02\x0b\x12\x04\xd4\x01\x04J\x1a\x82\x01\x20The\
    \x20last\x20time\x20the\x20application-server\x20received\x20any\x20data\
    \x20from\x20the\x20device,\n\x20or\x20an\x20empty\x20string\x20when\x20t\
    he\x20device\x20never\x20sent\x20any\x20data.\n\n\x0f\n\x05\x04\x01\x02\
    \x0b\x04\x12\x06\xd4\x01\x04\xd0\x01+\n\r\n\x05\x04\x01\x02\x0b\x06\x12\
    \x04\xd4\x01\x04\x1d\n\r\n\x05\x04\x01\x02\x0b\x01\x12\x04\xd4\x01\x1e*\
    \n\r\n\x05\x04\x01\x02\x0b\x03\x12\x04\xd4\x01-.\n\r\n\x05\x04\x01\x02\
    \x0b\x08\x12\x04\xd4\x01/I\n\r\n\x05\x04\x01\x02\x0b\n\x12\x04\xd4\x01<H\
    \n\x0c\n\x02\x04\x02\x12\x06\xd7\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\xd7\x01\x08\x12\n)\n\x04\x04\x02\x02\0\x12\x04\xd9\x01\x04.\
    \x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x02\x02\
    \0\x04\x12\x06\xd9\x01\x04\xd7\x01\x14\n\r\n\x05\x04\x02\x02\0\x05\x12\
    \x04\xd9\x01\x04\n\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xd9\x01\x0b\x12\n\
    \r\n\x05\x04\x02\x02\0\x03\x12\x04\xd9\x01\x15\x16\n\r\n\x05\x04\x02\x02\
    \0\x08\x12\x04\xd9\x01\x17-\n\r\n\x05\x04\x02\x02\0\n\x12\x04\xd9\x01$,\
    \nx\n\x04\x04\x02\x02\x01\x12\x04\xdd\x01\x04\x17\x1aj\x20Network\x20roo\
    t\x20key\x20(HEX\x20encoded).\n\x20Note:\x20For\x20LoRaWAN\x201.0.x,\x20\
    use\x20this\x20field\x20for\x20the\x20LoRaWAN\x201.0.x\x20'AppKey`!\n\n\
    \x0f\n\x05\x04\x02\x02\x01\x04\x12\x06\xdd\x01\x04\xd9\x01.\n\r\n\x05\
    \x04\x02\x02\x01\x05\x12\x04\xdd\x01\x04\n\n\r\n\x05\x04\x02\x02\x01\x01\
    \x12\x04\xdd\x01\x0b\x12\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xdd\x01\
    \x15\x16\nu\n\x04\x04\x02\x02\x02\x12\x04\xe1\x01\x04\x17\x1ag\x20Applic\
    ation\x20root\x20key\x20(HEX\x20encoded).\n\x20Note:\x20This\x20field\
    \x20only\x20needs\x20to\x20be\x20set\x20for\x20LoRaWAN\x201.1.x\x20devic\
    es!\n\n\x0f\n\x05\x04\x02\x02\x02\x04\x12\x06\xe1\x01\x04\xdd\x01\x17\n\
    \r\n\x05\x04\x02\x02\x02\x05\x12\x04\xe1\x01\x04\n\n\r\n\x05\x04\x02\x02\
    \x02\x01\x12\x04\xe1\x01\x0b\x12\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\
    \xe1\x01\x15\x16\n\xb6\x01\n\x04\x04\x02\x02\x03\x12\x04\xe6\x01\x04\x1b\
    \x1a\xa7\x01\x20Gen\x20application\x20key\x20(HEX\x20encoded).\n\x20This\
    \x20is\x20an\x20optional\x20key\x20that\x20only\x20must\x20be\x20set\x20\
    for\x20LORaWAN\x201.0.x\x20devices\n\x20that\x20implement\x20the\x20remo\
    te\x20multicast\x20setup\x20specification.\n\n\x0f\n\x05\x04\x02\x02\x03\
    \x04\x12\x06\xe6\x01\x04\xe1\x01\x17\n\r\n\x05\x04\x02\x02\x03\x05\x12\
    \x04\xe6\x01\x04\n\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xe6\x01\x0b\x16\
    \n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xe6\x01\x19\x1a\n\x0c\n\x02\x04\
    \x03\x12\x06\xe9\x01\0\xec\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xe9\
    \x01\x08\x1b\n(\n\x04\x04\x03\x02\0\x12\x04\xeb\x01\x04\x16\x1a\x1a\x20D\
    evice\x20object\x20to\x20create.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\
    \xeb\x01\x04\xe9\x01\x1d\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xeb\x01\x04\
    \n\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xeb\x01\x0b\x11\n\r\n\x05\x04\x03\
    \x02\0\x03\x12\x04\xeb\x01\x14\x15\n\x0c\n\x02\x04\x04\x12\x06\xee\x01\0\
    \xf1\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xee\x01\x08\x18\n)\n\x04\
    \x04\x04\x02\0\x12\x04\xf0\x01\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20\
    encoded).\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xf0\x01\x04\xee\x01\
    \x1a\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xf0\x01\x04\n\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\xf0\x01\x0b\x12\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \xf0\x01\x15\x16\n\r\n\x05\x04\x04\x02\0\x08\x12\x04\xf0\x01\x17-\n\r\n\
    \x05\x04\x04\x02\0\n\x12\x04\xf0\x01$,\n\x0c\n\x02\x04\x05\x12\x06\xf3\
    \x01\0\x8e\x02\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xf3\x01\x08\x19\n\x1e\
    \n\x04\x04\x05\x02\0\x12\x04\xf5\x01\x04\x16\x1a\x10\x20Device\x20object\
    .\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xf5\x01\x04\xf3\x01\x1b\n\r\n\
    \x05\x04\x05\x02\0\x06\x12\x04\xf5\x01\x04\n\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\xf5\x01\x0b\x11\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xf5\x01\x14\
    \x15\nS\n\x04\x04\x05\x02\x01\x12\x04\xfc\x01\x04J\x1a\x16\x20Last\x20se\
    en\x20timestamp.\n2-\x20Created\x20at\x202\n\x20Updated\x20at\x203\n\x20\
    First\x20seen\x20at\x204\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\xfc\
    \x01\x04\xf5\x01\x16\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\xfc\x01\x04\
    \x1d\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xfc\x01\x1e*\n\r\n\x05\x04\
    \x05\x02\x01\x03\x12\x04\xfc\x01-.\n\r\n\x05\x04\x05\x02\x01\x08\x12\x04\
    \xfc\x01/I\n\r\n\x05\x04\x05\x02\x01\n\x12\x04\xfc\x01<H\n\xa2\x02\n\x04\
    \x04\x05\x02\x02\x12\x04\x83\x02\x04%\x1a\x93\x02\x20The\x20device\x20ba\
    ttery\x20status\n\x200:\x20\x20\x20\x20\x20\x20The\x20end-device\x20is\
    \x20connected\x20to\x20an\x20external\x20power\x20source\n\x201..254:\
    \x20The\x20battery\x20level,\x201\x20being\x20at\x20minimum\x20and\x2025\
    4\x20being\x20at\x20maximum\n\x20255:\x20\x20\x20\x20The\x20end-device\
    \x20was\x20not\x20able\x20to\x20measure\x20the\x20battery\x20level\n\x20\
    256:\x20\x20\x20\x20The\x20device-status\x20is\x20not\x20available.\n\n\
    \x0f\n\x05\x04\x05\x02\x02\x04\x12\x06\x83\x02\x04\xfc\x01J\n\r\n\x05\
    \x04\x05\x02\x02\x05\x12\x04\x83\x02\x04\n\n\r\n\x05\x04\x05\x02\x02\x01\
    \x12\x04\x83\x02\x0b\x20\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x83\x02#$\
    \n\x82\x01\n\x04\x04\x05\x02\x03\x12\x04\x88\x02\x04%\x1at\x20The\x20dev\
    ice\x20margin\x20status\n\x20-32..32:\x20The\x20demodulation\x20SNR\x20r\
    ation\x20in\x20dB\n\x20256:\x20\x20\x20\x20\x20The\x20device-status\x20i\
    s\x20not\x20available.\n\n\x0f\n\x05\x04\x05\x02\x03\x04\x12\x06\x88\x02\
    \x04\x83\x02%\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\x88\x02\x04\t\n\r\n\
    \x05\x04\x05\x02\x03\x01\x12\x04\x88\x02\x0b\x1f\n\r\n\x05\x04\x05\x02\
    \x03\x03\x12\x04\x88\x02\"$\n\x87\x01\n\x04\x04\x05\x02\x04\x12\x04\x8d\
    \x02\x04\"\x1ay\x20Device\x20location.\n\x20This\x20will\x20set\x20when\
    \x20the\x20network-server\x20was\x20able\x20to\x20resolve\x20the\x20loca\
    tion\n\x20using\x20the\x20geolocation-server.\n\n\x0f\n\x05\x04\x05\x02\
    \x04\x04\x12\x06\x8d\x02\x04\x88\x02%\n\r\n\x05\x04\x05\x02\x04\x06\x12\
    \x04\x8d\x02\x04\x13\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x8d\x02\x14\
    \x1c\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x8d\x02\x1f!\n\x0c\n\x02\x04\
    \x06\x12\x06\x90\x02\0\xa2\x02\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x90\
    \x02\x08\x19\nB\n\x04\x04\x06\x02\0\x12\x04\x92\x02\x04\x14\x1a4\x20Max\
    \x20number\x20of\x20devices\x20to\x20return\x20in\x20the\x20result-set.\
    \n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\x92\x02\x04\x90\x02\x1b\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\x92\x02\x04\t\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\x92\x02\n\x0f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x92\x02\x12\
    \x13\n:\n\x04\x04\x06\x02\x01\x12\x04\x95\x02\x04\x15\x1a,\x20Offset\x20\
    in\x20the\x20result-set\x20(for\x20pagination).\n\n\x0f\n\x05\x04\x06\
    \x02\x01\x04\x12\x06\x95\x02\x04\x92\x02\x14\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\x95\x02\x04\t\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x95\x02\
    \n\x10\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x95\x02\x13\x14\n,\n\x04\
    \x04\x06\x02\x02\x12\x04\x98\x02\x04;\x1a\x1e\x20Application\x20ID\x20to\
    \x20filter\x20on.\n\n\x0f\n\x05\x04\x06\x02\x02\x04\x12\x06\x98\x02\x04\
    \x95\x02\x15\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\x98\x02\x04\t\n\r\n\
    \x05\x04\x06\x02\x02\x01\x12\x04\x98\x02\n\x18\n\r\n\x05\x04\x06\x02\x02\
    \x03\x12\x04\x98\x02\x1b\x1c\n\r\n\x05\x04\x06\x02\x02\x08\x12\x04\x98\
    \x02\x1d:\n\r\n\x05\x04\x06\x02\x02\n\x12\x04\x98\x02*9\n)\n\x04\x04\x06\
    \x02\x03\x12\x04\x9b\x02\x04\x16\x1a\x1b\x20Search\x20on\x20name\x20or\
    \x20DevEUI.\n\n\x0f\n\x05\x04\x06\x02\x03\x04\x12\x06\x9b\x02\x04\x98\
    \x02;\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\x9b\x02\x04\n\n\r\n\x05\x04\
    \x06\x02\x03\x01\x12\x04\x9b\x02\x0b\x11\n\r\n\x05\x04\x06\x02\x03\x03\
    \x12\x04\x9b\x02\x14\x15\nH\n\x04\x04\x06\x02\x04\x12\x04\x9e\x02\x04C\
    \x1a:\x20Multicast-group\x20ID\x20to\x20filter\x20on\x20(string\x20forma\
    tted\x20UUID).\n\n\x0f\n\x05\x04\x06\x02\x04\x04\x12\x06\x9e\x02\x04\x9b\
    \x02\x16\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\x9e\x02\x04\n\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\x9e\x02\x0b\x1d\n\r\n\x05\x04\x06\x02\x04\
    \x03\x12\x04\x9e\x02\x20!\n\r\n\x05\x04\x06\x02\x04\x08\x12\x04\x9e\x02\
    \"B\n\r\n\x05\x04\x06\x02\x04\n\x12\x04\x9e\x02/A\nH\n\x04\x04\x06\x02\
    \x05\x12\x04\xa1\x02\x04C\x1a:\x20Service-profile\x20ID\x20to\x20filter\
    \x20on\x20(string\x20formatted\x20UUID).\n\n\x0f\n\x05\x04\x06\x02\x05\
    \x04\x12\x06\xa1\x02\x04\x9e\x02C\n\r\n\x05\x04\x06\x02\x05\x05\x12\x04\
    \xa1\x02\x04\n\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xa1\x02\x0b\x1d\n\r\
    \n\x05\x04\x06\x02\x05\x03\x12\x04\xa1\x02\x20!\n\r\n\x05\x04\x06\x02\
    \x05\x08\x12\x04\xa1\x02\"B\n\r\n\x05\x04\x06\x02\x05\n\x12\x04\xa1\x02/\
    A\n\x0c\n\x02\x04\x07\x12\x06\xa4\x02\0\xaa\x02\x01\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xa4\x02\x08\x1a\nH\n\x04\x04\x07\x02\0\x12\x04\xa6\x02\x04\
    \x1a\x1a:\x20Total\x20number\x20of\x20devices\x20available\x20within\x20\
    the\x20result-set.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xa6\x02\x04\
    \xa4\x02\x1c\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xa6\x02\x04\t\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xa6\x02\n\x15\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xa6\x02\x18\x19\n/\n\x04\x04\x07\x02\x01\x12\x04\xa9\x02\x04'\x1a!\
    \x20Devices\x20within\x20this\x20result-set.\n\n\r\n\x05\x04\x07\x02\x01\
    \x04\x12\x04\xa9\x02\x04\x0c\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xa9\
    \x02\r\x1b\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xa9\x02\x1c\"\n\r\n\x05\
    \x04\x07\x02\x01\x03\x12\x04\xa9\x02%&\n\x0c\n\x02\x04\x08\x12\x06\xac\
    \x02\0\xaf\x02\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xac\x02\x08\x1b\n)\n\
    \x04\x04\x08\x02\0\x12\x04\xae\x02\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\
    \x20encoded).\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xae\x02\x04\xac\
    \x02\x1d\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xae\x02\x04\n\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xae\x02\x0b\x12\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xae\x02\x15\x16\n\r\n\x05\x04\x08\x02\0\x08\x12\x04\xae\x02\x17-\n\
    \r\n\x05\x04\x08\x02\0\n\x12\x04\xae\x02$,\n\x0c\n\x02\x04\t\x12\x06\xb2\
    \x02\0\xb5\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xb2\x02\x08\x1b\n(\n\
    \x04\x04\t\x02\0\x12\x04\xb4\x02\x04\x16\x1a\x1a\x20Device\x20object\x20\
    to\x20update.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xb4\x02\x04\xb2\x02\
    \x1d\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xb4\x02\x04\n\n\r\n\x05\x04\t\x02\
    \0\x01\x12\x04\xb4\x02\x0b\x11\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xb4\x02\
    \x14\x15\n\x0c\n\x02\x04\n\x12\x06\xb7\x02\0\xba\x02\x01\n\x0b\n\x03\x04\
    \n\x01\x12\x04\xb7\x02\x08\x1f\n-\n\x04\x04\n\x02\0\x12\x04\xb9\x02\x04\
    \x1f\x1a\x1f\x20Device-keys\x20object\x20to\x20create.\n\n\x0f\n\x05\x04\
    \n\x02\0\x04\x12\x06\xb9\x02\x04\xb7\x02!\n\r\n\x05\x04\n\x02\0\x06\x12\
    \x04\xb9\x02\x04\x0e\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xb9\x02\x0f\x1a\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\xb9\x02\x1d\x1e\n\x0c\n\x02\x04\x0b\x12\
    \x06\xbc\x02\0\xbf\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xbc\x02\x08\
    \x1c\n)\n\x04\x04\x0b\x02\0\x12\x04\xbe\x02\x04.\x1a\x1b\x20Device\x20EU\
    I\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xbe\x02\
    \x04\xbc\x02\x1e\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xbe\x02\x04\n\n\r\n\
    \x05\x04\x0b\x02\0\x01\x12\x04\xbe\x02\x0b\x12\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\xbe\x02\x15\x16\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\xbe\x02\
    \x17-\n\r\n\x05\x04\x0b\x02\0\n\x12\x04\xbe\x02$,\n\x0c\n\x02\x04\x0c\
    \x12\x06\xc1\x02\0\xc4\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xc1\x02\
    \x08\x1d\n\"\n\x04\x04\x0c\x02\0\x12\x04\xc3\x02\x04\x1f\x1a\x14\x20Devi\
    ce-key\x20object.\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xc3\x02\x04\
    \xc1\x02\x1f\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xc3\x02\x04\x0e\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\xc3\x02\x0f\x1a\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xc3\x02\x1d\x1e\n\x0c\n\x02\x04\r\x12\x06\xc6\x02\0\xc9\x02\
    \x01\n\x0b\n\x03\x04\r\x01\x12\x04\xc6\x02\x08\x1f\n-\n\x04\x04\r\x02\0\
    \x12\x04\xc8\x02\x04\x1f\x1a\x1f\x20Device-keys\x20object\x20to\x20updat\
    e.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xc8\x02\x04\xc6\x02!\n\r\n\x05\
    \x04\r\x02\0\x06\x12\x04\xc8\x02\x04\x0e\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\xc8\x02\x0f\x1a\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc8\x02\x1d\x1e\n\
    \x0c\n\x02\x04\x0e\x12\x06\xcb\x02\0\xce\x02\x01\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xcb\x02\x08\x1f\n)\n\x04\x04\x0e\x02\0\x12\x04\xcd\x02\x04.\x1a\
    \x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x0e\x02\0\
    \x04\x12\x06\xcd\x02\x04\xcb\x02!\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\
    \xcd\x02\x04\n\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xcd\x02\x0b\x12\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\xcd\x02\x15\x16\n\r\n\x05\x04\x0e\x02\0\
    \x08\x12\x04\xcd\x02\x17-\n\r\n\x05\x04\x0e\x02\0\n\x12\x04\xcd\x02$,\n\
    \x0c\n\x02\x04\x0f\x12\x06\xd0\x02\0\xeb\x02\x01\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xd0\x02\x08\x18\n)\n\x04\x04\x0f\x02\0\x12\x04\xd2\x02\x04.\x1a\
    \x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x0f\x02\0\
    \x04\x12\x06\xd2\x02\x04\xd0\x02\x1a\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\
    \xd2\x02\x04\n\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd2\x02\x0b\x12\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\xd2\x02\x15\x16\n\r\n\x05\x04\x0f\x02\0\
    \x08\x12\x04\xd2\x02\x17-\n\r\n\x05\x04\x0f\x02\0\n\x12\x04\xd2\x02$,\n-\
    \n\x04\x04\x0f\x02\x01\x12\x04\xd5\x02\x04\x18\x1a\x1f\x20Device\x20addr\
    ess\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\xd5\
    \x02\x04\xd2\x02.\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xd5\x02\x04\n\n\
    \r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xd5\x02\x0b\x13\n\r\n\x05\x04\x0f\
    \x02\x01\x03\x12\x04\xd5\x02\x16\x17\n6\n\x04\x04\x0f\x02\x02\x12\x04\
    \xd8\x02\x04\x19\x1a(\x20Application\x20session\x20key\x20(HEX\x20encode\
    d).\n\n\x0f\n\x05\x04\x0f\x02\x02\x04\x12\x06\xd8\x02\x04\xd5\x02\x18\n\
    \r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xd8\x02\x04\n\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\xd8\x02\x0b\x14\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\
    \xd8\x02\x17\x18\n=\n\x04\x04\x0f\x02\x03\x12\x04\xdb\x02\x04\x1d\x1a/\
    \x20Network\x20session\x20encryption\x20key\x20(HEX\x20encoded).\n\n\x0f\
    \n\x05\x04\x0f\x02\x03\x04\x12\x06\xdb\x02\x04\xd8\x02\x19\n\r\n\x05\x04\
    \x0f\x02\x03\x05\x12\x04\xdb\x02\x04\n\n\r\n\x05\x04\x0f\x02\x03\x01\x12\
    \x04\xdb\x02\x0b\x18\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xdb\x02\x1b\
    \x1c\nD\n\x04\x04\x0f\x02\x04\x12\x04\xde\x02\x04\x1f\x1a6\x20Serving\
    \x20network\x20session\x20integrity\x20key\x20(HEX\x20encoded).\n\n\x0f\
    \n\x05\x04\x0f\x02\x04\x04\x12\x06\xde\x02\x04\xdb\x02\x1d\n\r\n\x05\x04\
    \x0f\x02\x04\x05\x12\x04\xde\x02\x04\n\n\r\n\x05\x04\x0f\x02\x04\x01\x12\
    \x04\xde\x02\x0b\x1a\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xde\x02\x1d\
    \x1e\nG\n\x04\x04\x0f\x02\x05\x12\x04\xe1\x02\x04\x1f\x1a9\x20Forwarding\
    \x20network\x20session\x20integrity\x20key\x20(HEX\x20encoded).\n\n\x0f\
    \n\x05\x04\x0f\x02\x05\x04\x12\x06\xe1\x02\x04\xde\x02\x1f\n\r\n\x05\x04\
    \x0f\x02\x05\x05\x12\x04\xe1\x02\x04\n\n\r\n\x05\x04\x0f\x02\x05\x01\x12\
    \x04\xe1\x02\x0b\x1a\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xe1\x02\x1d\
    \x1e\n%\n\x04\x04\x0f\x02\x06\x12\x04\xe4\x02\x04\x18\x1a\x17\x20Uplink\
    \x20frame-counter.\n\n\x0f\n\x05\x04\x0f\x02\x06\x04\x12\x06\xe4\x02\x04\
    \xe1\x02\x1f\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\xe4\x02\x04\n\n\r\n\
    \x05\x04\x0f\x02\x06\x01\x12\x04\xe4\x02\x0b\x13\n\r\n\x05\x04\x0f\x02\
    \x06\x03\x12\x04\xe4\x02\x16\x17\n/\n\x04\x04\x0f\x02\x07\x12\x04\xe7\
    \x02\x04\x1c\x1a!\x20Downlink\x20network\x20frame-counter.\n\n\x0f\n\x05\
    \x04\x0f\x02\x07\x04\x12\x06\xe7\x02\x04\xe4\x02\x18\n\r\n\x05\x04\x0f\
    \x02\x07\x05\x12\x04\xe7\x02\x04\n\n\r\n\x05\x04\x0f\x02\x07\x01\x12\x04\
    \xe7\x02\x0b\x17\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xe7\x02\x1a\x1b\n\
    3\n\x04\x04\x0f\x02\x08\x12\x04\xea\x02\x04\x1d\x1a%\x20Downlink\x20appl\
    ication\x20frame-counter.\n\n\x0f\n\x05\x04\x0f\x02\x08\x04\x12\x06\xea\
    \x02\x04\xe7\x02\x1c\n\r\n\x05\x04\x0f\x02\x08\x05\x12\x04\xea\x02\x04\n\
    \n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\xea\x02\x0b\x17\n\r\n\x05\x04\x0f\
    \x02\x08\x03\x12\x04\xea\x02\x1a\x1c\n\x0c\n\x02\x04\x10\x12\x06\xed\x02\
    \0\xef\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xed\x02\x08\x1d\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xee\x02\x04+\n\x0f\n\x05\x04\x10\x02\0\x04\
    \x12\x06\xee\x02\x04\xed\x02\x1f\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xee\
    \x02\x04\x14\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xee\x02\x15&\n\r\n\x05\
    \x04\x10\x02\0\x03\x12\x04\xee\x02)*\n\x0c\n\x02\x04\x11\x12\x06\xf1\x02\
    \0\xf4\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xf1\x02\x08\x1f\n)\n\x04\
    \x04\x11\x02\0\x12\x04\xf3\x02\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20\
    encoded).\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xf3\x02\x04\xf1\x02!\n\
    \r\n\x05\x04\x11\x02\0\x05\x12\x04\xf3\x02\x04\n\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xf3\x02\x0b\x12\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xf3\x02\
    \x15\x16\n\r\n\x05\x04\x11\x02\0\x08\x12\x04\xf3\x02\x17-\n\r\n\x05\x04\
    \x11\x02\0\n\x12\x04\xf3\x02$,\n\x0c\n\x02\x04\x12\x12\x06\xf6\x02\0\xf9\
    \x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xf6\x02\x08\"\n)\n\x04\x04\x12\
    \x02\0\x12\x04\xf8\x02\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded)\
    .\n\n\x0f\n\x05\x04\x12\x02\0\x04\x12\x06\xf8\x02\x04\xf6\x02$\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\xf8\x02\x04\n\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\xf8\x02\x0b\x12\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf8\x02\x15\x16\
    \n\r\n\x05\x04\x12\x02\0\x08\x12\x04\xf8\x02\x17-\n\r\n\x05\x04\x12\x02\
    \0\n\x12\x04\xf8\x02$,\n\x0c\n\x02\x04\x13\x12\x06\xfb\x02\0\xfe\x02\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xfb\x02\x08#\n)\n\x04\x04\x13\x02\0\x12\
    \x04\xfd\x02\x04+\x1a\x1b\x20Device-activation\x20object.\n\n\x0f\n\x05\
    \x04\x13\x02\0\x04\x12\x06\xfd\x02\x04\xfb\x02%\n\r\n\x05\x04\x13\x02\0\
    \x06\x12\x04\xfd\x02\x04\x14\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xfd\x02\
    \x15&\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xfd\x02)*\n\x0c\n\x02\x04\x14\
    \x12\x06\x80\x03\0\x83\x03\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\x80\x03\
    \x08\x1f\n)\n\x04\x04\x14\x02\0\x12\x04\x82\x03\x04.\x1a\x1b\x20Device\
    \x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\x82\
    \x03\x04\x80\x03!\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x82\x03\x04\n\n\r\
    \n\x05\x04\x14\x02\0\x01\x12\x04\x82\x03\x0b\x12\n\r\n\x05\x04\x14\x02\0\
    \x03\x12\x04\x82\x03\x15\x16\n\r\n\x05\x04\x14\x02\0\x08\x12\x04\x82\x03\
    \x17-\n\r\n\x05\x04\x14\x02\0\n\x12\x04\x82\x03$,\n\x0c\n\x02\x04\x15\
    \x12\x06\x85\x03\0\x88\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x85\x03\
    \x08\x20\n-\n\x04\x04\x15\x02\0\x12\x04\x87\x03\x04\x18\x1a\x1f\x20Devic\
    e\x20address\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\
    \x06\x87\x03\x04\x85\x03\"\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x87\x03\
    \x04\n\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x87\x03\x0b\x13\n\r\n\x05\x04\
    \x15\x02\0\x03\x12\x04\x87\x03\x16\x17\n\x0c\n\x02\x04\x16\x12\x06\x8a\
    \x03\0\x8d\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x8a\x03\x08$\n)\n\x04\
    \x04\x16\x02\0\x12\x04\x8c\x03\x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20\
    encoded).\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\x8c\x03\x04\x8a\x03&\n\
    \r\n\x05\x04\x16\x02\0\x05\x12\x04\x8c\x03\x04\n\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\x8c\x03\x0b\x12\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x8c\x03\
    \x15\x16\n\r\n\x05\x04\x16\x02\0\x08\x12\x04\x8c\x03\x17-\n\r\n\x05\x04\
    \x16\x02\0\n\x12\x04\x8c\x03$,\n\x0c\n\x02\x04\x17\x12\x06\x8f\x03\0\x97\
    \x03\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x8f\x03\x08%\n\x0e\n\x04\x04\
    \x17\x08\0\x12\x06\x90\x03\x04\x96\x03\x05\n\r\n\x05\x04\x17\x08\0\x01\
    \x12\x04\x90\x03\n\x0f\n)\n\x04\x04\x17\x02\0\x12\x04\x92\x03\x08(\x1a\
    \x1b\x20Contains\x20an\x20uplink\x20frame.\n\n\r\n\x05\x04\x17\x02\0\x06\
    \x12\x04\x92\x03\x08\x16\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x92\x03\x17\
    #\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x92\x03&'\n*\n\x04\x04\x17\x02\x01\
    \x12\x04\x95\x03\x08,\x1a\x1c\x20Contains\x20a\x20downlink\x20frame.\n\n\
    \r\n\x05\x04\x17\x02\x01\x06\x12\x04\x95\x03\x08\x18\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\x95\x03\x19'\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \x95\x03*+\n\x0c\n\x02\x04\x18\x12\x06\x99\x03\0\x9c\x03\x01\n\x0b\n\x03\
    \x04\x18\x01\x12\x04\x99\x03\x08$\n)\n\x04\x04\x18\x02\0\x12\x04\x9b\x03\
    \x04.\x1a\x1b\x20Device\x20EUI\x20(HEX\x20encoded).\n\n\x0f\n\x05\x04\
    \x18\x02\0\x04\x12\x06\x9b\x03\x04\x99\x03&\n\r\n\x05\x04\x18\x02\0\x05\
    \x12\x04\x9b\x03\x04\n\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x9b\x03\x0b\
    \x12\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x9b\x03\x15\x16\n\r\n\x05\x04\
    \x18\x02\0\x08\x12\x04\x9b\x03\x17-\n\r\n\x05\x04\x18\x02\0\n\x12\x04\
    \x9b\x03$,\n\x0c\n\x02\x04\x19\x12\x06\x9e\x03\0\xa4\x03\x01\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\x9e\x03\x08%\n\x1f\n\x04\x04\x19\x02\0\x12\x04\xa0\
    \x03\x04\x14\x1a\x11\x20The\x20event\x20type.\n\n\x0f\n\x05\x04\x19\x02\
    \0\x04\x12\x06\xa0\x03\x04\x9e\x03'\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\
    \xa0\x03\x04\n\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xa0\x03\x0b\x0f\n\r\n\
    \x05\x04\x19\x02\0\x03\x12\x04\xa0\x03\x12\x13\n3\n\x04\x04\x19\x02\x01\
    \x12\x04\xa3\x03\x048\x1a%\x20The\x20event\x20payload\x20in\x20JSON\x20e\
    ncoding.\n\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\xa3\x03\x04\xa0\x03\
    \x14\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xa3\x03\x04\n\n\r\n\x05\x04\
    \x19\x02\x01\x01\x12\x04\xa3\x03\x0b\x17\n\r\n\x05\x04\x19\x02\x01\x03\
    \x12\x04\xa3\x03\x1a\x1b\n\r\n\x05\x04\x19\x02\x01\x08\x12\x04\xa3\x03\
    \x1c7\n\r\n\x05\x04\x19\x02\x01\n\x12\x04\xa3\x03)6b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
