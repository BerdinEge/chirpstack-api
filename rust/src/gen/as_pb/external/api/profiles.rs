// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `as/external/api/profiles.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct ServiceProfile {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub organization_id: i64,
    pub network_server_id: i64,
    pub ul_rate: u32,
    pub ul_bucket_size: u32,
    pub ul_rate_policy: RatePolicy,
    pub dl_rate: u32,
    pub dl_bucket_size: u32,
    pub dl_rate_policy: RatePolicy,
    pub add_gw_metadata: bool,
    pub dev_status_req_freq: u32,
    pub report_dev_status_battery: bool,
    pub report_dev_status_margin: bool,
    pub dr_min: u32,
    pub dr_max: u32,
    pub channel_mask: ::std::vec::Vec<u8>,
    pub pr_allowed: bool,
    pub hr_allowed: bool,
    pub ra_allowed: bool,
    pub nwk_geo_loc: bool,
    pub target_per: u32,
    pub min_gw_diversity: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceProfile {
    fn default() -> &'a ServiceProfile {
        <ServiceProfile as ::protobuf::Message>::default_instance()
    }
}

impl ServiceProfile {
    pub fn new() -> ServiceProfile {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 21;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 organization_id = 22;


    pub fn get_organization_id(&self) -> i64 {
        self.organization_id
    }
    pub fn clear_organization_id(&mut self) {
        self.organization_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: i64) {
        self.organization_id = v;
    }

    // int64 network_server_id = 23;


    pub fn get_network_server_id(&self) -> i64 {
        self.network_server_id
    }
    pub fn clear_network_server_id(&mut self) {
        self.network_server_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_server_id(&mut self, v: i64) {
        self.network_server_id = v;
    }

    // uint32 ul_rate = 2;


    pub fn get_ul_rate(&self) -> u32 {
        self.ul_rate
    }
    pub fn clear_ul_rate(&mut self) {
        self.ul_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ul_rate(&mut self, v: u32) {
        self.ul_rate = v;
    }

    // uint32 ul_bucket_size = 3;


    pub fn get_ul_bucket_size(&self) -> u32 {
        self.ul_bucket_size
    }
    pub fn clear_ul_bucket_size(&mut self) {
        self.ul_bucket_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_ul_bucket_size(&mut self, v: u32) {
        self.ul_bucket_size = v;
    }

    // .api.RatePolicy ul_rate_policy = 4;


    pub fn get_ul_rate_policy(&self) -> RatePolicy {
        self.ul_rate_policy
    }
    pub fn clear_ul_rate_policy(&mut self) {
        self.ul_rate_policy = RatePolicy::DROP;
    }

    // Param is passed by value, moved
    pub fn set_ul_rate_policy(&mut self, v: RatePolicy) {
        self.ul_rate_policy = v;
    }

    // uint32 dl_rate = 5;


    pub fn get_dl_rate(&self) -> u32 {
        self.dl_rate
    }
    pub fn clear_dl_rate(&mut self) {
        self.dl_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_dl_rate(&mut self, v: u32) {
        self.dl_rate = v;
    }

    // uint32 dl_bucket_size = 6;


    pub fn get_dl_bucket_size(&self) -> u32 {
        self.dl_bucket_size
    }
    pub fn clear_dl_bucket_size(&mut self) {
        self.dl_bucket_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_dl_bucket_size(&mut self, v: u32) {
        self.dl_bucket_size = v;
    }

    // .api.RatePolicy dl_rate_policy = 7;


    pub fn get_dl_rate_policy(&self) -> RatePolicy {
        self.dl_rate_policy
    }
    pub fn clear_dl_rate_policy(&mut self) {
        self.dl_rate_policy = RatePolicy::DROP;
    }

    // Param is passed by value, moved
    pub fn set_dl_rate_policy(&mut self, v: RatePolicy) {
        self.dl_rate_policy = v;
    }

    // bool add_gw_metadata = 8;


    pub fn get_add_gw_metadata(&self) -> bool {
        self.add_gw_metadata
    }
    pub fn clear_add_gw_metadata(&mut self) {
        self.add_gw_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_add_gw_metadata(&mut self, v: bool) {
        self.add_gw_metadata = v;
    }

    // uint32 dev_status_req_freq = 9;


    pub fn get_dev_status_req_freq(&self) -> u32 {
        self.dev_status_req_freq
    }
    pub fn clear_dev_status_req_freq(&mut self) {
        self.dev_status_req_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_dev_status_req_freq(&mut self, v: u32) {
        self.dev_status_req_freq = v;
    }

    // bool report_dev_status_battery = 10;


    pub fn get_report_dev_status_battery(&self) -> bool {
        self.report_dev_status_battery
    }
    pub fn clear_report_dev_status_battery(&mut self) {
        self.report_dev_status_battery = false;
    }

    // Param is passed by value, moved
    pub fn set_report_dev_status_battery(&mut self, v: bool) {
        self.report_dev_status_battery = v;
    }

    // bool report_dev_status_margin = 11;


    pub fn get_report_dev_status_margin(&self) -> bool {
        self.report_dev_status_margin
    }
    pub fn clear_report_dev_status_margin(&mut self) {
        self.report_dev_status_margin = false;
    }

    // Param is passed by value, moved
    pub fn set_report_dev_status_margin(&mut self, v: bool) {
        self.report_dev_status_margin = v;
    }

    // uint32 dr_min = 12;


    pub fn get_dr_min(&self) -> u32 {
        self.dr_min
    }
    pub fn clear_dr_min(&mut self) {
        self.dr_min = 0;
    }

    // Param is passed by value, moved
    pub fn set_dr_min(&mut self, v: u32) {
        self.dr_min = v;
    }

    // uint32 dr_max = 13;


    pub fn get_dr_max(&self) -> u32 {
        self.dr_max
    }
    pub fn clear_dr_max(&mut self) {
        self.dr_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_dr_max(&mut self, v: u32) {
        self.dr_max = v;
    }

    // bytes channel_mask = 14;


    pub fn get_channel_mask(&self) -> &[u8] {
        &self.channel_mask
    }
    pub fn clear_channel_mask(&mut self) {
        self.channel_mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.channel_mask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.channel_mask
    }

    // Take field
    pub fn take_channel_mask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.channel_mask, ::std::vec::Vec::new())
    }

    // bool pr_allowed = 15;


    pub fn get_pr_allowed(&self) -> bool {
        self.pr_allowed
    }
    pub fn clear_pr_allowed(&mut self) {
        self.pr_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_pr_allowed(&mut self, v: bool) {
        self.pr_allowed = v;
    }

    // bool hr_allowed = 16;


    pub fn get_hr_allowed(&self) -> bool {
        self.hr_allowed
    }
    pub fn clear_hr_allowed(&mut self) {
        self.hr_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_hr_allowed(&mut self, v: bool) {
        self.hr_allowed = v;
    }

    // bool ra_allowed = 17;


    pub fn get_ra_allowed(&self) -> bool {
        self.ra_allowed
    }
    pub fn clear_ra_allowed(&mut self) {
        self.ra_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_ra_allowed(&mut self, v: bool) {
        self.ra_allowed = v;
    }

    // bool nwk_geo_loc = 18;


    pub fn get_nwk_geo_loc(&self) -> bool {
        self.nwk_geo_loc
    }
    pub fn clear_nwk_geo_loc(&mut self) {
        self.nwk_geo_loc = false;
    }

    // Param is passed by value, moved
    pub fn set_nwk_geo_loc(&mut self, v: bool) {
        self.nwk_geo_loc = v;
    }

    // uint32 target_per = 19;


    pub fn get_target_per(&self) -> u32 {
        self.target_per
    }
    pub fn clear_target_per(&mut self) {
        self.target_per = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_per(&mut self, v: u32) {
        self.target_per = v;
    }

    // uint32 min_gw_diversity = 20;


    pub fn get_min_gw_diversity(&self) -> u32 {
        self.min_gw_diversity
    }
    pub fn clear_min_gw_diversity(&mut self) {
        self.min_gw_diversity = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_gw_diversity(&mut self, v: u32) {
        self.min_gw_diversity = v;
    }
}

impl ::protobuf::Message for ServiceProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.organization_id = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.network_server_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ul_rate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ul_bucket_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ul_rate_policy, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dl_rate = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dl_bucket_size = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dl_rate_policy, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.add_gw_metadata = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dev_status_req_freq = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_dev_status_battery = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_dev_status_margin = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dr_min = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dr_max = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.channel_mask)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pr_allowed = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hr_allowed = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ra_allowed = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nwk_geo_loc = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_per = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_gw_diversity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.name);
        }
        if self.organization_id != 0 {
            my_size += ::protobuf::rt::value_size(22, self.organization_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.network_server_id != 0 {
            my_size += ::protobuf::rt::value_size(23, self.network_server_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ul_rate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ul_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ul_bucket_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ul_bucket_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ul_rate_policy != RatePolicy::DROP {
            my_size += ::protobuf::rt::enum_size(4, self.ul_rate_policy);
        }
        if self.dl_rate != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dl_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dl_bucket_size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.dl_bucket_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dl_rate_policy != RatePolicy::DROP {
            my_size += ::protobuf::rt::enum_size(7, self.dl_rate_policy);
        }
        if self.add_gw_metadata != false {
            my_size += 2;
        }
        if self.dev_status_req_freq != 0 {
            my_size += ::protobuf::rt::value_size(9, self.dev_status_req_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.report_dev_status_battery != false {
            my_size += 2;
        }
        if self.report_dev_status_margin != false {
            my_size += 2;
        }
        if self.dr_min != 0 {
            my_size += ::protobuf::rt::value_size(12, self.dr_min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dr_max != 0 {
            my_size += ::protobuf::rt::value_size(13, self.dr_max, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.channel_mask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.channel_mask);
        }
        if self.pr_allowed != false {
            my_size += 2;
        }
        if self.hr_allowed != false {
            my_size += 3;
        }
        if self.ra_allowed != false {
            my_size += 3;
        }
        if self.nwk_geo_loc != false {
            my_size += 3;
        }
        if self.target_per != 0 {
            my_size += ::protobuf::rt::value_size(19, self.target_per, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_gw_diversity != 0 {
            my_size += ::protobuf::rt::value_size(20, self.min_gw_diversity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(21, &self.name)?;
        }
        if self.organization_id != 0 {
            os.write_int64(22, self.organization_id)?;
        }
        if self.network_server_id != 0 {
            os.write_int64(23, self.network_server_id)?;
        }
        if self.ul_rate != 0 {
            os.write_uint32(2, self.ul_rate)?;
        }
        if self.ul_bucket_size != 0 {
            os.write_uint32(3, self.ul_bucket_size)?;
        }
        if self.ul_rate_policy != RatePolicy::DROP {
            os.write_enum(4, self.ul_rate_policy.value())?;
        }
        if self.dl_rate != 0 {
            os.write_uint32(5, self.dl_rate)?;
        }
        if self.dl_bucket_size != 0 {
            os.write_uint32(6, self.dl_bucket_size)?;
        }
        if self.dl_rate_policy != RatePolicy::DROP {
            os.write_enum(7, self.dl_rate_policy.value())?;
        }
        if self.add_gw_metadata != false {
            os.write_bool(8, self.add_gw_metadata)?;
        }
        if self.dev_status_req_freq != 0 {
            os.write_uint32(9, self.dev_status_req_freq)?;
        }
        if self.report_dev_status_battery != false {
            os.write_bool(10, self.report_dev_status_battery)?;
        }
        if self.report_dev_status_margin != false {
            os.write_bool(11, self.report_dev_status_margin)?;
        }
        if self.dr_min != 0 {
            os.write_uint32(12, self.dr_min)?;
        }
        if self.dr_max != 0 {
            os.write_uint32(13, self.dr_max)?;
        }
        if !self.channel_mask.is_empty() {
            os.write_bytes(14, &self.channel_mask)?;
        }
        if self.pr_allowed != false {
            os.write_bool(15, self.pr_allowed)?;
        }
        if self.hr_allowed != false {
            os.write_bool(16, self.hr_allowed)?;
        }
        if self.ra_allowed != false {
            os.write_bool(17, self.ra_allowed)?;
        }
        if self.nwk_geo_loc != false {
            os.write_bool(18, self.nwk_geo_loc)?;
        }
        if self.target_per != 0 {
            os.write_uint32(19, self.target_per)?;
        }
        if self.min_gw_diversity != 0 {
            os.write_uint32(20, self.min_gw_diversity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceProfile {
        ServiceProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &ServiceProfile| { &m.id },
                    |m: &mut ServiceProfile| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ServiceProfile| { &m.name },
                    |m: &mut ServiceProfile| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "organization_id",
                    |m: &ServiceProfile| { &m.organization_id },
                    |m: &mut ServiceProfile| { &mut m.organization_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "network_server_id",
                    |m: &ServiceProfile| { &m.network_server_id },
                    |m: &mut ServiceProfile| { &mut m.network_server_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ul_rate",
                    |m: &ServiceProfile| { &m.ul_rate },
                    |m: &mut ServiceProfile| { &mut m.ul_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ul_bucket_size",
                    |m: &ServiceProfile| { &m.ul_bucket_size },
                    |m: &mut ServiceProfile| { &mut m.ul_bucket_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RatePolicy>>(
                    "ul_rate_policy",
                    |m: &ServiceProfile| { &m.ul_rate_policy },
                    |m: &mut ServiceProfile| { &mut m.ul_rate_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dl_rate",
                    |m: &ServiceProfile| { &m.dl_rate },
                    |m: &mut ServiceProfile| { &mut m.dl_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dl_bucket_size",
                    |m: &ServiceProfile| { &m.dl_bucket_size },
                    |m: &mut ServiceProfile| { &mut m.dl_bucket_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RatePolicy>>(
                    "dl_rate_policy",
                    |m: &ServiceProfile| { &m.dl_rate_policy },
                    |m: &mut ServiceProfile| { &mut m.dl_rate_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "add_gw_metadata",
                    |m: &ServiceProfile| { &m.add_gw_metadata },
                    |m: &mut ServiceProfile| { &mut m.add_gw_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dev_status_req_freq",
                    |m: &ServiceProfile| { &m.dev_status_req_freq },
                    |m: &mut ServiceProfile| { &mut m.dev_status_req_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_dev_status_battery",
                    |m: &ServiceProfile| { &m.report_dev_status_battery },
                    |m: &mut ServiceProfile| { &mut m.report_dev_status_battery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_dev_status_margin",
                    |m: &ServiceProfile| { &m.report_dev_status_margin },
                    |m: &mut ServiceProfile| { &mut m.report_dev_status_margin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dr_min",
                    |m: &ServiceProfile| { &m.dr_min },
                    |m: &mut ServiceProfile| { &mut m.dr_min },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dr_max",
                    |m: &ServiceProfile| { &m.dr_max },
                    |m: &mut ServiceProfile| { &mut m.dr_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "channel_mask",
                    |m: &ServiceProfile| { &m.channel_mask },
                    |m: &mut ServiceProfile| { &mut m.channel_mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pr_allowed",
                    |m: &ServiceProfile| { &m.pr_allowed },
                    |m: &mut ServiceProfile| { &mut m.pr_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hr_allowed",
                    |m: &ServiceProfile| { &m.hr_allowed },
                    |m: &mut ServiceProfile| { &mut m.hr_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ra_allowed",
                    |m: &ServiceProfile| { &m.ra_allowed },
                    |m: &mut ServiceProfile| { &mut m.ra_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "nwk_geo_loc",
                    |m: &ServiceProfile| { &m.nwk_geo_loc },
                    |m: &mut ServiceProfile| { &mut m.nwk_geo_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_per",
                    |m: &ServiceProfile| { &m.target_per },
                    |m: &mut ServiceProfile| { &mut m.target_per },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "min_gw_diversity",
                    |m: &ServiceProfile| { &m.min_gw_diversity },
                    |m: &mut ServiceProfile| { &mut m.min_gw_diversity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceProfile>(
                    "ServiceProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceProfile {
        static mut instance: ::protobuf::lazy::Lazy<ServiceProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceProfile,
        };
        unsafe {
            instance.get(ServiceProfile::new)
        }
    }
}

impl ::protobuf::Clear for ServiceProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.organization_id = 0;
        self.network_server_id = 0;
        self.ul_rate = 0;
        self.ul_bucket_size = 0;
        self.ul_rate_policy = RatePolicy::DROP;
        self.dl_rate = 0;
        self.dl_bucket_size = 0;
        self.dl_rate_policy = RatePolicy::DROP;
        self.add_gw_metadata = false;
        self.dev_status_req_freq = 0;
        self.report_dev_status_battery = false;
        self.report_dev_status_margin = false;
        self.dr_min = 0;
        self.dr_max = 0;
        self.channel_mask.clear();
        self.pr_allowed = false;
        self.hr_allowed = false;
        self.ra_allowed = false;
        self.nwk_geo_loc = false;
        self.target_per = 0;
        self.min_gw_diversity = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceProfile {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub organization_id: i64,
    pub network_server_id: i64,
    pub supports_class_b: bool,
    pub class_b_timeout: u32,
    pub ping_slot_period: u32,
    pub ping_slot_dr: u32,
    pub ping_slot_freq: u32,
    pub supports_class_c: bool,
    pub class_c_timeout: u32,
    pub mac_version: ::std::string::String,
    pub reg_params_revision: ::std::string::String,
    pub rx_delay_1: u32,
    pub rx_dr_offset_1: u32,
    pub rx_datarate_2: u32,
    pub rx_freq_2: u32,
    pub factory_preset_freqs: ::std::vec::Vec<u32>,
    pub max_eirp: u32,
    pub max_duty_cycle: u32,
    pub supports_join: bool,
    pub rf_region: ::std::string::String,
    pub supports_32bit_f_cnt: bool,
    pub payload_codec: ::std::string::String,
    pub payload_encoder_script: ::std::string::String,
    pub payload_decoder_script: ::std::string::String,
    pub geoloc_buffer_ttl: u32,
    pub geoloc_min_buffer_size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceProfile {
    fn default() -> &'a DeviceProfile {
        <DeviceProfile as ::protobuf::Message>::default_instance()
    }
}

impl DeviceProfile {
    pub fn new() -> DeviceProfile {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 21;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 organization_id = 22;


    pub fn get_organization_id(&self) -> i64 {
        self.organization_id
    }
    pub fn clear_organization_id(&mut self) {
        self.organization_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: i64) {
        self.organization_id = v;
    }

    // int64 network_server_id = 23;


    pub fn get_network_server_id(&self) -> i64 {
        self.network_server_id
    }
    pub fn clear_network_server_id(&mut self) {
        self.network_server_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_network_server_id(&mut self, v: i64) {
        self.network_server_id = v;
    }

    // bool supports_class_b = 2;


    pub fn get_supports_class_b(&self) -> bool {
        self.supports_class_b
    }
    pub fn clear_supports_class_b(&mut self) {
        self.supports_class_b = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_class_b(&mut self, v: bool) {
        self.supports_class_b = v;
    }

    // uint32 class_b_timeout = 3;


    pub fn get_class_b_timeout(&self) -> u32 {
        self.class_b_timeout
    }
    pub fn clear_class_b_timeout(&mut self) {
        self.class_b_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_class_b_timeout(&mut self, v: u32) {
        self.class_b_timeout = v;
    }

    // uint32 ping_slot_period = 4;


    pub fn get_ping_slot_period(&self) -> u32 {
        self.ping_slot_period
    }
    pub fn clear_ping_slot_period(&mut self) {
        self.ping_slot_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_period(&mut self, v: u32) {
        self.ping_slot_period = v;
    }

    // uint32 ping_slot_dr = 5;


    pub fn get_ping_slot_dr(&self) -> u32 {
        self.ping_slot_dr
    }
    pub fn clear_ping_slot_dr(&mut self) {
        self.ping_slot_dr = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_dr(&mut self, v: u32) {
        self.ping_slot_dr = v;
    }

    // uint32 ping_slot_freq = 6;


    pub fn get_ping_slot_freq(&self) -> u32 {
        self.ping_slot_freq
    }
    pub fn clear_ping_slot_freq(&mut self) {
        self.ping_slot_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_freq(&mut self, v: u32) {
        self.ping_slot_freq = v;
    }

    // bool supports_class_c = 7;


    pub fn get_supports_class_c(&self) -> bool {
        self.supports_class_c
    }
    pub fn clear_supports_class_c(&mut self) {
        self.supports_class_c = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_class_c(&mut self, v: bool) {
        self.supports_class_c = v;
    }

    // uint32 class_c_timeout = 8;


    pub fn get_class_c_timeout(&self) -> u32 {
        self.class_c_timeout
    }
    pub fn clear_class_c_timeout(&mut self) {
        self.class_c_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_class_c_timeout(&mut self, v: u32) {
        self.class_c_timeout = v;
    }

    // string mac_version = 9;


    pub fn get_mac_version(&self) -> &str {
        &self.mac_version
    }
    pub fn clear_mac_version(&mut self) {
        self.mac_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_version(&mut self, v: ::std::string::String) {
        self.mac_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_version(&mut self) -> &mut ::std::string::String {
        &mut self.mac_version
    }

    // Take field
    pub fn take_mac_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_version, ::std::string::String::new())
    }

    // string reg_params_revision = 10;


    pub fn get_reg_params_revision(&self) -> &str {
        &self.reg_params_revision
    }
    pub fn clear_reg_params_revision(&mut self) {
        self.reg_params_revision.clear();
    }

    // Param is passed by value, moved
    pub fn set_reg_params_revision(&mut self, v: ::std::string::String) {
        self.reg_params_revision = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reg_params_revision(&mut self) -> &mut ::std::string::String {
        &mut self.reg_params_revision
    }

    // Take field
    pub fn take_reg_params_revision(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reg_params_revision, ::std::string::String::new())
    }

    // uint32 rx_delay_1 = 11;


    pub fn get_rx_delay_1(&self) -> u32 {
        self.rx_delay_1
    }
    pub fn clear_rx_delay_1(&mut self) {
        self.rx_delay_1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_delay_1(&mut self, v: u32) {
        self.rx_delay_1 = v;
    }

    // uint32 rx_dr_offset_1 = 12;


    pub fn get_rx_dr_offset_1(&self) -> u32 {
        self.rx_dr_offset_1
    }
    pub fn clear_rx_dr_offset_1(&mut self) {
        self.rx_dr_offset_1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dr_offset_1(&mut self, v: u32) {
        self.rx_dr_offset_1 = v;
    }

    // uint32 rx_datarate_2 = 13;


    pub fn get_rx_datarate_2(&self) -> u32 {
        self.rx_datarate_2
    }
    pub fn clear_rx_datarate_2(&mut self) {
        self.rx_datarate_2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_datarate_2(&mut self, v: u32) {
        self.rx_datarate_2 = v;
    }

    // uint32 rx_freq_2 = 14;


    pub fn get_rx_freq_2(&self) -> u32 {
        self.rx_freq_2
    }
    pub fn clear_rx_freq_2(&mut self) {
        self.rx_freq_2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_freq_2(&mut self, v: u32) {
        self.rx_freq_2 = v;
    }

    // repeated uint32 factory_preset_freqs = 15;


    pub fn get_factory_preset_freqs(&self) -> &[u32] {
        &self.factory_preset_freqs
    }
    pub fn clear_factory_preset_freqs(&mut self) {
        self.factory_preset_freqs.clear();
    }

    // Param is passed by value, moved
    pub fn set_factory_preset_freqs(&mut self, v: ::std::vec::Vec<u32>) {
        self.factory_preset_freqs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_factory_preset_freqs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.factory_preset_freqs
    }

    // Take field
    pub fn take_factory_preset_freqs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.factory_preset_freqs, ::std::vec::Vec::new())
    }

    // uint32 max_eirp = 16;


    pub fn get_max_eirp(&self) -> u32 {
        self.max_eirp
    }
    pub fn clear_max_eirp(&mut self) {
        self.max_eirp = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_eirp(&mut self, v: u32) {
        self.max_eirp = v;
    }

    // uint32 max_duty_cycle = 17;


    pub fn get_max_duty_cycle(&self) -> u32 {
        self.max_duty_cycle
    }
    pub fn clear_max_duty_cycle(&mut self) {
        self.max_duty_cycle = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_duty_cycle(&mut self, v: u32) {
        self.max_duty_cycle = v;
    }

    // bool supports_join = 18;


    pub fn get_supports_join(&self) -> bool {
        self.supports_join
    }
    pub fn clear_supports_join(&mut self) {
        self.supports_join = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_join(&mut self, v: bool) {
        self.supports_join = v;
    }

    // string rf_region = 19;


    pub fn get_rf_region(&self) -> &str {
        &self.rf_region
    }
    pub fn clear_rf_region(&mut self) {
        self.rf_region.clear();
    }

    // Param is passed by value, moved
    pub fn set_rf_region(&mut self, v: ::std::string::String) {
        self.rf_region = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rf_region(&mut self) -> &mut ::std::string::String {
        &mut self.rf_region
    }

    // Take field
    pub fn take_rf_region(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rf_region, ::std::string::String::new())
    }

    // bool supports_32bit_f_cnt = 20;


    pub fn get_supports_32bit_f_cnt(&self) -> bool {
        self.supports_32bit_f_cnt
    }
    pub fn clear_supports_32bit_f_cnt(&mut self) {
        self.supports_32bit_f_cnt = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_32bit_f_cnt(&mut self, v: bool) {
        self.supports_32bit_f_cnt = v;
    }

    // string payload_codec = 24;


    pub fn get_payload_codec(&self) -> &str {
        &self.payload_codec
    }
    pub fn clear_payload_codec(&mut self) {
        self.payload_codec.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_codec(&mut self, v: ::std::string::String) {
        self.payload_codec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_codec(&mut self) -> &mut ::std::string::String {
        &mut self.payload_codec
    }

    // Take field
    pub fn take_payload_codec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_codec, ::std::string::String::new())
    }

    // string payload_encoder_script = 25;


    pub fn get_payload_encoder_script(&self) -> &str {
        &self.payload_encoder_script
    }
    pub fn clear_payload_encoder_script(&mut self) {
        self.payload_encoder_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_encoder_script(&mut self, v: ::std::string::String) {
        self.payload_encoder_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_encoder_script(&mut self) -> &mut ::std::string::String {
        &mut self.payload_encoder_script
    }

    // Take field
    pub fn take_payload_encoder_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_encoder_script, ::std::string::String::new())
    }

    // string payload_decoder_script = 26;


    pub fn get_payload_decoder_script(&self) -> &str {
        &self.payload_decoder_script
    }
    pub fn clear_payload_decoder_script(&mut self) {
        self.payload_decoder_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_decoder_script(&mut self, v: ::std::string::String) {
        self.payload_decoder_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_decoder_script(&mut self) -> &mut ::std::string::String {
        &mut self.payload_decoder_script
    }

    // Take field
    pub fn take_payload_decoder_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_decoder_script, ::std::string::String::new())
    }

    // uint32 geoloc_buffer_ttl = 27;


    pub fn get_geoloc_buffer_ttl(&self) -> u32 {
        self.geoloc_buffer_ttl
    }
    pub fn clear_geoloc_buffer_ttl(&mut self) {
        self.geoloc_buffer_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_geoloc_buffer_ttl(&mut self, v: u32) {
        self.geoloc_buffer_ttl = v;
    }

    // uint32 geoloc_min_buffer_size = 28;


    pub fn get_geoloc_min_buffer_size(&self) -> u32 {
        self.geoloc_min_buffer_size
    }
    pub fn clear_geoloc_min_buffer_size(&mut self) {
        self.geoloc_min_buffer_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_geoloc_min_buffer_size(&mut self, v: u32) {
        self.geoloc_min_buffer_size = v;
    }
}

impl ::protobuf::Message for DeviceProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.organization_id = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.network_server_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_class_b = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_b_timeout = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_period = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_dr = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_freq = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_class_c = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_c_timeout = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_version)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reg_params_revision)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_delay_1 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_dr_offset_1 = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_datarate_2 = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_freq_2 = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.factory_preset_freqs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_eirp = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_duty_cycle = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_join = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rf_region)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_32bit_f_cnt = tmp;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_codec)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_encoder_script)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_decoder_script)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.geoloc_buffer_ttl = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.geoloc_min_buffer_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.name);
        }
        if self.organization_id != 0 {
            my_size += ::protobuf::rt::value_size(22, self.organization_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.network_server_id != 0 {
            my_size += ::protobuf::rt::value_size(23, self.network_server_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supports_class_b != false {
            my_size += 2;
        }
        if self.class_b_timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.class_b_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_period != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ping_slot_period, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_dr != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ping_slot_dr, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_freq != 0 {
            my_size += ::protobuf::rt::value_size(6, self.ping_slot_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supports_class_c != false {
            my_size += 2;
        }
        if self.class_c_timeout != 0 {
            my_size += ::protobuf::rt::value_size(8, self.class_c_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mac_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.mac_version);
        }
        if !self.reg_params_revision.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.reg_params_revision);
        }
        if self.rx_delay_1 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.rx_delay_1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_dr_offset_1 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.rx_dr_offset_1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_datarate_2 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.rx_datarate_2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_freq_2 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.rx_freq_2, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.factory_preset_freqs {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.max_eirp != 0 {
            my_size += ::protobuf::rt::value_size(16, self.max_eirp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_duty_cycle != 0 {
            my_size += ::protobuf::rt::value_size(17, self.max_duty_cycle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supports_join != false {
            my_size += 3;
        }
        if !self.rf_region.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.rf_region);
        }
        if self.supports_32bit_f_cnt != false {
            my_size += 3;
        }
        if !self.payload_codec.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.payload_codec);
        }
        if !self.payload_encoder_script.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.payload_encoder_script);
        }
        if !self.payload_decoder_script.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.payload_decoder_script);
        }
        if self.geoloc_buffer_ttl != 0 {
            my_size += ::protobuf::rt::value_size(27, self.geoloc_buffer_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.geoloc_min_buffer_size != 0 {
            my_size += ::protobuf::rt::value_size(28, self.geoloc_min_buffer_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(21, &self.name)?;
        }
        if self.organization_id != 0 {
            os.write_int64(22, self.organization_id)?;
        }
        if self.network_server_id != 0 {
            os.write_int64(23, self.network_server_id)?;
        }
        if self.supports_class_b != false {
            os.write_bool(2, self.supports_class_b)?;
        }
        if self.class_b_timeout != 0 {
            os.write_uint32(3, self.class_b_timeout)?;
        }
        if self.ping_slot_period != 0 {
            os.write_uint32(4, self.ping_slot_period)?;
        }
        if self.ping_slot_dr != 0 {
            os.write_uint32(5, self.ping_slot_dr)?;
        }
        if self.ping_slot_freq != 0 {
            os.write_uint32(6, self.ping_slot_freq)?;
        }
        if self.supports_class_c != false {
            os.write_bool(7, self.supports_class_c)?;
        }
        if self.class_c_timeout != 0 {
            os.write_uint32(8, self.class_c_timeout)?;
        }
        if !self.mac_version.is_empty() {
            os.write_string(9, &self.mac_version)?;
        }
        if !self.reg_params_revision.is_empty() {
            os.write_string(10, &self.reg_params_revision)?;
        }
        if self.rx_delay_1 != 0 {
            os.write_uint32(11, self.rx_delay_1)?;
        }
        if self.rx_dr_offset_1 != 0 {
            os.write_uint32(12, self.rx_dr_offset_1)?;
        }
        if self.rx_datarate_2 != 0 {
            os.write_uint32(13, self.rx_datarate_2)?;
        }
        if self.rx_freq_2 != 0 {
            os.write_uint32(14, self.rx_freq_2)?;
        }
        for v in &self.factory_preset_freqs {
            os.write_uint32(15, *v)?;
        };
        if self.max_eirp != 0 {
            os.write_uint32(16, self.max_eirp)?;
        }
        if self.max_duty_cycle != 0 {
            os.write_uint32(17, self.max_duty_cycle)?;
        }
        if self.supports_join != false {
            os.write_bool(18, self.supports_join)?;
        }
        if !self.rf_region.is_empty() {
            os.write_string(19, &self.rf_region)?;
        }
        if self.supports_32bit_f_cnt != false {
            os.write_bool(20, self.supports_32bit_f_cnt)?;
        }
        if !self.payload_codec.is_empty() {
            os.write_string(24, &self.payload_codec)?;
        }
        if !self.payload_encoder_script.is_empty() {
            os.write_string(25, &self.payload_encoder_script)?;
        }
        if !self.payload_decoder_script.is_empty() {
            os.write_string(26, &self.payload_decoder_script)?;
        }
        if self.geoloc_buffer_ttl != 0 {
            os.write_uint32(27, self.geoloc_buffer_ttl)?;
        }
        if self.geoloc_min_buffer_size != 0 {
            os.write_uint32(28, self.geoloc_min_buffer_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceProfile {
        DeviceProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &DeviceProfile| { &m.id },
                    |m: &mut DeviceProfile| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeviceProfile| { &m.name },
                    |m: &mut DeviceProfile| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "organization_id",
                    |m: &DeviceProfile| { &m.organization_id },
                    |m: &mut DeviceProfile| { &mut m.organization_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "network_server_id",
                    |m: &DeviceProfile| { &m.network_server_id },
                    |m: &mut DeviceProfile| { &mut m.network_server_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_class_b",
                    |m: &DeviceProfile| { &m.supports_class_b },
                    |m: &mut DeviceProfile| { &mut m.supports_class_b },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "class_b_timeout",
                    |m: &DeviceProfile| { &m.class_b_timeout },
                    |m: &mut DeviceProfile| { &mut m.class_b_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_period",
                    |m: &DeviceProfile| { &m.ping_slot_period },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_dr",
                    |m: &DeviceProfile| { &m.ping_slot_dr },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_dr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_freq",
                    |m: &DeviceProfile| { &m.ping_slot_freq },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_class_c",
                    |m: &DeviceProfile| { &m.supports_class_c },
                    |m: &mut DeviceProfile| { &mut m.supports_class_c },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "class_c_timeout",
                    |m: &DeviceProfile| { &m.class_c_timeout },
                    |m: &mut DeviceProfile| { &mut m.class_c_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mac_version",
                    |m: &DeviceProfile| { &m.mac_version },
                    |m: &mut DeviceProfile| { &mut m.mac_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reg_params_revision",
                    |m: &DeviceProfile| { &m.reg_params_revision },
                    |m: &mut DeviceProfile| { &mut m.reg_params_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_delay_1",
                    |m: &DeviceProfile| { &m.rx_delay_1 },
                    |m: &mut DeviceProfile| { &mut m.rx_delay_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_dr_offset_1",
                    |m: &DeviceProfile| { &m.rx_dr_offset_1 },
                    |m: &mut DeviceProfile| { &mut m.rx_dr_offset_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_datarate_2",
                    |m: &DeviceProfile| { &m.rx_datarate_2 },
                    |m: &mut DeviceProfile| { &mut m.rx_datarate_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_freq_2",
                    |m: &DeviceProfile| { &m.rx_freq_2 },
                    |m: &mut DeviceProfile| { &mut m.rx_freq_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "factory_preset_freqs",
                    |m: &DeviceProfile| { &m.factory_preset_freqs },
                    |m: &mut DeviceProfile| { &mut m.factory_preset_freqs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_eirp",
                    |m: &DeviceProfile| { &m.max_eirp },
                    |m: &mut DeviceProfile| { &mut m.max_eirp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_duty_cycle",
                    |m: &DeviceProfile| { &m.max_duty_cycle },
                    |m: &mut DeviceProfile| { &mut m.max_duty_cycle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_join",
                    |m: &DeviceProfile| { &m.supports_join },
                    |m: &mut DeviceProfile| { &mut m.supports_join },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rf_region",
                    |m: &DeviceProfile| { &m.rf_region },
                    |m: &mut DeviceProfile| { &mut m.rf_region },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_32bit_f_cnt",
                    |m: &DeviceProfile| { &m.supports_32bit_f_cnt },
                    |m: &mut DeviceProfile| { &mut m.supports_32bit_f_cnt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_codec",
                    |m: &DeviceProfile| { &m.payload_codec },
                    |m: &mut DeviceProfile| { &mut m.payload_codec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_encoder_script",
                    |m: &DeviceProfile| { &m.payload_encoder_script },
                    |m: &mut DeviceProfile| { &mut m.payload_encoder_script },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_decoder_script",
                    |m: &DeviceProfile| { &m.payload_decoder_script },
                    |m: &mut DeviceProfile| { &mut m.payload_decoder_script },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "geoloc_buffer_ttl",
                    |m: &DeviceProfile| { &m.geoloc_buffer_ttl },
                    |m: &mut DeviceProfile| { &mut m.geoloc_buffer_ttl },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "geoloc_min_buffer_size",
                    |m: &DeviceProfile| { &m.geoloc_min_buffer_size },
                    |m: &mut DeviceProfile| { &mut m.geoloc_min_buffer_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceProfile>(
                    "DeviceProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceProfile {
        static mut instance: ::protobuf::lazy::Lazy<DeviceProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceProfile,
        };
        unsafe {
            instance.get(DeviceProfile::new)
        }
    }
}

impl ::protobuf::Clear for DeviceProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.organization_id = 0;
        self.network_server_id = 0;
        self.supports_class_b = false;
        self.class_b_timeout = 0;
        self.ping_slot_period = 0;
        self.ping_slot_dr = 0;
        self.ping_slot_freq = 0;
        self.supports_class_c = false;
        self.class_c_timeout = 0;
        self.mac_version.clear();
        self.reg_params_revision.clear();
        self.rx_delay_1 = 0;
        self.rx_dr_offset_1 = 0;
        self.rx_datarate_2 = 0;
        self.rx_freq_2 = 0;
        self.factory_preset_freqs.clear();
        self.max_eirp = 0;
        self.max_duty_cycle = 0;
        self.supports_join = false;
        self.rf_region.clear();
        self.supports_32bit_f_cnt = false;
        self.payload_codec.clear();
        self.payload_encoder_script.clear();
        self.payload_decoder_script.clear();
        self.geoloc_buffer_ttl = 0;
        self.geoloc_min_buffer_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RatePolicy {
    DROP = 0,
    MARK = 1,
}

impl ::protobuf::ProtobufEnum for RatePolicy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RatePolicy> {
        match value {
            0 => ::std::option::Option::Some(RatePolicy::DROP),
            1 => ::std::option::Option::Some(RatePolicy::MARK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RatePolicy] = &[
            RatePolicy::DROP,
            RatePolicy::MARK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RatePolicy", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RatePolicy {
}

impl ::std::default::Default for RatePolicy {
    fn default() -> Self {
        RatePolicy::DROP
    }
}

impl ::protobuf::reflect::ProtobufValue for RatePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1eas/external/api/profiles.proto\x12\x03api\"\xd7\x06\n\x0eServicePr\
    ofile\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\
    \x15\x20\x01(\tR\x04name\x12'\n\x0forganization_id\x18\x16\x20\x01(\x03R\
    \x0eorganizationID\x12*\n\x11network_server_id\x18\x17\x20\x01(\x03R\x0f\
    networkServerID\x12\x17\n\x07ul_rate\x18\x02\x20\x01(\rR\x06ulRate\x12$\
    \n\x0eul_bucket_size\x18\x03\x20\x01(\rR\x0culBucketSize\x125\n\x0eul_ra\
    te_policy\x18\x04\x20\x01(\x0e2\x0f.api.RatePolicyR\x0culRatePolicy\x12\
    \x17\n\x07dl_rate\x18\x05\x20\x01(\rR\x06dlRate\x12$\n\x0edl_bucket_size\
    \x18\x06\x20\x01(\rR\x0cdlBucketSize\x125\n\x0edl_rate_policy\x18\x07\
    \x20\x01(\x0e2\x0f.api.RatePolicyR\x0cdlRatePolicy\x12&\n\x0fadd_gw_meta\
    data\x18\x08\x20\x01(\x08R\raddGWMetaData\x12-\n\x13dev_status_req_freq\
    \x18\t\x20\x01(\rR\x10devStatusReqFreq\x129\n\x19report_dev_status_batte\
    ry\x18\n\x20\x01(\x08R\x16reportDevStatusBattery\x127\n\x18report_dev_st\
    atus_margin\x18\x0b\x20\x01(\x08R\x15reportDevStatusMargin\x12\x15\n\x06\
    dr_min\x18\x0c\x20\x01(\rR\x05drMin\x12\x15\n\x06dr_max\x18\r\x20\x01(\r\
    R\x05drMax\x12!\n\x0cchannel_mask\x18\x0e\x20\x01(\x0cR\x0bchannelMask\
    \x12\x1d\n\npr_allowed\x18\x0f\x20\x01(\x08R\tprAllowed\x12\x1d\n\nhr_al\
    lowed\x18\x10\x20\x01(\x08R\thrAllowed\x12\x1d\n\nra_allowed\x18\x11\x20\
    \x01(\x08R\traAllowed\x12\x1e\n\x0bnwk_geo_loc\x18\x12\x20\x01(\x08R\tnw\
    kGeoLoc\x12\x1d\n\ntarget_per\x18\x13\x20\x01(\rR\ttargetPER\x12(\n\x10m\
    in_gw_diversity\x18\x14\x20\x01(\rR\x0eminGWDiversity\"\xca\x08\n\rDevic\
    eProfile\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\
    \x15\x20\x01(\tR\x04name\x12'\n\x0forganization_id\x18\x16\x20\x01(\x03R\
    \x0eorganizationID\x12*\n\x11network_server_id\x18\x17\x20\x01(\x03R\x0f\
    networkServerID\x12(\n\x10supports_class_b\x18\x02\x20\x01(\x08R\x0esupp\
    ortsClassB\x12&\n\x0fclass_b_timeout\x18\x03\x20\x01(\rR\rclassBTimeout\
    \x12(\n\x10ping_slot_period\x18\x04\x20\x01(\rR\x0epingSlotPeriod\x12\
    \x20\n\x0cping_slot_dr\x18\x05\x20\x01(\rR\npingSlotDR\x12$\n\x0eping_sl\
    ot_freq\x18\x06\x20\x01(\rR\x0cpingSlotFreq\x12(\n\x10supports_class_c\
    \x18\x07\x20\x01(\x08R\x0esupportsClassC\x12&\n\x0fclass_c_timeout\x18\
    \x08\x20\x01(\rR\rclassCTimeout\x12\x1f\n\x0bmac_version\x18\t\x20\x01(\
    \tR\nmacVersion\x12.\n\x13reg_params_revision\x18\n\x20\x01(\tR\x11regPa\
    ramsRevision\x12\x1c\n\nrx_delay_1\x18\x0b\x20\x01(\rR\x08rxDelay1\x12#\
    \n\x0erx_dr_offset_1\x18\x0c\x20\x01(\rR\x0brxDROffset1\x12\"\n\rrx_data\
    rate_2\x18\r\x20\x01(\rR\x0brxDataRate2\x12\x1a\n\trx_freq_2\x18\x0e\x20\
    \x01(\rR\x07rxFreq2\x120\n\x14factory_preset_freqs\x18\x0f\x20\x03(\rR\
    \x12factoryPresetFreqs\x12\x19\n\x08max_eirp\x18\x10\x20\x01(\rR\x07maxE\
    IRP\x12$\n\x0emax_duty_cycle\x18\x11\x20\x01(\rR\x0cmaxDutyCycle\x12#\n\
    \rsupports_join\x18\x12\x20\x01(\x08R\x0csupportsJoin\x12\x1b\n\trf_regi\
    on\x18\x13\x20\x01(\tR\x08rfRegion\x12/\n\x14supports_32bit_f_cnt\x18\
    \x14\x20\x01(\x08R\x11supports32BitFCnt\x12#\n\rpayload_codec\x18\x18\
    \x20\x01(\tR\x0cpayloadCodec\x124\n\x16payload_encoder_script\x18\x19\
    \x20\x01(\tR\x14payloadEncoderScript\x124\n\x16payload_decoder_script\
    \x18\x1a\x20\x01(\tR\x14payloadDecoderScript\x12*\n\x11geoloc_buffer_ttl\
    \x18\x1b\x20\x01(\rR\x0fgeolocBufferTTL\x123\n\x16geoloc_min_buffer_size\
    \x18\x1c\x20\x01(\rR\x13geolocMinBufferSize*\x20\n\nRatePolicy\x12\x08\n\
    \x04DROP\x10\0\x12\x08\n\x04MARK\x10\x01B9Z7github.com/brocaar/chirpstac\
    k-api/go/v3/as/external/apiJ\xe87\n\x07\x12\x05\0\0\xb5\x01\x01\n\x08\n\
    \x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0b\n\x08\n\x01\
    \x08\x12\x03\x04\0N\n\t\n\x02\x08\x0b\x12\x03\x04\0N\n\n\n\x02\x05\0\x12\
    \x04\x07\0\r\x01\n\n\n\x03\x05\0\x01\x12\x03\x07\x05\x0f\n\x13\n\x04\x05\
    \0\x02\0\x12\x03\t\x04\r\x1a\x06\x20Drop\n\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\t\x04\x08\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\x0b\x0c\n\x13\n\
    \x04\x05\0\x02\x01\x12\x03\x0c\x04\r\x1a\x06\x20Mark\n\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x0c\x04\x08\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\
    \x0c\x0b\x0c\n\n\n\x02\x04\0\x12\x04\x0f\0V\x01\n\n\n\x03\x04\0\x01\x12\
    \x03\x0f\x08\x16\n[\n\x04\x04\0\x02\0\x12\x03\x12\x04\x12\x1aN\x20Servic\
    e-profile\x20ID\x20(UUID\x20string).\n\x20This\x20will\x20be\x20automati\
    cally\x20set\x20on\x20create.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x12\
    \x04\x0f\x18\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x12\x04\n\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03\x12\x0b\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\
    \x12\x10\x11\n$\n\x04\x04\0\x02\x01\x12\x03\x15\x04\x15\x1a\x17\x20Servi\
    ce-profile\x20name.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x15\x04\x12\
    \x12\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x15\x04\n\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03\x15\x0b\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x15\x12\x14\nH\n\x04\x04\0\x02\x02\x12\x03\x18\x04>\x1a;\x20Organizatio\
    n\x20ID\x20to\x20which\x20the\x20service-profile\x20is\x20assigned.\n\n\
    \r\n\x05\x04\0\x02\x02\x04\x12\x04\x18\x04\x15\x15\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03\x18\x04\t\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x18\n\
    \x19\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x18\x1c\x1e\n\x0c\n\x05\x04\0\
    \x02\x02\x08\x12\x03\x18\x1f=\n\x0c\n\x05\x04\0\x02\x02\n\x12\x03\x18,<\
    \nM\n\x04\x04\0\x02\x03\x12\x03\x1b\x04A\x1a@\x20Network-server\x20ID\
    \x20on\x20which\x20the\x20service-profile\x20is\x20provisioned.\n\n\r\n\
    \x05\x04\0\x02\x03\x04\x12\x04\x1b\x04\x18>\n\x0c\n\x05\x04\0\x02\x03\
    \x05\x12\x03\x1b\x04\t\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x1b\n\x1b\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1b\x1e\x20\n\x0c\n\x05\x04\0\x02\
    \x03\x08\x12\x03\x1b!@\n\x0c\n\x05\x04\0\x02\x03\n\x12\x03\x1b.?\nD\n\
    \x04\x04\0\x02\x04\x12\x03\x1e\x04\x17\x1a7\x20Token\x20bucket\x20fillin\
    g\x20rate,\x20including\x20ACKs\x20(packet/h).\n\n\r\n\x05\x04\0\x02\x04\
    \x04\x12\x04\x1e\x04\x1bA\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x1e\x04\
    \n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1e\x0b\x12\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03\x1e\x15\x16\n'\n\x04\x04\0\x02\x05\x12\x03!\x04\x1e\
    \x1a\x1a\x20Token\x20bucket\x20burst\x20size.\n\n\r\n\x05\x04\0\x02\x05\
    \x04\x12\x04!\x04\x1e\x17\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03!\x04\n\n\
    \x0c\n\x05\x04\0\x02\x05\x01\x12\x03!\x0b\x19\n\x0c\n\x05\x04\0\x02\x05\
    \x03\x12\x03!\x1c\x1d\n2\n\x04\x04\0\x02\x06\x12\x03$\x04\"\x1a%\x20Drop\
    \x20or\x20mark\x20when\x20exceeding\x20ULRate.\n\n\r\n\x05\x04\0\x02\x06\
    \x04\x12\x04$\x04!\x1e\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03$\x04\x0e\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03$\x0f\x1d\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03$\x20!\nD\n\x04\x04\0\x02\x07\x12\x03'\x04\x17\x1a7\x20Token\
    \x20bucket\x20filling\x20rate,\x20including\x20ACKs\x20(packet/h).\n\n\r\
    \n\x05\x04\0\x02\x07\x04\x12\x04'\x04$\"\n\x0c\n\x05\x04\0\x02\x07\x05\
    \x12\x03'\x04\n\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03'\x0b\x12\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03'\x15\x16\n'\n\x04\x04\0\x02\x08\x12\x03*\
    \x04\x1e\x1a\x1a\x20Token\x20bucket\x20burst\x20size.\n\n\r\n\x05\x04\0\
    \x02\x08\x04\x12\x04*\x04'\x17\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03*\
    \x04\n\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03*\x0b\x19\n\x0c\n\x05\x04\0\
    \x02\x08\x03\x12\x03*\x1c\x1d\n2\n\x04\x04\0\x02\t\x12\x03-\x04\"\x1a%\
    \x20Drop\x20or\x20mark\x20when\x20exceeding\x20DLRate.\n\n\r\n\x05\x04\0\
    \x02\t\x04\x12\x04-\x04*\x1e\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03-\x04\
    \x0e\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03-\x0f\x1d\n\x0c\n\x05\x04\0\x02\
    \t\x03\x12\x03-\x20!\n\\\n\x04\x04\0\x02\n\x12\x030\x04;\x1aO\x20GW\x20m\
    etadata\x20(RSSI,\x20SNR,\x20GW\x20geoloc.,\x20etc.)\x20are\x20added\x20\
    to\x20the\x20packet\x20sent\x20to\x20AS.\n\n\r\n\x05\x04\0\x02\n\x04\x12\
    \x040\x04-\"\n\x0c\n\x05\x04\0\x02\n\x05\x12\x030\x04\x08\n\x0c\n\x05\
    \x04\0\x02\n\x01\x12\x030\t\x18\n\x0c\n\x05\x04\0\x02\n\x03\x12\x030\x1b\
    \x1c\n\x0c\n\x05\x04\0\x02\n\x08\x12\x030\x1d:\n\x0c\n\x05\x04\0\x02\n\n\
    \x12\x030*9\nP\n\x04\x04\0\x02\x0b\x12\x033\x04#\x1aC\x20Frequency\x20to\
    \x20initiate\x20an\x20End-Device\x20status\x20request\x20(request/day).\
    \n\n\r\n\x05\x04\0\x02\x0b\x04\x12\x043\x040;\n\x0c\n\x05\x04\0\x02\x0b\
    \x05\x12\x033\x04\n\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x033\x0b\x1e\n\x0c\
    \n\x05\x04\0\x02\x0b\x03\x12\x033!\"\n5\n\x04\x04\0\x02\x0c\x12\x036\x04\
    (\x1a(\x20Report\x20End-Device\x20battery\x20level\x20to\x20AS.\n\n\r\n\
    \x05\x04\0\x02\x0c\x04\x12\x046\x043#\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\
    \x036\x04\x08\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x036\t\"\n\x0c\n\x05\x04\
    \0\x02\x0c\x03\x12\x036%'\n.\n\x04\x04\0\x02\r\x12\x039\x04'\x1a!\x20Rep\
    ort\x20End-Device\x20margin\x20to\x20AS.\n\n\r\n\x05\x04\0\x02\r\x04\x12\
    \x049\x046(\n\x0c\n\x05\x04\0\x02\r\x05\x12\x039\x04\x08\n\x0c\n\x05\x04\
    \0\x02\r\x01\x12\x039\t!\n\x0c\n\x05\x04\0\x02\r\x03\x12\x039$&\n7\n\x04\
    \x04\0\x02\x0e\x12\x03<\x04\x17\x1a*\x20Minimum\x20allowed\x20data\x20ra\
    te.\x20Used\x20for\x20ADR.\n\n\r\n\x05\x04\0\x02\x0e\x04\x12\x04<\x049'\
    \n\x0c\n\x05\x04\0\x02\x0e\x05\x12\x03<\x04\n\n\x0c\n\x05\x04\0\x02\x0e\
    \x01\x12\x03<\x0b\x11\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03<\x14\x16\n7\
    \n\x04\x04\0\x02\x0f\x12\x03?\x04\x17\x1a*\x20Maximum\x20allowed\x20data\
    \x20rate.\x20Used\x20for\x20ADR.\n\n\r\n\x05\x04\0\x02\x0f\x04\x12\x04?\
    \x04<\x17\n\x0c\n\x05\x04\0\x02\x0f\x05\x12\x03?\x04\n\n\x0c\n\x05\x04\0\
    \x02\x0f\x01\x12\x03?\x0b\x11\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03?\x14\
    \x16\nK\n\x04\x04\0\x02\x10\x12\x03B\x04\x1c\x1a>\x20Channel\x20mask.\
    \x20sNS\x20does\x20not\x20have\x20to\x20obey\x20(i.e.,\x20informative).\
    \n\n\r\n\x05\x04\0\x02\x10\x04\x12\x04B\x04?\x17\n\x0c\n\x05\x04\0\x02\
    \x10\x05\x12\x03B\x04\t\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03B\n\x16\n\
    \x0c\n\x05\x04\0\x02\x10\x03\x12\x03B\x19\x1b\n'\n\x04\x04\0\x02\x11\x12\
    \x03E\x04\x19\x1a\x1a\x20Passive\x20Roaming\x20allowed.\n\n\r\n\x05\x04\
    \0\x02\x11\x04\x12\x04E\x04B\x1c\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x03E\
    \x04\x08\n\x0c\n\x05\x04\0\x02\x11\x01\x12\x03E\t\x13\n\x0c\n\x05\x04\0\
    \x02\x11\x03\x12\x03E\x16\x18\n(\n\x04\x04\0\x02\x12\x12\x03H\x04\x19\
    \x1a\x1b\x20Handover\x20Roaming\x20allowed.\n\n\r\n\x05\x04\0\x02\x12\
    \x04\x12\x04H\x04E\x19\n\x0c\n\x05\x04\0\x02\x12\x05\x12\x03H\x04\x08\n\
    \x0c\n\x05\x04\0\x02\x12\x01\x12\x03H\t\x13\n\x0c\n\x05\x04\0\x02\x12\
    \x03\x12\x03H\x16\x18\n*\n\x04\x04\0\x02\x13\x12\x03K\x04\x19\x1a\x1d\
    \x20Roaming\x20Activation\x20allowed.\n\n\r\n\x05\x04\0\x02\x13\x04\x12\
    \x04K\x04H\x19\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x03K\x04\x08\n\x0c\n\
    \x05\x04\0\x02\x13\x01\x12\x03K\t\x13\n\x0c\n\x05\x04\0\x02\x13\x03\x12\
    \x03K\x16\x18\n2\n\x04\x04\0\x02\x14\x12\x03N\x04\x1a\x1a%\x20Enable\x20\
    network\x20geolocation\x20service.\n\n\r\n\x05\x04\0\x02\x14\x04\x12\x04\
    N\x04K\x19\n\x0c\n\x05\x04\0\x02\x14\x05\x12\x03N\x04\x08\n\x0c\n\x05\
    \x04\0\x02\x14\x01\x12\x03N\t\x14\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03N\
    \x17\x19\n(\n\x04\x04\0\x02\x15\x12\x03Q\x045\x1a\x1b\x20Target\x20Packe\
    t\x20Error\x20Rate.\n\n\r\n\x05\x04\0\x02\x15\x04\x12\x04Q\x04N\x1a\n\
    \x0c\n\x05\x04\0\x02\x15\x05\x12\x03Q\x04\n\n\x0c\n\x05\x04\0\x02\x15\
    \x01\x12\x03Q\x0b\x15\n\x0c\n\x05\x04\0\x02\x15\x03\x12\x03Q\x18\x1a\n\
    \x0c\n\x05\x04\0\x02\x15\x08\x12\x03Q\x1b4\n\x0c\n\x05\x04\0\x02\x15\n\
    \x12\x03Q(3\n=\n\x04\x04\0\x02\x16\x12\x03T\x04@\x1a0\x20Minimum\x20numb\
    er\x20of\x20receiving\x20GWs\x20(informative).\n\n\r\n\x05\x04\0\x02\x16\
    \x04\x12\x04T\x04Q5\n\x0c\n\x05\x04\0\x02\x16\x05\x12\x03T\x04\n\n\x0c\n\
    \x05\x04\0\x02\x16\x01\x12\x03T\x0b\x1b\n\x0c\n\x05\x04\0\x02\x16\x03\
    \x12\x03T\x1e\x20\n\x0c\n\x05\x04\0\x02\x16\x08\x12\x03T!?\n\x0c\n\x05\
    \x04\0\x02\x16\n\x12\x03T.>\n\x0b\n\x02\x04\x01\x12\x05X\0\xb5\x01\x01\n\
    \n\n\x03\x04\x01\x01\x12\x03X\x08\x15\n/\n\x04\x04\x01\x02\0\x12\x03Z\
    \x04\x12\x1a\"\x20Device-profile\x20ID\x20(UUID\x20string).\n\n\r\n\x05\
    \x04\x01\x02\0\x04\x12\x04Z\x04X\x17\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03Z\x04\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03Z\x0b\r\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03Z\x10\x11\n#\n\x04\x04\x01\x02\x01\x12\x03]\x04\
    \x15\x1a\x16\x20Device-profile\x20name.\n\n\r\n\x05\x04\x01\x02\x01\x04\
    \x12\x04]\x04Z\x12\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03]\x04\n\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03]\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03]\x12\x14\nH\n\x04\x04\x01\x02\x02\x12\x03`\x04>\x1a;\x20Org\
    anization\x20ID\x20to\x20which\x20the\x20service-profile\x20is\x20assign\
    ed.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04`\x04]\x15\n\x0c\n\x05\x04\
    \x01\x02\x02\x05\x12\x03`\x04\t\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03`\
    \n\x19\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03`\x1c\x1e\n\x0c\n\x05\x04\
    \x01\x02\x02\x08\x12\x03`\x1f=\n\x0c\n\x05\x04\x01\x02\x02\n\x12\x03`,<\
    \nM\n\x04\x04\x01\x02\x03\x12\x03c\x04A\x1a@\x20Network-server\x20ID\x20\
    on\x20which\x20the\x20service-profile\x20is\x20provisioned.\n\n\r\n\x05\
    \x04\x01\x02\x03\x04\x12\x04c\x04`>\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03c\x04\t\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03c\n\x1b\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03c\x1e\x20\n\x0c\n\x05\x04\x01\x02\x03\x08\
    \x12\x03c!@\n\x0c\n\x05\x04\x01\x02\x03\n\x12\x03c.?\n+\n\x04\x04\x01\
    \x02\x04\x12\x03f\x04\x1e\x1a\x1e\x20End-Device\x20supports\x20Class\x20\
    B.\n\n\r\n\x05\x04\x01\x02\x04\x04\x12\x04f\x04cA\n\x0c\n\x05\x04\x01\
    \x02\x04\x05\x12\x03f\x04\x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03f\t\
    \x19\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03f\x1c\x1d\n\x86\x01\n\x04\
    \x04\x01\x02\x05\x12\x03i\x04\x1f\x1ay\x20Maximum\x20delay\x20for\x20the\
    \x20End-Device\x20to\x20answer\x20a\x20MAC\x20request\x20or\x20a\x20conf\
    irmed\x20DL\x20frame\x20(mandatory\x20if\x20class\x20B\x20mode\x20suppor\
    ted).\n\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04i\x04f\x1e\n\x0c\n\x05\x04\
    \x01\x02\x05\x05\x12\x03i\x04\n\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03i\
    \x0b\x1a\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03i\x1d\x1e\n3\n\x04\x04\
    \x01\x02\x06\x12\x03l\x04\x20\x1a&\x20Mandatory\x20if\x20class\x20B\x20m\
    ode\x20supported.\n\n\r\n\x05\x04\x01\x02\x06\x04\x12\x04l\x04i\x1f\n\
    \x0c\n\x05\x04\x01\x02\x06\x05\x12\x03l\x04\n\n\x0c\n\x05\x04\x01\x02\
    \x06\x01\x12\x03l\x0b\x1b\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03l\x1e\
    \x1f\n3\n\x04\x04\x01\x02\x07\x12\x03o\x047\x1a&\x20Mandatory\x20if\x20c\
    lass\x20B\x20mode\x20supported.\n\n\r\n\x05\x04\x01\x02\x07\x04\x12\x04o\
    \x04l\x20\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03o\x04\n\n\x0c\n\x05\x04\
    \x01\x02\x07\x01\x12\x03o\x0b\x17\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\
    \x03o\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x07\x08\x12\x03o\x1c6\n\x0c\n\x05\
    \x04\x01\x02\x07\n\x12\x03o)5\n3\n\x04\x04\x01\x02\x08\x12\x03r\x04\x1e\
    \x1a&\x20Mandatory\x20if\x20class\x20B\x20mode\x20supported.\n\n\r\n\x05\
    \x04\x01\x02\x08\x04\x12\x04r\x04o7\n\x0c\n\x05\x04\x01\x02\x08\x05\x12\
    \x03r\x04\n\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03r\x0b\x19\n\x0c\n\x05\
    \x04\x01\x02\x08\x03\x12\x03r\x1c\x1d\n+\n\x04\x04\x01\x02\t\x12\x03u\
    \x04\x1e\x1a\x1e\x20End-Device\x20supports\x20Class\x20C.\n\n\r\n\x05\
    \x04\x01\x02\t\x04\x12\x04u\x04r\x1e\n\x0c\n\x05\x04\x01\x02\t\x05\x12\
    \x03u\x04\x08\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03u\t\x19\n\x0c\n\x05\
    \x04\x01\x02\t\x03\x12\x03u\x1c\x1d\n\x86\x01\n\x04\x04\x01\x02\n\x12\
    \x03x\x04\x1f\x1ay\x20Maximum\x20delay\x20for\x20the\x20End-Device\x20to\
    \x20answer\x20a\x20MAC\x20request\x20or\x20a\x20confirmed\x20DL\x20frame\
    \x20(mandatory\x20if\x20class\x20C\x20mode\x20supported).\n\n\r\n\x05\
    \x04\x01\x02\n\x04\x12\x04x\x04u\x1e\n\x0c\n\x05\x04\x01\x02\n\x05\x12\
    \x03x\x04\n\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03x\x0b\x1a\n\x0c\n\x05\
    \x04\x01\x02\n\x03\x12\x03x\x1d\x1e\nB\n\x04\x04\x01\x02\x0b\x12\x03{\
    \x04\x1b\x1a5\x20Version\x20of\x20the\x20LoRaWAN\x20supported\x20by\x20t\
    he\x20End-Device.\n\n\r\n\x05\x04\x01\x02\x0b\x04\x12\x04{\x04x\x1f\n\
    \x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03{\x04\n\n\x0c\n\x05\x04\x01\x02\
    \x0b\x01\x12\x03{\x0b\x16\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03{\x19\
    \x1a\nX\n\x04\x04\x01\x02\x0c\x12\x03~\x04$\x1aK\x20Revision\x20of\x20th\
    e\x20Regional\x20Parameters\x20document\x20supported\x20by\x20the\x20End\
    -Device.\n\n\r\n\x05\x04\x01\x02\x0c\x04\x12\x04~\x04{\x1b\n\x0c\n\x05\
    \x04\x01\x02\x0c\x05\x12\x03~\x04\n\n\x0c\n\x05\x04\x01\x02\x0c\x01\x12\
    \x03~\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03~!#\n6\n\x04\x04\
    \x01\x02\r\x12\x04\x81\x01\x04\x1b\x1a(\x20Class\x20A\x20RX1\x20delay\
    \x20(mandatory\x20for\x20ABP).\n\n\x0e\n\x05\x04\x01\x02\r\x04\x12\x05\
    \x81\x01\x04~$\n\r\n\x05\x04\x01\x02\r\x05\x12\x04\x81\x01\x04\n\n\r\n\
    \x05\x04\x01\x02\r\x01\x12\x04\x81\x01\x0b\x15\n\r\n\x05\x04\x01\x02\r\
    \x03\x12\x04\x81\x01\x18\x1a\n9\n\x04\x04\x01\x02\x0e\x12\x04\x84\x01\
    \x04;\x1a+\x20RX1\x20data\x20rate\x20offset\x20(mandatory\x20for\x20ABP)\
    .\n\n\x0f\n\x05\x04\x01\x02\x0e\x04\x12\x06\x84\x01\x04\x81\x01\x1b\n\r\
    \n\x05\x04\x01\x02\x0e\x05\x12\x04\x84\x01\x04\n\n\r\n\x05\x04\x01\x02\
    \x0e\x01\x12\x04\x84\x01\x0b\x19\n\r\n\x05\x04\x01\x02\x0e\x03\x12\x04\
    \x84\x01\x1c\x1e\n\r\n\x05\x04\x01\x02\x0e\x08\x12\x04\x84\x01\x1f:\n\r\
    \n\x05\x04\x01\x02\x0e\n\x12\x04\x84\x01,9\n2\n\x04\x04\x01\x02\x0f\x12\
    \x04\x87\x01\x04:\x1a$\x20RX2\x20data\x20rate\x20(mandatory\x20for\x20AB\
    P).\n\n\x0f\n\x05\x04\x01\x02\x0f\x04\x12\x06\x87\x01\x04\x84\x01;\n\r\n\
    \x05\x04\x01\x02\x0f\x05\x12\x04\x87\x01\x04\n\n\r\n\x05\x04\x01\x02\x0f\
    \x01\x12\x04\x87\x01\x0b\x18\n\r\n\x05\x04\x01\x02\x0f\x03\x12\x04\x87\
    \x01\x1b\x1d\n\r\n\x05\x04\x01\x02\x0f\x08\x12\x04\x87\x01\x1e9\n\r\n\
    \x05\x04\x01\x02\x0f\n\x12\x04\x87\x01+8\n:\n\x04\x04\x01\x02\x10\x12\
    \x04\x8a\x01\x04\x1a\x1a,\x20RX2\x20channel\x20frequency\x20(mandatory\
    \x20for\x20ABP).\n\n\x0f\n\x05\x04\x01\x02\x10\x04\x12\x06\x8a\x01\x04\
    \x87\x01:\n\r\n\x05\x04\x01\x02\x10\x05\x12\x04\x8a\x01\x04\n\n\r\n\x05\
    \x04\x01\x02\x10\x01\x12\x04\x8a\x01\x0b\x14\n\r\n\x05\x04\x01\x02\x10\
    \x03\x12\x04\x8a\x01\x17\x19\nG\n\x04\x04\x01\x02\x11\x12\x04\x8d\x01\
    \x04.\x1a9\x20List\x20of\x20factory-preset\x20frequencies\x20(mandatory\
    \x20for\x20ABP).\n\n\r\n\x05\x04\x01\x02\x11\x04\x12\x04\x8d\x01\x04\x0c\
    \n\r\n\x05\x04\x01\x02\x11\x05\x12\x04\x8d\x01\r\x13\n\r\n\x05\x04\x01\
    \x02\x11\x01\x12\x04\x8d\x01\x14(\n\r\n\x05\x04\x01\x02\x11\x03\x12\x04\
    \x8d\x01+-\n9\n\x04\x04\x01\x02\x12\x12\x04\x90\x01\x041\x1a+\x20Maximum\
    \x20EIRP\x20supported\x20by\x20the\x20End-Device.\n\n\x0f\n\x05\x04\x01\
    \x02\x12\x04\x12\x06\x90\x01\x04\x8d\x01.\n\r\n\x05\x04\x01\x02\x12\x05\
    \x12\x04\x90\x01\x04\n\n\r\n\x05\x04\x01\x02\x12\x01\x12\x04\x90\x01\x0b\
    \x13\n\r\n\x05\x04\x01\x02\x12\x03\x12\x04\x90\x01\x16\x18\n\r\n\x05\x04\
    \x01\x02\x12\x08\x12\x04\x90\x01\x190\n\r\n\x05\x04\x01\x02\x12\n\x12\
    \x04\x90\x01&/\n?\n\x04\x04\x01\x02\x13\x12\x04\x93\x01\x04\x1f\x1a1\x20\
    Maximum\x20duty\x20cycle\x20supported\x20by\x20the\x20End-Device.\n\n\
    \x0f\n\x05\x04\x01\x02\x13\x04\x12\x06\x93\x01\x04\x90\x011\n\r\n\x05\
    \x04\x01\x02\x13\x05\x12\x04\x93\x01\x04\n\n\r\n\x05\x04\x01\x02\x13\x01\
    \x12\x04\x93\x01\x0b\x19\n\r\n\x05\x04\x01\x02\x13\x03\x12\x04\x93\x01\
    \x1c\x1e\n=\n\x04\x04\x01\x02\x14\x12\x04\x96\x01\x04\x1c\x1a/\x20End-De\
    vice\x20supports\x20Join\x20(OTAA)\x20or\x20not\x20(ABP).\n\n\x0f\n\x05\
    \x04\x01\x02\x14\x04\x12\x06\x96\x01\x04\x93\x01\x1f\n\r\n\x05\x04\x01\
    \x02\x14\x05\x12\x04\x96\x01\x04\x08\n\r\n\x05\x04\x01\x02\x14\x01\x12\
    \x04\x96\x01\t\x16\n\r\n\x05\x04\x01\x02\x14\x03\x12\x04\x96\x01\x19\x1b\
    \n\x1f\n\x04\x04\x01\x02\x15\x12\x04\x99\x01\x04\x1a\x1a\x11\x20RF\x20re\
    gion\x20name.\n\n\x0f\n\x05\x04\x01\x02\x15\x04\x12\x06\x99\x01\x04\x96\
    \x01\x1c\n\r\n\x05\x04\x01\x02\x15\x05\x12\x04\x99\x01\x04\n\n\r\n\x05\
    \x04\x01\x02\x15\x01\x12\x04\x99\x01\x0b\x14\n\r\n\x05\x04\x01\x02\x15\
    \x03\x12\x04\x99\x01\x17\x19\nR\n\x04\x04\x01\x02\x16\x12\x04\x9c\x01\
    \x04E\x1aD\x20End-Device\x20uses\x2032bit\x20FCnt\x20(mandatory\x20for\
    \x20LoRaWAN\x201.0\x20End-Device).\n\n\x0f\n\x05\x04\x01\x02\x16\x04\x12\
    \x06\x9c\x01\x04\x99\x01\x1a\n\r\n\x05\x04\x01\x02\x16\x05\x12\x04\x9c\
    \x01\x04\x08\n\r\n\x05\x04\x01\x02\x16\x01\x12\x04\x9c\x01\t\x1d\n\r\n\
    \x05\x04\x01\x02\x16\x03\x12\x04\x9c\x01\x20\"\n\r\n\x05\x04\x01\x02\x16\
    \x08\x12\x04\x9c\x01#D\n\r\n\x05\x04\x01\x02\x16\n\x12\x04\x9c\x010C\nI\
    \n\x04\x04\x01\x02\x17\x12\x04\xa0\x01\x04\x1e\x1a;\x20Payload\x20codec.\
    \n\x20Leave\x20blank\x20to\x20disable\x20the\x20codec\x20feature.\n\n\
    \x0f\n\x05\x04\x01\x02\x17\x04\x12\x06\xa0\x01\x04\x9c\x01E\n\r\n\x05\
    \x04\x01\x02\x17\x05\x12\x04\xa0\x01\x04\n\n\r\n\x05\x04\x01\x02\x17\x01\
    \x12\x04\xa0\x01\x0b\x18\n\r\n\x05\x04\x01\x02\x17\x03\x12\x04\xa0\x01\
    \x1b\x1d\n\x88\x01\n\x04\x04\x01\x02\x18\x12\x04\xa5\x01\x04'\x1az\x20Pa\
    yload\x20encoder\x20script.\n\x20Depending\x20the\x20codec,\x20it\x20is\
    \x20possible\x20to\x20provide\x20a\x20script\x20which\x20implements\n\
    \x20the\x20encoder\x20function.\n\n\x0f\n\x05\x04\x01\x02\x18\x04\x12\
    \x06\xa5\x01\x04\xa0\x01\x1e\n\r\n\x05\x04\x01\x02\x18\x05\x12\x04\xa5\
    \x01\x04\n\n\r\n\x05\x04\x01\x02\x18\x01\x12\x04\xa5\x01\x0b!\n\r\n\x05\
    \x04\x01\x02\x18\x03\x12\x04\xa5\x01$&\n\x88\x01\n\x04\x04\x01\x02\x19\
    \x12\x04\xaa\x01\x04'\x1az\x20Payload\x20decoder\x20script.\n\x20Dependi\
    ng\x20the\x20codec,\x20it\x20is\x20possible\x20to\x20provide\x20a\x20scr\
    ipt\x20which\x20implements\n\x20the\x20decoder\x20function.\n\n\x0f\n\
    \x05\x04\x01\x02\x19\x04\x12\x06\xaa\x01\x04\xa5\x01'\n\r\n\x05\x04\x01\
    \x02\x19\x05\x12\x04\xaa\x01\x04\n\n\r\n\x05\x04\x01\x02\x19\x01\x12\x04\
    \xaa\x01\x0b!\n\r\n\x05\x04\x01\x02\x19\x03\x12\x04\xaa\x01$&\n\xb7\x01\
    \n\x04\x04\x01\x02\x1a\x12\x04\xaf\x01\x04B\x1a\xa8\x01\x20Geolocation\
    \x20buffer\x20TTL\x20(in\x20seconds).\n\x20When\x20>\x200,\x20uplink\x20\
    RX\x20meta-data\x20will\x20be\x20stored\x20in\x20a\x20buffer\x20so\x20th\
    at\n\x20the\x20meta-data\x20of\x20multiple\x20uplinks\x20can\x20be\x20us\
    ed\x20for\x20geolocation.\n\n\x0f\n\x05\x04\x01\x02\x1a\x04\x12\x06\xaf\
    \x01\x04\xaa\x01'\n\r\n\x05\x04\x01\x02\x1a\x05\x12\x04\xaf\x01\x04\n\n\
    \r\n\x05\x04\x01\x02\x1a\x01\x12\x04\xaf\x01\x0b\x1c\n\r\n\x05\x04\x01\
    \x02\x1a\x03\x12\x04\xaf\x01\x1f!\n\r\n\x05\x04\x01\x02\x1a\x08\x12\x04\
    \xaf\x01\"A\n\r\n\x05\x04\x01\x02\x1a\n\x12\x04\xaf\x01/@\n\x8c\x01\n\
    \x04\x04\x01\x02\x1b\x12\x04\xb4\x01\x04'\x1a~\x20Geolocation\x20minimum\
    \x20buffer\x20size.\n\x20When\x20>\x200,\x20geolocation\x20will\x20only\
    \x20be\x20performed\x20when\x20the\x20buffer\x20has\n\x20at\x20least\x20\
    the\x20given\x20size.\n\n\x0f\n\x05\x04\x01\x02\x1b\x04\x12\x06\xb4\x01\
    \x04\xaf\x01B\n\r\n\x05\x04\x01\x02\x1b\x05\x12\x04\xb4\x01\x04\n\n\r\n\
    \x05\x04\x01\x02\x1b\x01\x12\x04\xb4\x01\x0b!\n\r\n\x05\x04\x01\x02\x1b\
    \x03\x12\x04\xb4\x01$&b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
