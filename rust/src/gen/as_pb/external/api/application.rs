// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `as/external/api/application.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Application {
    // message fields
    pub id: i64,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub organization_id: i64,
    pub service_profile_id: ::std::string::String,
    pub payload_codec: ::std::string::String,
    pub payload_encoder_script: ::std::string::String,
    pub payload_decoder_script: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Application {
    fn default() -> &'a Application {
        <Application as ::protobuf::Message>::default_instance()
    }
}

impl Application {
    pub fn new() -> Application {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int64 organization_id = 4;


    pub fn get_organization_id(&self) -> i64 {
        self.organization_id
    }
    pub fn clear_organization_id(&mut self) {
        self.organization_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: i64) {
        self.organization_id = v;
    }

    // string service_profile_id = 5;


    pub fn get_service_profile_id(&self) -> &str {
        &self.service_profile_id
    }
    pub fn clear_service_profile_id(&mut self) {
        self.service_profile_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_profile_id(&mut self, v: ::std::string::String) {
        self.service_profile_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_profile_id(&mut self) -> &mut ::std::string::String {
        &mut self.service_profile_id
    }

    // Take field
    pub fn take_service_profile_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_profile_id, ::std::string::String::new())
    }

    // string payload_codec = 6;


    pub fn get_payload_codec(&self) -> &str {
        &self.payload_codec
    }
    pub fn clear_payload_codec(&mut self) {
        self.payload_codec.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_codec(&mut self, v: ::std::string::String) {
        self.payload_codec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_codec(&mut self) -> &mut ::std::string::String {
        &mut self.payload_codec
    }

    // Take field
    pub fn take_payload_codec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_codec, ::std::string::String::new())
    }

    // string payload_encoder_script = 7;


    pub fn get_payload_encoder_script(&self) -> &str {
        &self.payload_encoder_script
    }
    pub fn clear_payload_encoder_script(&mut self) {
        self.payload_encoder_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_encoder_script(&mut self, v: ::std::string::String) {
        self.payload_encoder_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_encoder_script(&mut self) -> &mut ::std::string::String {
        &mut self.payload_encoder_script
    }

    // Take field
    pub fn take_payload_encoder_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_encoder_script, ::std::string::String::new())
    }

    // string payload_decoder_script = 8;


    pub fn get_payload_decoder_script(&self) -> &str {
        &self.payload_decoder_script
    }
    pub fn clear_payload_decoder_script(&mut self) {
        self.payload_decoder_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_decoder_script(&mut self, v: ::std::string::String) {
        self.payload_decoder_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_decoder_script(&mut self) -> &mut ::std::string::String {
        &mut self.payload_decoder_script
    }

    // Take field
    pub fn take_payload_decoder_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_decoder_script, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Application {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.organization_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_profile_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_codec)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_encoder_script)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_decoder_script)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.organization_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.organization_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.service_profile_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.service_profile_id);
        }
        if !self.payload_codec.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payload_codec);
        }
        if !self.payload_encoder_script.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.payload_encoder_script);
        }
        if !self.payload_decoder_script.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.payload_decoder_script);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.organization_id != 0 {
            os.write_int64(4, self.organization_id)?;
        }
        if !self.service_profile_id.is_empty() {
            os.write_string(5, &self.service_profile_id)?;
        }
        if !self.payload_codec.is_empty() {
            os.write_string(6, &self.payload_codec)?;
        }
        if !self.payload_encoder_script.is_empty() {
            os.write_string(7, &self.payload_encoder_script)?;
        }
        if !self.payload_decoder_script.is_empty() {
            os.write_string(8, &self.payload_decoder_script)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Application {
        Application::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &Application| { &m.id },
                    |m: &mut Application| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Application| { &m.name },
                    |m: &mut Application| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Application| { &m.description },
                    |m: &mut Application| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "organization_id",
                    |m: &Application| { &m.organization_id },
                    |m: &mut Application| { &mut m.organization_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service_profile_id",
                    |m: &Application| { &m.service_profile_id },
                    |m: &mut Application| { &mut m.service_profile_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_codec",
                    |m: &Application| { &m.payload_codec },
                    |m: &mut Application| { &mut m.payload_codec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_encoder_script",
                    |m: &Application| { &m.payload_encoder_script },
                    |m: &mut Application| { &mut m.payload_encoder_script },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payload_decoder_script",
                    |m: &Application| { &m.payload_decoder_script },
                    |m: &mut Application| { &mut m.payload_decoder_script },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Application>(
                    "Application",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Application {
        static mut instance: ::protobuf::lazy::Lazy<Application> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Application,
        };
        unsafe {
            instance.get(Application::new)
        }
    }
}

impl ::protobuf::Clear for Application {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.description.clear();
        self.organization_id = 0;
        self.service_profile_id.clear();
        self.payload_codec.clear();
        self.payload_encoder_script.clear();
        self.payload_decoder_script.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Application {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Application {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationListItem {
    // message fields
    pub id: i64,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub organization_id: i64,
    pub service_profile_id: ::std::string::String,
    pub service_profile_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationListItem {
    fn default() -> &'a ApplicationListItem {
        <ApplicationListItem as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationListItem {
    pub fn new() -> ApplicationListItem {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int64 organization_id = 4;


    pub fn get_organization_id(&self) -> i64 {
        self.organization_id
    }
    pub fn clear_organization_id(&mut self) {
        self.organization_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: i64) {
        self.organization_id = v;
    }

    // string service_profile_id = 5;


    pub fn get_service_profile_id(&self) -> &str {
        &self.service_profile_id
    }
    pub fn clear_service_profile_id(&mut self) {
        self.service_profile_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_profile_id(&mut self, v: ::std::string::String) {
        self.service_profile_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_profile_id(&mut self) -> &mut ::std::string::String {
        &mut self.service_profile_id
    }

    // Take field
    pub fn take_service_profile_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_profile_id, ::std::string::String::new())
    }

    // string service_profile_name = 6;


    pub fn get_service_profile_name(&self) -> &str {
        &self.service_profile_name
    }
    pub fn clear_service_profile_name(&mut self) {
        self.service_profile_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_profile_name(&mut self, v: ::std::string::String) {
        self.service_profile_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_profile_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_profile_name
    }

    // Take field
    pub fn take_service_profile_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_profile_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ApplicationListItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.organization_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_profile_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_profile_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.organization_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.organization_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.service_profile_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.service_profile_id);
        }
        if !self.service_profile_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.service_profile_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.organization_id != 0 {
            os.write_int64(4, self.organization_id)?;
        }
        if !self.service_profile_id.is_empty() {
            os.write_string(5, &self.service_profile_id)?;
        }
        if !self.service_profile_name.is_empty() {
            os.write_string(6, &self.service_profile_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationListItem {
        ApplicationListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &ApplicationListItem| { &m.id },
                    |m: &mut ApplicationListItem| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ApplicationListItem| { &m.name },
                    |m: &mut ApplicationListItem| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &ApplicationListItem| { &m.description },
                    |m: &mut ApplicationListItem| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "organization_id",
                    |m: &ApplicationListItem| { &m.organization_id },
                    |m: &mut ApplicationListItem| { &mut m.organization_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service_profile_id",
                    |m: &ApplicationListItem| { &m.service_profile_id },
                    |m: &mut ApplicationListItem| { &mut m.service_profile_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service_profile_name",
                    |m: &ApplicationListItem| { &m.service_profile_name },
                    |m: &mut ApplicationListItem| { &mut m.service_profile_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplicationListItem>(
                    "ApplicationListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplicationListItem {
        static mut instance: ::protobuf::lazy::Lazy<ApplicationListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplicationListItem,
        };
        unsafe {
            instance.get(ApplicationListItem::new)
        }
    }
}

impl ::protobuf::Clear for ApplicationListItem {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.description.clear();
        self.organization_id = 0;
        self.service_profile_id.clear();
        self.service_profile_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateApplicationRequest {
    // message fields
    pub application: ::protobuf::SingularPtrField<Application>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateApplicationRequest {
    fn default() -> &'a CreateApplicationRequest {
        <CreateApplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateApplicationRequest {
    pub fn new() -> CreateApplicationRequest {
        ::std::default::Default::default()
    }

    // .api.Application application = 1;


    pub fn get_application(&self) -> &Application {
        self.application.as_ref().unwrap_or_else(|| Application::default_instance())
    }
    pub fn clear_application(&mut self) {
        self.application.clear();
    }

    pub fn has_application(&self) -> bool {
        self.application.is_some()
    }

    // Param is passed by value, moved
    pub fn set_application(&mut self, v: Application) {
        self.application = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application(&mut self) -> &mut Application {
        if self.application.is_none() {
            self.application.set_default();
        }
        self.application.as_mut().unwrap()
    }

    // Take field
    pub fn take_application(&mut self) -> Application {
        self.application.take().unwrap_or_else(|| Application::new())
    }
}

impl ::protobuf::Message for CreateApplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.application {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.application)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.application.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.application.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateApplicationRequest {
        CreateApplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Application>>(
                    "application",
                    |m: &CreateApplicationRequest| { &m.application },
                    |m: &mut CreateApplicationRequest| { &mut m.application },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateApplicationRequest>(
                    "CreateApplicationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateApplicationRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateApplicationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateApplicationRequest,
        };
        unsafe {
            instance.get(CreateApplicationRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateApplicationRequest {
    fn clear(&mut self) {
        self.application.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateApplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateApplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateApplicationResponse {
    // message fields
    pub id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateApplicationResponse {
    fn default() -> &'a CreateApplicationResponse {
        <CreateApplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateApplicationResponse {
    pub fn new() -> CreateApplicationResponse {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }
}

impl ::protobuf::Message for CreateApplicationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateApplicationResponse {
        CreateApplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &CreateApplicationResponse| { &m.id },
                    |m: &mut CreateApplicationResponse| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateApplicationResponse>(
                    "CreateApplicationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateApplicationResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateApplicationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateApplicationResponse,
        };
        unsafe {
            instance.get(CreateApplicationResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateApplicationResponse {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateApplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateApplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetApplicationRequest {
    // message fields
    pub id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetApplicationRequest {
    fn default() -> &'a GetApplicationRequest {
        <GetApplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetApplicationRequest {
    pub fn new() -> GetApplicationRequest {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }
}

impl ::protobuf::Message for GetApplicationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetApplicationRequest {
        GetApplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &GetApplicationRequest| { &m.id },
                    |m: &mut GetApplicationRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetApplicationRequest>(
                    "GetApplicationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetApplicationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetApplicationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetApplicationRequest,
        };
        unsafe {
            instance.get(GetApplicationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetApplicationRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetApplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetApplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetApplicationResponse {
    // message fields
    pub application: ::protobuf::SingularPtrField<Application>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetApplicationResponse {
    fn default() -> &'a GetApplicationResponse {
        <GetApplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetApplicationResponse {
    pub fn new() -> GetApplicationResponse {
        ::std::default::Default::default()
    }

    // .api.Application application = 1;


    pub fn get_application(&self) -> &Application {
        self.application.as_ref().unwrap_or_else(|| Application::default_instance())
    }
    pub fn clear_application(&mut self) {
        self.application.clear();
    }

    pub fn has_application(&self) -> bool {
        self.application.is_some()
    }

    // Param is passed by value, moved
    pub fn set_application(&mut self, v: Application) {
        self.application = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application(&mut self) -> &mut Application {
        if self.application.is_none() {
            self.application.set_default();
        }
        self.application.as_mut().unwrap()
    }

    // Take field
    pub fn take_application(&mut self) -> Application {
        self.application.take().unwrap_or_else(|| Application::new())
    }
}

impl ::protobuf::Message for GetApplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.application {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.application)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.application.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.application.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetApplicationResponse {
        GetApplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Application>>(
                    "application",
                    |m: &GetApplicationResponse| { &m.application },
                    |m: &mut GetApplicationResponse| { &mut m.application },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetApplicationResponse>(
                    "GetApplicationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetApplicationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetApplicationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetApplicationResponse,
        };
        unsafe {
            instance.get(GetApplicationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetApplicationResponse {
    fn clear(&mut self) {
        self.application.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetApplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetApplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateApplicationRequest {
    // message fields
    pub application: ::protobuf::SingularPtrField<Application>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateApplicationRequest {
    fn default() -> &'a UpdateApplicationRequest {
        <UpdateApplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateApplicationRequest {
    pub fn new() -> UpdateApplicationRequest {
        ::std::default::Default::default()
    }

    // .api.Application application = 1;


    pub fn get_application(&self) -> &Application {
        self.application.as_ref().unwrap_or_else(|| Application::default_instance())
    }
    pub fn clear_application(&mut self) {
        self.application.clear();
    }

    pub fn has_application(&self) -> bool {
        self.application.is_some()
    }

    // Param is passed by value, moved
    pub fn set_application(&mut self, v: Application) {
        self.application = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application(&mut self) -> &mut Application {
        if self.application.is_none() {
            self.application.set_default();
        }
        self.application.as_mut().unwrap()
    }

    // Take field
    pub fn take_application(&mut self) -> Application {
        self.application.take().unwrap_or_else(|| Application::new())
    }
}

impl ::protobuf::Message for UpdateApplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.application {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.application)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.application.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.application.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateApplicationRequest {
        UpdateApplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Application>>(
                    "application",
                    |m: &UpdateApplicationRequest| { &m.application },
                    |m: &mut UpdateApplicationRequest| { &mut m.application },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateApplicationRequest>(
                    "UpdateApplicationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateApplicationRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateApplicationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateApplicationRequest,
        };
        unsafe {
            instance.get(UpdateApplicationRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateApplicationRequest {
    fn clear(&mut self) {
        self.application.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateApplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateApplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteApplicationRequest {
    // message fields
    pub id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteApplicationRequest {
    fn default() -> &'a DeleteApplicationRequest {
        <DeleteApplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteApplicationRequest {
    pub fn new() -> DeleteApplicationRequest {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }
}

impl ::protobuf::Message for DeleteApplicationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteApplicationRequest {
        DeleteApplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &DeleteApplicationRequest| { &m.id },
                    |m: &mut DeleteApplicationRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteApplicationRequest>(
                    "DeleteApplicationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteApplicationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteApplicationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteApplicationRequest,
        };
        unsafe {
            instance.get(DeleteApplicationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteApplicationRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteApplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteApplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListApplicationRequest {
    // message fields
    pub limit: i64,
    pub offset: i64,
    pub organization_id: i64,
    pub search: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListApplicationRequest {
    fn default() -> &'a ListApplicationRequest {
        <ListApplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListApplicationRequest {
    pub fn new() -> ListApplicationRequest {
        ::std::default::Default::default()
    }

    // int64 limit = 1;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 organization_id = 3;


    pub fn get_organization_id(&self) -> i64 {
        self.organization_id
    }
    pub fn clear_organization_id(&mut self) {
        self.organization_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: i64) {
        self.organization_id = v;
    }

    // string search = 4;


    pub fn get_search(&self) -> &str {
        &self.search
    }
    pub fn clear_search(&mut self) {
        self.search.clear();
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: ::std::string::String) {
        self.search = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut ::std::string::String {
        &mut self.search
    }

    // Take field
    pub fn take_search(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.search, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListApplicationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.organization_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.search)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.organization_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.organization_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.search.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.search);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_int64(1, self.limit)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.organization_id != 0 {
            os.write_int64(3, self.organization_id)?;
        }
        if !self.search.is_empty() {
            os.write_string(4, &self.search)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListApplicationRequest {
        ListApplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ListApplicationRequest| { &m.limit },
                    |m: &mut ListApplicationRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "offset",
                    |m: &ListApplicationRequest| { &m.offset },
                    |m: &mut ListApplicationRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "organization_id",
                    |m: &ListApplicationRequest| { &m.organization_id },
                    |m: &mut ListApplicationRequest| { &mut m.organization_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "search",
                    |m: &ListApplicationRequest| { &m.search },
                    |m: &mut ListApplicationRequest| { &mut m.search },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListApplicationRequest>(
                    "ListApplicationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListApplicationRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListApplicationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListApplicationRequest,
        };
        unsafe {
            instance.get(ListApplicationRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListApplicationRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.offset = 0;
        self.organization_id = 0;
        self.search.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListApplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListApplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListApplicationResponse {
    // message fields
    pub total_count: i64,
    pub result: ::protobuf::RepeatedField<ApplicationListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListApplicationResponse {
    fn default() -> &'a ListApplicationResponse {
        <ListApplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListApplicationResponse {
    pub fn new() -> ListApplicationResponse {
        ::std::default::Default::default()
    }

    // int64 total_count = 1;


    pub fn get_total_count(&self) -> i64 {
        self.total_count
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i64) {
        self.total_count = v;
    }

    // repeated .api.ApplicationListItem result = 2;


    pub fn get_result(&self) -> &[ApplicationListItem] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<ApplicationListItem>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<ApplicationListItem> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<ApplicationListItem> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListApplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_count != 0 {
            os.write_int64(1, self.total_count)?;
        }
        for v in &self.result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListApplicationResponse {
        ListApplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_count",
                    |m: &ListApplicationResponse| { &m.total_count },
                    |m: &mut ListApplicationResponse| { &mut m.total_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplicationListItem>>(
                    "result",
                    |m: &ListApplicationResponse| { &m.result },
                    |m: &mut ListApplicationResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListApplicationResponse>(
                    "ListApplicationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListApplicationResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListApplicationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListApplicationResponse,
        };
        unsafe {
            instance.get(ListApplicationResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListApplicationResponse {
    fn clear(&mut self) {
        self.total_count = 0;
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListApplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListApplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPIntegrationHeader {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPIntegrationHeader {
    fn default() -> &'a HTTPIntegrationHeader {
        <HTTPIntegrationHeader as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIntegrationHeader {
    pub fn new() -> HTTPIntegrationHeader {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTPIntegrationHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPIntegrationHeader {
        HTTPIntegrationHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &HTTPIntegrationHeader| { &m.key },
                    |m: &mut HTTPIntegrationHeader| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &HTTPIntegrationHeader| { &m.value },
                    |m: &mut HTTPIntegrationHeader| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPIntegrationHeader>(
                    "HTTPIntegrationHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTTPIntegrationHeader {
        static mut instance: ::protobuf::lazy::Lazy<HTTPIntegrationHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPIntegrationHeader,
        };
        unsafe {
            instance.get(HTTPIntegrationHeader::new)
        }
    }
}

impl ::protobuf::Clear for HTTPIntegrationHeader {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPIntegrationHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIntegrationHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPIntegration {
    // message fields
    pub application_id: i64,
    pub headers: ::protobuf::RepeatedField<HTTPIntegrationHeader>,
    pub uplink_data_url: ::std::string::String,
    pub join_notification_url: ::std::string::String,
    pub ack_notification_url: ::std::string::String,
    pub error_notification_url: ::std::string::String,
    pub status_notification_url: ::std::string::String,
    pub location_notification_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPIntegration {
    fn default() -> &'a HTTPIntegration {
        <HTTPIntegration as ::protobuf::Message>::default_instance()
    }
}

impl HTTPIntegration {
    pub fn new() -> HTTPIntegration {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // repeated .api.HTTPIntegrationHeader headers = 2;


    pub fn get_headers(&self) -> &[HTTPIntegrationHeader] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HTTPIntegrationHeader>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HTTPIntegrationHeader> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HTTPIntegrationHeader> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // string uplink_data_url = 3;


    pub fn get_uplink_data_url(&self) -> &str {
        &self.uplink_data_url
    }
    pub fn clear_uplink_data_url(&mut self) {
        self.uplink_data_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_uplink_data_url(&mut self, v: ::std::string::String) {
        self.uplink_data_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uplink_data_url(&mut self) -> &mut ::std::string::String {
        &mut self.uplink_data_url
    }

    // Take field
    pub fn take_uplink_data_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uplink_data_url, ::std::string::String::new())
    }

    // string join_notification_url = 4;


    pub fn get_join_notification_url(&self) -> &str {
        &self.join_notification_url
    }
    pub fn clear_join_notification_url(&mut self) {
        self.join_notification_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_join_notification_url(&mut self, v: ::std::string::String) {
        self.join_notification_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_join_notification_url(&mut self) -> &mut ::std::string::String {
        &mut self.join_notification_url
    }

    // Take field
    pub fn take_join_notification_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.join_notification_url, ::std::string::String::new())
    }

    // string ack_notification_url = 5;


    pub fn get_ack_notification_url(&self) -> &str {
        &self.ack_notification_url
    }
    pub fn clear_ack_notification_url(&mut self) {
        self.ack_notification_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_notification_url(&mut self, v: ::std::string::String) {
        self.ack_notification_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack_notification_url(&mut self) -> &mut ::std::string::String {
        &mut self.ack_notification_url
    }

    // Take field
    pub fn take_ack_notification_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ack_notification_url, ::std::string::String::new())
    }

    // string error_notification_url = 6;


    pub fn get_error_notification_url(&self) -> &str {
        &self.error_notification_url
    }
    pub fn clear_error_notification_url(&mut self) {
        self.error_notification_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_notification_url(&mut self, v: ::std::string::String) {
        self.error_notification_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_notification_url(&mut self) -> &mut ::std::string::String {
        &mut self.error_notification_url
    }

    // Take field
    pub fn take_error_notification_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_notification_url, ::std::string::String::new())
    }

    // string status_notification_url = 7;


    pub fn get_status_notification_url(&self) -> &str {
        &self.status_notification_url
    }
    pub fn clear_status_notification_url(&mut self) {
        self.status_notification_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_notification_url(&mut self, v: ::std::string::String) {
        self.status_notification_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_notification_url(&mut self) -> &mut ::std::string::String {
        &mut self.status_notification_url
    }

    // Take field
    pub fn take_status_notification_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_notification_url, ::std::string::String::new())
    }

    // string location_notification_url = 8;


    pub fn get_location_notification_url(&self) -> &str {
        &self.location_notification_url
    }
    pub fn clear_location_notification_url(&mut self) {
        self.location_notification_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_location_notification_url(&mut self, v: ::std::string::String) {
        self.location_notification_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location_notification_url(&mut self) -> &mut ::std::string::String {
        &mut self.location_notification_url
    }

    // Take field
    pub fn take_location_notification_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location_notification_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTPIntegration {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uplink_data_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.join_notification_url)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ack_notification_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_notification_url)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_notification_url)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location_notification_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.uplink_data_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uplink_data_url);
        }
        if !self.join_notification_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.join_notification_url);
        }
        if !self.ack_notification_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.ack_notification_url);
        }
        if !self.error_notification_url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.error_notification_url);
        }
        if !self.status_notification_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.status_notification_url);
        }
        if !self.location_notification_url.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.location_notification_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        for v in &self.headers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.uplink_data_url.is_empty() {
            os.write_string(3, &self.uplink_data_url)?;
        }
        if !self.join_notification_url.is_empty() {
            os.write_string(4, &self.join_notification_url)?;
        }
        if !self.ack_notification_url.is_empty() {
            os.write_string(5, &self.ack_notification_url)?;
        }
        if !self.error_notification_url.is_empty() {
            os.write_string(6, &self.error_notification_url)?;
        }
        if !self.status_notification_url.is_empty() {
            os.write_string(7, &self.status_notification_url)?;
        }
        if !self.location_notification_url.is_empty() {
            os.write_string(8, &self.location_notification_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPIntegration {
        HTTPIntegration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &HTTPIntegration| { &m.application_id },
                    |m: &mut HTTPIntegration| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPIntegrationHeader>>(
                    "headers",
                    |m: &HTTPIntegration| { &m.headers },
                    |m: &mut HTTPIntegration| { &mut m.headers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uplink_data_url",
                    |m: &HTTPIntegration| { &m.uplink_data_url },
                    |m: &mut HTTPIntegration| { &mut m.uplink_data_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "join_notification_url",
                    |m: &HTTPIntegration| { &m.join_notification_url },
                    |m: &mut HTTPIntegration| { &mut m.join_notification_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ack_notification_url",
                    |m: &HTTPIntegration| { &m.ack_notification_url },
                    |m: &mut HTTPIntegration| { &mut m.ack_notification_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_notification_url",
                    |m: &HTTPIntegration| { &m.error_notification_url },
                    |m: &mut HTTPIntegration| { &mut m.error_notification_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status_notification_url",
                    |m: &HTTPIntegration| { &m.status_notification_url },
                    |m: &mut HTTPIntegration| { &mut m.status_notification_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location_notification_url",
                    |m: &HTTPIntegration| { &m.location_notification_url },
                    |m: &mut HTTPIntegration| { &mut m.location_notification_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPIntegration>(
                    "HTTPIntegration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTTPIntegration {
        static mut instance: ::protobuf::lazy::Lazy<HTTPIntegration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPIntegration,
        };
        unsafe {
            instance.get(HTTPIntegration::new)
        }
    }
}

impl ::protobuf::Clear for HTTPIntegration {
    fn clear(&mut self) {
        self.application_id = 0;
        self.headers.clear();
        self.uplink_data_url.clear();
        self.join_notification_url.clear();
        self.ack_notification_url.clear();
        self.error_notification_url.clear();
        self.status_notification_url.clear();
        self.location_notification_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPIntegration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPIntegration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateHTTPIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<HTTPIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateHTTPIntegrationRequest {
    fn default() -> &'a CreateHTTPIntegrationRequest {
        <CreateHTTPIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateHTTPIntegrationRequest {
    pub fn new() -> CreateHTTPIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.HTTPIntegration integration = 1;


    pub fn get_integration(&self) -> &HTTPIntegration {
        self.integration.as_ref().unwrap_or_else(|| HTTPIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: HTTPIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut HTTPIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> HTTPIntegration {
        self.integration.take().unwrap_or_else(|| HTTPIntegration::new())
    }
}

impl ::protobuf::Message for CreateHTTPIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateHTTPIntegrationRequest {
        CreateHTTPIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPIntegration>>(
                    "integration",
                    |m: &CreateHTTPIntegrationRequest| { &m.integration },
                    |m: &mut CreateHTTPIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateHTTPIntegrationRequest>(
                    "CreateHTTPIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateHTTPIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateHTTPIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateHTTPIntegrationRequest,
        };
        unsafe {
            instance.get(CreateHTTPIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateHTTPIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateHTTPIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateHTTPIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHTTPIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetHTTPIntegrationRequest {
    fn default() -> &'a GetHTTPIntegrationRequest {
        <GetHTTPIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetHTTPIntegrationRequest {
    pub fn new() -> GetHTTPIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for GetHTTPIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHTTPIntegrationRequest {
        GetHTTPIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &GetHTTPIntegrationRequest| { &m.application_id },
                    |m: &mut GetHTTPIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHTTPIntegrationRequest>(
                    "GetHTTPIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHTTPIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetHTTPIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHTTPIntegrationRequest,
        };
        unsafe {
            instance.get(GetHTTPIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetHTTPIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHTTPIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHTTPIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHTTPIntegrationResponse {
    // message fields
    pub integration: ::protobuf::SingularPtrField<HTTPIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetHTTPIntegrationResponse {
    fn default() -> &'a GetHTTPIntegrationResponse {
        <GetHTTPIntegrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetHTTPIntegrationResponse {
    pub fn new() -> GetHTTPIntegrationResponse {
        ::std::default::Default::default()
    }

    // .api.HTTPIntegration integration = 1;


    pub fn get_integration(&self) -> &HTTPIntegration {
        self.integration.as_ref().unwrap_or_else(|| HTTPIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: HTTPIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut HTTPIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> HTTPIntegration {
        self.integration.take().unwrap_or_else(|| HTTPIntegration::new())
    }
}

impl ::protobuf::Message for GetHTTPIntegrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHTTPIntegrationResponse {
        GetHTTPIntegrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPIntegration>>(
                    "integration",
                    |m: &GetHTTPIntegrationResponse| { &m.integration },
                    |m: &mut GetHTTPIntegrationResponse| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetHTTPIntegrationResponse>(
                    "GetHTTPIntegrationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetHTTPIntegrationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetHTTPIntegrationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetHTTPIntegrationResponse,
        };
        unsafe {
            instance.get(GetHTTPIntegrationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetHTTPIntegrationResponse {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHTTPIntegrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHTTPIntegrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateHTTPIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<HTTPIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateHTTPIntegrationRequest {
    fn default() -> &'a UpdateHTTPIntegrationRequest {
        <UpdateHTTPIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateHTTPIntegrationRequest {
    pub fn new() -> UpdateHTTPIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.HTTPIntegration integration = 1;


    pub fn get_integration(&self) -> &HTTPIntegration {
        self.integration.as_ref().unwrap_or_else(|| HTTPIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: HTTPIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut HTTPIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> HTTPIntegration {
        self.integration.take().unwrap_or_else(|| HTTPIntegration::new())
    }
}

impl ::protobuf::Message for UpdateHTTPIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateHTTPIntegrationRequest {
        UpdateHTTPIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPIntegration>>(
                    "integration",
                    |m: &UpdateHTTPIntegrationRequest| { &m.integration },
                    |m: &mut UpdateHTTPIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateHTTPIntegrationRequest>(
                    "UpdateHTTPIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateHTTPIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateHTTPIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateHTTPIntegrationRequest,
        };
        unsafe {
            instance.get(UpdateHTTPIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateHTTPIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateHTTPIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateHTTPIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteHTTPIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteHTTPIntegrationRequest {
    fn default() -> &'a DeleteHTTPIntegrationRequest {
        <DeleteHTTPIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteHTTPIntegrationRequest {
    pub fn new() -> DeleteHTTPIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for DeleteHTTPIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteHTTPIntegrationRequest {
        DeleteHTTPIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &DeleteHTTPIntegrationRequest| { &m.application_id },
                    |m: &mut DeleteHTTPIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteHTTPIntegrationRequest>(
                    "DeleteHTTPIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteHTTPIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteHTTPIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteHTTPIntegrationRequest,
        };
        unsafe {
            instance.get(DeleteHTTPIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteHTTPIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteHTTPIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteHTTPIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListIntegrationRequest {
    fn default() -> &'a ListIntegrationRequest {
        <ListIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListIntegrationRequest {
    pub fn new() -> ListIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for ListIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListIntegrationRequest {
        ListIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &ListIntegrationRequest| { &m.application_id },
                    |m: &mut ListIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListIntegrationRequest>(
                    "ListIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListIntegrationRequest,
        };
        unsafe {
            instance.get(ListIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntegrationListItem {
    // message fields
    pub kind: IntegrationKind,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntegrationListItem {
    fn default() -> &'a IntegrationListItem {
        <IntegrationListItem as ::protobuf::Message>::default_instance()
    }
}

impl IntegrationListItem {
    pub fn new() -> IntegrationListItem {
        ::std::default::Default::default()
    }

    // .api.IntegrationKind kind = 1;


    pub fn get_kind(&self) -> IntegrationKind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = IntegrationKind::HTTP;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: IntegrationKind) {
        self.kind = v;
    }
}

impl ::protobuf::Message for IntegrationListItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != IntegrationKind::HTTP {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != IntegrationKind::HTTP {
            os.write_enum(1, self.kind.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntegrationListItem {
        IntegrationListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IntegrationKind>>(
                    "kind",
                    |m: &IntegrationListItem| { &m.kind },
                    |m: &mut IntegrationListItem| { &mut m.kind },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IntegrationListItem>(
                    "IntegrationListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntegrationListItem {
        static mut instance: ::protobuf::lazy::Lazy<IntegrationListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IntegrationListItem,
        };
        unsafe {
            instance.get(IntegrationListItem::new)
        }
    }
}

impl ::protobuf::Clear for IntegrationListItem {
    fn clear(&mut self) {
        self.kind = IntegrationKind::HTTP;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntegrationListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegrationListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListIntegrationResponse {
    // message fields
    pub total_count: i64,
    pub result: ::protobuf::RepeatedField<IntegrationListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListIntegrationResponse {
    fn default() -> &'a ListIntegrationResponse {
        <ListIntegrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListIntegrationResponse {
    pub fn new() -> ListIntegrationResponse {
        ::std::default::Default::default()
    }

    // int64 total_count = 1;


    pub fn get_total_count(&self) -> i64 {
        self.total_count
    }
    pub fn clear_total_count(&mut self) {
        self.total_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i64) {
        self.total_count = v;
    }

    // repeated .api.IntegrationListItem result = 2;


    pub fn get_result(&self) -> &[IntegrationListItem] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<IntegrationListItem>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<IntegrationListItem> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<IntegrationListItem> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListIntegrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_count != 0 {
            os.write_int64(1, self.total_count)?;
        }
        for v in &self.result {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListIntegrationResponse {
        ListIntegrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_count",
                    |m: &ListIntegrationResponse| { &m.total_count },
                    |m: &mut ListIntegrationResponse| { &mut m.total_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntegrationListItem>>(
                    "result",
                    |m: &ListIntegrationResponse| { &m.result },
                    |m: &mut ListIntegrationResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListIntegrationResponse>(
                    "ListIntegrationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListIntegrationResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListIntegrationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListIntegrationResponse,
        };
        unsafe {
            instance.get(ListIntegrationResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListIntegrationResponse {
    fn clear(&mut self) {
        self.total_count = 0;
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListIntegrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListIntegrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InfluxDBIntegration {
    // message fields
    pub application_id: i64,
    pub endpoint: ::std::string::String,
    pub db: ::std::string::String,
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub retention_policy_name: ::std::string::String,
    pub precision: InfluxDBPrecision,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InfluxDBIntegration {
    fn default() -> &'a InfluxDBIntegration {
        <InfluxDBIntegration as ::protobuf::Message>::default_instance()
    }
}

impl InfluxDBIntegration {
    pub fn new() -> InfluxDBIntegration {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string endpoint = 2;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // string db = 3;


    pub fn get_db(&self) -> &str {
        &self.db
    }
    pub fn clear_db(&mut self) {
        self.db.clear();
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: ::std::string::String) {
        self.db = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db(&mut self) -> &mut ::std::string::String {
        &mut self.db
    }

    // Take field
    pub fn take_db(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.db, ::std::string::String::new())
    }

    // string username = 4;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 5;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string retention_policy_name = 6;


    pub fn get_retention_policy_name(&self) -> &str {
        &self.retention_policy_name
    }
    pub fn clear_retention_policy_name(&mut self) {
        self.retention_policy_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_retention_policy_name(&mut self, v: ::std::string::String) {
        self.retention_policy_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retention_policy_name(&mut self) -> &mut ::std::string::String {
        &mut self.retention_policy_name
    }

    // Take field
    pub fn take_retention_policy_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.retention_policy_name, ::std::string::String::new())
    }

    // .api.InfluxDBPrecision precision = 7;


    pub fn get_precision(&self) -> InfluxDBPrecision {
        self.precision
    }
    pub fn clear_precision(&mut self) {
        self.precision = InfluxDBPrecision::NS;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: InfluxDBPrecision) {
        self.precision = v;
    }
}

impl ::protobuf::Message for InfluxDBIntegration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.db)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.retention_policy_name)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.precision, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.endpoint);
        }
        if !self.db.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.db);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.password);
        }
        if !self.retention_policy_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.retention_policy_name);
        }
        if self.precision != InfluxDBPrecision::NS {
            my_size += ::protobuf::rt::enum_size(7, self.precision);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(2, &self.endpoint)?;
        }
        if !self.db.is_empty() {
            os.write_string(3, &self.db)?;
        }
        if !self.username.is_empty() {
            os.write_string(4, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(5, &self.password)?;
        }
        if !self.retention_policy_name.is_empty() {
            os.write_string(6, &self.retention_policy_name)?;
        }
        if self.precision != InfluxDBPrecision::NS {
            os.write_enum(7, self.precision.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InfluxDBIntegration {
        InfluxDBIntegration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &InfluxDBIntegration| { &m.application_id },
                    |m: &mut InfluxDBIntegration| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &InfluxDBIntegration| { &m.endpoint },
                    |m: &mut InfluxDBIntegration| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "db",
                    |m: &InfluxDBIntegration| { &m.db },
                    |m: &mut InfluxDBIntegration| { &mut m.db },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &InfluxDBIntegration| { &m.username },
                    |m: &mut InfluxDBIntegration| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &InfluxDBIntegration| { &m.password },
                    |m: &mut InfluxDBIntegration| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "retention_policy_name",
                    |m: &InfluxDBIntegration| { &m.retention_policy_name },
                    |m: &mut InfluxDBIntegration| { &mut m.retention_policy_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InfluxDBPrecision>>(
                    "precision",
                    |m: &InfluxDBIntegration| { &m.precision },
                    |m: &mut InfluxDBIntegration| { &mut m.precision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InfluxDBIntegration>(
                    "InfluxDBIntegration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InfluxDBIntegration {
        static mut instance: ::protobuf::lazy::Lazy<InfluxDBIntegration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InfluxDBIntegration,
        };
        unsafe {
            instance.get(InfluxDBIntegration::new)
        }
    }
}

impl ::protobuf::Clear for InfluxDBIntegration {
    fn clear(&mut self) {
        self.application_id = 0;
        self.endpoint.clear();
        self.db.clear();
        self.username.clear();
        self.password.clear();
        self.retention_policy_name.clear();
        self.precision = InfluxDBPrecision::NS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InfluxDBIntegration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InfluxDBIntegration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateInfluxDBIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<InfluxDBIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateInfluxDBIntegrationRequest {
    fn default() -> &'a CreateInfluxDBIntegrationRequest {
        <CreateInfluxDBIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateInfluxDBIntegrationRequest {
    pub fn new() -> CreateInfluxDBIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.InfluxDBIntegration integration = 1;


    pub fn get_integration(&self) -> &InfluxDBIntegration {
        self.integration.as_ref().unwrap_or_else(|| InfluxDBIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: InfluxDBIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut InfluxDBIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> InfluxDBIntegration {
        self.integration.take().unwrap_or_else(|| InfluxDBIntegration::new())
    }
}

impl ::protobuf::Message for CreateInfluxDBIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateInfluxDBIntegrationRequest {
        CreateInfluxDBIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InfluxDBIntegration>>(
                    "integration",
                    |m: &CreateInfluxDBIntegrationRequest| { &m.integration },
                    |m: &mut CreateInfluxDBIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateInfluxDBIntegrationRequest>(
                    "CreateInfluxDBIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateInfluxDBIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateInfluxDBIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateInfluxDBIntegrationRequest,
        };
        unsafe {
            instance.get(CreateInfluxDBIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateInfluxDBIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateInfluxDBIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateInfluxDBIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfluxDBIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfluxDBIntegrationRequest {
    fn default() -> &'a GetInfluxDBIntegrationRequest {
        <GetInfluxDBIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfluxDBIntegrationRequest {
    pub fn new() -> GetInfluxDBIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for GetInfluxDBIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfluxDBIntegrationRequest {
        GetInfluxDBIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &GetInfluxDBIntegrationRequest| { &m.application_id },
                    |m: &mut GetInfluxDBIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfluxDBIntegrationRequest>(
                    "GetInfluxDBIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfluxDBIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInfluxDBIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfluxDBIntegrationRequest,
        };
        unsafe {
            instance.get(GetInfluxDBIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInfluxDBIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfluxDBIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfluxDBIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfluxDBIntegrationResponse {
    // message fields
    pub integration: ::protobuf::SingularPtrField<InfluxDBIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfluxDBIntegrationResponse {
    fn default() -> &'a GetInfluxDBIntegrationResponse {
        <GetInfluxDBIntegrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfluxDBIntegrationResponse {
    pub fn new() -> GetInfluxDBIntegrationResponse {
        ::std::default::Default::default()
    }

    // .api.InfluxDBIntegration integration = 1;


    pub fn get_integration(&self) -> &InfluxDBIntegration {
        self.integration.as_ref().unwrap_or_else(|| InfluxDBIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: InfluxDBIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut InfluxDBIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> InfluxDBIntegration {
        self.integration.take().unwrap_or_else(|| InfluxDBIntegration::new())
    }
}

impl ::protobuf::Message for GetInfluxDBIntegrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfluxDBIntegrationResponse {
        GetInfluxDBIntegrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InfluxDBIntegration>>(
                    "integration",
                    |m: &GetInfluxDBIntegrationResponse| { &m.integration },
                    |m: &mut GetInfluxDBIntegrationResponse| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfluxDBIntegrationResponse>(
                    "GetInfluxDBIntegrationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfluxDBIntegrationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetInfluxDBIntegrationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfluxDBIntegrationResponse,
        };
        unsafe {
            instance.get(GetInfluxDBIntegrationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetInfluxDBIntegrationResponse {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfluxDBIntegrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfluxDBIntegrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateInfluxDBIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<InfluxDBIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateInfluxDBIntegrationRequest {
    fn default() -> &'a UpdateInfluxDBIntegrationRequest {
        <UpdateInfluxDBIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInfluxDBIntegrationRequest {
    pub fn new() -> UpdateInfluxDBIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.InfluxDBIntegration integration = 1;


    pub fn get_integration(&self) -> &InfluxDBIntegration {
        self.integration.as_ref().unwrap_or_else(|| InfluxDBIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: InfluxDBIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut InfluxDBIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> InfluxDBIntegration {
        self.integration.take().unwrap_or_else(|| InfluxDBIntegration::new())
    }
}

impl ::protobuf::Message for UpdateInfluxDBIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInfluxDBIntegrationRequest {
        UpdateInfluxDBIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InfluxDBIntegration>>(
                    "integration",
                    |m: &UpdateInfluxDBIntegrationRequest| { &m.integration },
                    |m: &mut UpdateInfluxDBIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateInfluxDBIntegrationRequest>(
                    "UpdateInfluxDBIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateInfluxDBIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateInfluxDBIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateInfluxDBIntegrationRequest,
        };
        unsafe {
            instance.get(UpdateInfluxDBIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateInfluxDBIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInfluxDBIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInfluxDBIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteInfluxDBIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteInfluxDBIntegrationRequest {
    fn default() -> &'a DeleteInfluxDBIntegrationRequest {
        <DeleteInfluxDBIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteInfluxDBIntegrationRequest {
    pub fn new() -> DeleteInfluxDBIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for DeleteInfluxDBIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteInfluxDBIntegrationRequest {
        DeleteInfluxDBIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &DeleteInfluxDBIntegrationRequest| { &m.application_id },
                    |m: &mut DeleteInfluxDBIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteInfluxDBIntegrationRequest>(
                    "DeleteInfluxDBIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteInfluxDBIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteInfluxDBIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteInfluxDBIntegrationRequest,
        };
        unsafe {
            instance.get(DeleteInfluxDBIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteInfluxDBIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteInfluxDBIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteInfluxDBIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThingsBoardIntegration {
    // message fields
    pub application_id: i64,
    pub server: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThingsBoardIntegration {
    fn default() -> &'a ThingsBoardIntegration {
        <ThingsBoardIntegration as ::protobuf::Message>::default_instance()
    }
}

impl ThingsBoardIntegration {
    pub fn new() -> ThingsBoardIntegration {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }

    // string server = 2;


    pub fn get_server(&self) -> &str {
        &self.server
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        &mut self.server
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ThingsBoardIntegration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.server.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        if !self.server.is_empty() {
            os.write_string(2, &self.server)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThingsBoardIntegration {
        ThingsBoardIntegration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &ThingsBoardIntegration| { &m.application_id },
                    |m: &mut ThingsBoardIntegration| { &mut m.application_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server",
                    |m: &ThingsBoardIntegration| { &m.server },
                    |m: &mut ThingsBoardIntegration| { &mut m.server },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThingsBoardIntegration>(
                    "ThingsBoardIntegration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThingsBoardIntegration {
        static mut instance: ::protobuf::lazy::Lazy<ThingsBoardIntegration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThingsBoardIntegration,
        };
        unsafe {
            instance.get(ThingsBoardIntegration::new)
        }
    }
}

impl ::protobuf::Clear for ThingsBoardIntegration {
    fn clear(&mut self) {
        self.application_id = 0;
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThingsBoardIntegration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThingsBoardIntegration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateThingsBoardIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<ThingsBoardIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateThingsBoardIntegrationRequest {
    fn default() -> &'a CreateThingsBoardIntegrationRequest {
        <CreateThingsBoardIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateThingsBoardIntegrationRequest {
    pub fn new() -> CreateThingsBoardIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.ThingsBoardIntegration integration = 1;


    pub fn get_integration(&self) -> &ThingsBoardIntegration {
        self.integration.as_ref().unwrap_or_else(|| ThingsBoardIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: ThingsBoardIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut ThingsBoardIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> ThingsBoardIntegration {
        self.integration.take().unwrap_or_else(|| ThingsBoardIntegration::new())
    }
}

impl ::protobuf::Message for CreateThingsBoardIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateThingsBoardIntegrationRequest {
        CreateThingsBoardIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThingsBoardIntegration>>(
                    "integration",
                    |m: &CreateThingsBoardIntegrationRequest| { &m.integration },
                    |m: &mut CreateThingsBoardIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateThingsBoardIntegrationRequest>(
                    "CreateThingsBoardIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateThingsBoardIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateThingsBoardIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateThingsBoardIntegrationRequest,
        };
        unsafe {
            instance.get(CreateThingsBoardIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateThingsBoardIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateThingsBoardIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateThingsBoardIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetThingsBoardIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetThingsBoardIntegrationRequest {
    fn default() -> &'a GetThingsBoardIntegrationRequest {
        <GetThingsBoardIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetThingsBoardIntegrationRequest {
    pub fn new() -> GetThingsBoardIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for GetThingsBoardIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetThingsBoardIntegrationRequest {
        GetThingsBoardIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &GetThingsBoardIntegrationRequest| { &m.application_id },
                    |m: &mut GetThingsBoardIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetThingsBoardIntegrationRequest>(
                    "GetThingsBoardIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetThingsBoardIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetThingsBoardIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetThingsBoardIntegrationRequest,
        };
        unsafe {
            instance.get(GetThingsBoardIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetThingsBoardIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetThingsBoardIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetThingsBoardIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetThingsBoardIntegrationResponse {
    // message fields
    pub integration: ::protobuf::SingularPtrField<ThingsBoardIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetThingsBoardIntegrationResponse {
    fn default() -> &'a GetThingsBoardIntegrationResponse {
        <GetThingsBoardIntegrationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetThingsBoardIntegrationResponse {
    pub fn new() -> GetThingsBoardIntegrationResponse {
        ::std::default::Default::default()
    }

    // .api.ThingsBoardIntegration integration = 1;


    pub fn get_integration(&self) -> &ThingsBoardIntegration {
        self.integration.as_ref().unwrap_or_else(|| ThingsBoardIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: ThingsBoardIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut ThingsBoardIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> ThingsBoardIntegration {
        self.integration.take().unwrap_or_else(|| ThingsBoardIntegration::new())
    }
}

impl ::protobuf::Message for GetThingsBoardIntegrationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetThingsBoardIntegrationResponse {
        GetThingsBoardIntegrationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThingsBoardIntegration>>(
                    "integration",
                    |m: &GetThingsBoardIntegrationResponse| { &m.integration },
                    |m: &mut GetThingsBoardIntegrationResponse| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetThingsBoardIntegrationResponse>(
                    "GetThingsBoardIntegrationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetThingsBoardIntegrationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetThingsBoardIntegrationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetThingsBoardIntegrationResponse,
        };
        unsafe {
            instance.get(GetThingsBoardIntegrationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetThingsBoardIntegrationResponse {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetThingsBoardIntegrationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetThingsBoardIntegrationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateThingsBoardIntegrationRequest {
    // message fields
    pub integration: ::protobuf::SingularPtrField<ThingsBoardIntegration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateThingsBoardIntegrationRequest {
    fn default() -> &'a UpdateThingsBoardIntegrationRequest {
        <UpdateThingsBoardIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateThingsBoardIntegrationRequest {
    pub fn new() -> UpdateThingsBoardIntegrationRequest {
        ::std::default::Default::default()
    }

    // .api.ThingsBoardIntegration integration = 1;


    pub fn get_integration(&self) -> &ThingsBoardIntegration {
        self.integration.as_ref().unwrap_or_else(|| ThingsBoardIntegration::default_instance())
    }
    pub fn clear_integration(&mut self) {
        self.integration.clear();
    }

    pub fn has_integration(&self) -> bool {
        self.integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_integration(&mut self, v: ThingsBoardIntegration) {
        self.integration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_integration(&mut self) -> &mut ThingsBoardIntegration {
        if self.integration.is_none() {
            self.integration.set_default();
        }
        self.integration.as_mut().unwrap()
    }

    // Take field
    pub fn take_integration(&mut self) -> ThingsBoardIntegration {
        self.integration.take().unwrap_or_else(|| ThingsBoardIntegration::new())
    }
}

impl ::protobuf::Message for UpdateThingsBoardIntegrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.integration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.integration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.integration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateThingsBoardIntegrationRequest {
        UpdateThingsBoardIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThingsBoardIntegration>>(
                    "integration",
                    |m: &UpdateThingsBoardIntegrationRequest| { &m.integration },
                    |m: &mut UpdateThingsBoardIntegrationRequest| { &mut m.integration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateThingsBoardIntegrationRequest>(
                    "UpdateThingsBoardIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateThingsBoardIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateThingsBoardIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateThingsBoardIntegrationRequest,
        };
        unsafe {
            instance.get(UpdateThingsBoardIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateThingsBoardIntegrationRequest {
    fn clear(&mut self) {
        self.integration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateThingsBoardIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateThingsBoardIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteThingsBoardIntegrationRequest {
    // message fields
    pub application_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteThingsBoardIntegrationRequest {
    fn default() -> &'a DeleteThingsBoardIntegrationRequest {
        <DeleteThingsBoardIntegrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteThingsBoardIntegrationRequest {
    pub fn new() -> DeleteThingsBoardIntegrationRequest {
        ::std::default::Default::default()
    }

    // int64 application_id = 1;


    pub fn get_application_id(&self) -> i64 {
        self.application_id
    }
    pub fn clear_application_id(&mut self) {
        self.application_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_application_id(&mut self, v: i64) {
        self.application_id = v;
    }
}

impl ::protobuf::Message for DeleteThingsBoardIntegrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.application_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.application_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.application_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.application_id != 0 {
            os.write_int64(1, self.application_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteThingsBoardIntegrationRequest {
        DeleteThingsBoardIntegrationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "application_id",
                    |m: &DeleteThingsBoardIntegrationRequest| { &m.application_id },
                    |m: &mut DeleteThingsBoardIntegrationRequest| { &mut m.application_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteThingsBoardIntegrationRequest>(
                    "DeleteThingsBoardIntegrationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteThingsBoardIntegrationRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteThingsBoardIntegrationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteThingsBoardIntegrationRequest,
        };
        unsafe {
            instance.get(DeleteThingsBoardIntegrationRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteThingsBoardIntegrationRequest {
    fn clear(&mut self) {
        self.application_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteThingsBoardIntegrationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteThingsBoardIntegrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IntegrationKind {
    HTTP = 0,
    INFLUXDB = 1,
    THINGSBOARD = 2,
}

impl ::protobuf::ProtobufEnum for IntegrationKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IntegrationKind> {
        match value {
            0 => ::std::option::Option::Some(IntegrationKind::HTTP),
            1 => ::std::option::Option::Some(IntegrationKind::INFLUXDB),
            2 => ::std::option::Option::Some(IntegrationKind::THINGSBOARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IntegrationKind] = &[
            IntegrationKind::HTTP,
            IntegrationKind::INFLUXDB,
            IntegrationKind::THINGSBOARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("IntegrationKind", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for IntegrationKind {
}

impl ::std::default::Default for IntegrationKind {
    fn default() -> Self {
        IntegrationKind::HTTP
    }
}

impl ::protobuf::reflect::ProtobufValue for IntegrationKind {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InfluxDBPrecision {
    NS = 0,
    U = 1,
    MS = 2,
    S = 3,
    M = 4,
    H = 5,
}

impl ::protobuf::ProtobufEnum for InfluxDBPrecision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InfluxDBPrecision> {
        match value {
            0 => ::std::option::Option::Some(InfluxDBPrecision::NS),
            1 => ::std::option::Option::Some(InfluxDBPrecision::U),
            2 => ::std::option::Option::Some(InfluxDBPrecision::MS),
            3 => ::std::option::Option::Some(InfluxDBPrecision::S),
            4 => ::std::option::Option::Some(InfluxDBPrecision::M),
            5 => ::std::option::Option::Some(InfluxDBPrecision::H),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InfluxDBPrecision] = &[
            InfluxDBPrecision::NS,
            InfluxDBPrecision::U,
            InfluxDBPrecision::MS,
            InfluxDBPrecision::S,
            InfluxDBPrecision::M,
            InfluxDBPrecision::H,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("InfluxDBPrecision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for InfluxDBPrecision {
}

impl ::std::default::Default for InfluxDBPrecision {
    fn default() -> Self {
        InfluxDBPrecision::NS
    }
}

impl ::protobuf::reflect::ProtobufValue for InfluxDBPrecision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!as/external/api/application.proto\x12\x03api\x1a\x1cgoogle/api/annota\
    tions.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xbb\x02\n\x0bApplicatio\
    n\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdes\
    cription\x12'\n\x0forganization_id\x18\x04\x20\x01(\x03R\x0eorganization\
    ID\x12,\n\x12service_profile_id\x18\x05\x20\x01(\tR\x10serviceProfileID\
    \x12#\n\rpayload_codec\x18\x06\x20\x01(\tR\x0cpayloadCodec\x124\n\x16pay\
    load_encoder_script\x18\x07\x20\x01(\tR\x14payloadEncoderScript\x124\n\
    \x16payload_decoder_script\x18\x08\x20\x01(\tR\x14payloadDecoderScript\"\
    \xe4\x01\n\x13ApplicationListItem\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x20\n\x0bdescri\
    ption\x18\x03\x20\x01(\tR\x0bdescription\x12'\n\x0forganization_id\x18\
    \x04\x20\x01(\x03R\x0eorganizationID\x12,\n\x12service_profile_id\x18\
    \x05\x20\x01(\tR\x10serviceProfileID\x120\n\x14service_profile_name\x18\
    \x06\x20\x01(\tR\x12serviceProfileName\"N\n\x18CreateApplicationRequest\
    \x122\n\x0bapplication\x18\x01\x20\x01(\x0b2\x10.api.ApplicationR\x0bapp\
    lication\"+\n\x19CreateApplicationResponse\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x03R\x02id\"'\n\x15GetApplicationRequest\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x03R\x02id\"L\n\x16GetApplicationResponse\x122\n\x0bapplicatio\
    n\x18\x01\x20\x01(\x0b2\x10.api.ApplicationR\x0bapplication\"N\n\x18Upda\
    teApplicationRequest\x122\n\x0bapplication\x18\x01\x20\x01(\x0b2\x10.api\
    .ApplicationR\x0bapplication\"*\n\x18DeleteApplicationRequest\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x03R\x02id\"\x87\x01\n\x16ListApplicationRequest\
    \x12\x14\n\x05limit\x18\x01\x20\x01(\x03R\x05limit\x12\x16\n\x06offset\
    \x18\x02\x20\x01(\x03R\x06offset\x12'\n\x0forganization_id\x18\x03\x20\
    \x01(\x03R\x0eorganizationID\x12\x16\n\x06search\x18\x04\x20\x01(\tR\x06\
    search\"l\n\x17ListApplicationResponse\x12\x1f\n\x0btotal_count\x18\x01\
    \x20\x01(\x03R\ntotalCount\x120\n\x06result\x18\x02\x20\x03(\x0b2\x18.ap\
    i.ApplicationListItemR\x06result\"?\n\x15HTTPIntegrationHeader\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value\"\xa6\x03\n\x0fHTTPIntegration\x12%\n\x0eapplication_id\x18\
    \x01\x20\x01(\x03R\rapplicationID\x124\n\x07headers\x18\x02\x20\x03(\x0b\
    2\x1a.api.HTTPIntegrationHeaderR\x07headers\x12&\n\x0fuplink_data_url\
    \x18\x03\x20\x01(\tR\ruplinkDataURL\x122\n\x15join_notification_url\x18\
    \x04\x20\x01(\tR\x13joinNotificationURL\x120\n\x14ack_notification_url\
    \x18\x05\x20\x01(\tR\x12ackNotificationURL\x124\n\x16error_notification_\
    url\x18\x06\x20\x01(\tR\x14errorNotificationURL\x126\n\x17status_notific\
    ation_url\x18\x07\x20\x01(\tR\x15statusNotificationURL\x12:\n\x19locatio\
    n_notification_url\x18\x08\x20\x01(\tR\x17locationNotificationURL\"V\n\
    \x1cCreateHTTPIntegrationRequest\x126\n\x0bintegration\x18\x01\x20\x01(\
    \x0b2\x14.api.HTTPIntegrationR\x0bintegration\"B\n\x19GetHTTPIntegration\
    Request\x12%\n\x0eapplication_id\x18\x01\x20\x01(\x03R\rapplicationID\"T\
    \n\x1aGetHTTPIntegrationResponse\x126\n\x0bintegration\x18\x01\x20\x01(\
    \x0b2\x14.api.HTTPIntegrationR\x0bintegration\"V\n\x1cUpdateHTTPIntegrat\
    ionRequest\x126\n\x0bintegration\x18\x01\x20\x01(\x0b2\x14.api.HTTPInteg\
    rationR\x0bintegration\"E\n\x1cDeleteHTTPIntegrationRequest\x12%\n\x0eap\
    plication_id\x18\x01\x20\x01(\x03R\rapplicationID\"?\n\x16ListIntegratio\
    nRequest\x12%\n\x0eapplication_id\x18\x01\x20\x01(\x03R\rapplicationID\"\
    ?\n\x13IntegrationListItem\x12(\n\x04kind\x18\x01\x20\x01(\x0e2\x14.api.\
    IntegrationKindR\x04kind\"l\n\x17ListIntegrationResponse\x12\x1f\n\x0bto\
    tal_count\x18\x01\x20\x01(\x03R\ntotalCount\x120\n\x06result\x18\x02\x20\
    \x03(\x0b2\x18.api.IntegrationListItemR\x06result\"\x8a\x02\n\x13InfluxD\
    BIntegration\x12%\n\x0eapplication_id\x18\x01\x20\x01(\x03R\rapplication\
    ID\x12\x1a\n\x08endpoint\x18\x02\x20\x01(\tR\x08endpoint\x12\x0e\n\x02db\
    \x18\x03\x20\x01(\tR\x02db\x12\x1a\n\x08username\x18\x04\x20\x01(\tR\x08\
    username\x12\x1a\n\x08password\x18\x05\x20\x01(\tR\x08password\x122\n\
    \x15retention_policy_name\x18\x06\x20\x01(\tR\x13retentionPolicyName\x12\
    4\n\tprecision\x18\x07\x20\x01(\x0e2\x16.api.InfluxDBPrecisionR\tprecisi\
    on\"^\n\x20CreateInfluxDBIntegrationRequest\x12:\n\x0bintegration\x18\
    \x01\x20\x01(\x0b2\x18.api.InfluxDBIntegrationR\x0bintegration\"F\n\x1dG\
    etInfluxDBIntegrationRequest\x12%\n\x0eapplication_id\x18\x01\x20\x01(\
    \x03R\rapplicationID\"\\\n\x1eGetInfluxDBIntegrationResponse\x12:\n\x0bi\
    ntegration\x18\x01\x20\x01(\x0b2\x18.api.InfluxDBIntegrationR\x0bintegra\
    tion\"^\n\x20UpdateInfluxDBIntegrationRequest\x12:\n\x0bintegration\x18\
    \x01\x20\x01(\x0b2\x18.api.InfluxDBIntegrationR\x0bintegration\"I\n\x20D\
    eleteInfluxDBIntegrationRequest\x12%\n\x0eapplication_id\x18\x01\x20\x01\
    (\x03R\rapplicationID\"W\n\x16ThingsBoardIntegration\x12%\n\x0eapplicati\
    on_id\x18\x01\x20\x01(\x03R\rapplicationID\x12\x16\n\x06server\x18\x02\
    \x20\x01(\tR\x06server\"d\n#CreateThingsBoardIntegrationRequest\x12=\n\
    \x0bintegration\x18\x01\x20\x01(\x0b2\x1b.api.ThingsBoardIntegrationR\
    \x0bintegration\"I\n\x20GetThingsBoardIntegrationRequest\x12%\n\x0eappli\
    cation_id\x18\x01\x20\x01(\x03R\rapplicationID\"b\n!GetThingsBoardIntegr\
    ationResponse\x12=\n\x0bintegration\x18\x01\x20\x01(\x0b2\x1b.api.Things\
    BoardIntegrationR\x0bintegration\"d\n#UpdateThingsBoardIntegrationReques\
    t\x12=\n\x0bintegration\x18\x01\x20\x01(\x0b2\x1b.api.ThingsBoardIntegra\
    tionR\x0bintegration\"L\n#DeleteThingsBoardIntegrationRequest\x12%\n\x0e\
    application_id\x18\x01\x20\x01(\x03R\rapplicationID*:\n\x0fIntegrationKi\
    nd\x12\x08\n\x04HTTP\x10\0\x12\x0c\n\x08INFLUXDB\x10\x01\x12\x0f\n\x0bTH\
    INGSBOARD\x10\x02*?\n\x11InfluxDBPrecision\x12\x06\n\x02NS\x10\0\x12\x05\
    \n\x01U\x10\x01\x12\x06\n\x02MS\x10\x02\x12\x05\n\x01S\x10\x03\x12\x05\n\
    \x01M\x10\x04\x12\x05\n\x01H\x10\x052\xe9\x14\n\x12ApplicationService\
    \x12e\n\x06Create\x12\x1d.api.CreateApplicationRequest\x1a\x1e.api.Creat\
    eApplicationResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\"\x11/api/application\
    s:\x01*\x12^\n\x03Get\x12\x1a.api.GetApplicationRequest\x1a\x1b.api.GetA\
    pplicationResponse\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/api/application\
    s/{id}\x12n\n\x06Update\x12\x1d.api.UpdateApplicationRequest\x1a\x16.goo\
    gle.protobuf.Empty\"-\x82\xd3\xe4\x93\x02'\x1a\"/api/applications/{appli\
    cation.id}:\x01*\x12_\n\x06Delete\x12\x1d.api.DeleteApplicationRequest\
    \x1a\x16.google.protobuf.Empty\"\x1e\x82\xd3\xe4\x93\x02\x18*\x16/api/ap\
    plications/{id}\x12\\\n\x04List\x12\x1b.api.ListApplicationRequest\x1a\
    \x1c.api.ListApplicationResponse\"\x19\x82\xd3\xe4\x93\x02\x13\x12\x11/a\
    pi/applications\x12\x9f\x01\n\x15CreateHTTPIntegration\x12!.api.CreateHT\
    TPIntegrationRequest\x1a\x16.google.protobuf.Empty\"K\x82\xd3\xe4\x93\
    \x02E\"@/api/applications/{integration.application_id}/integrations/http\
    :\x01*\x12\x93\x01\n\x12GetHTTPIntegration\x12\x1e.api.GetHTTPIntegratio\
    nRequest\x1a\x1f.api.GetHTTPIntegrationResponse\"<\x82\xd3\xe4\x93\x026\
    \x124/api/applications/{application_id}/integrations/http\x12\x9f\x01\n\
    \x15UpdateHTTPIntegration\x12!.api.UpdateHTTPIntegrationRequest\x1a\x16.\
    google.protobuf.Empty\"K\x82\xd3\xe4\x93\x02E\x1a@/api/applications/{int\
    egration.application_id}/integrations/http:\x01*\x12\x90\x01\n\x15Delete\
    HTTPIntegration\x12!.api.DeleteHTTPIntegrationRequest\x1a\x16.google.pro\
    tobuf.Empty\"<\x82\xd3\xe4\x93\x026*4/api/applications/{application_id}/\
    integrations/http\x12\xab\x01\n\x19CreateInfluxDBIntegration\x12%.api.Cr\
    eateInfluxDBIntegrationRequest\x1a\x16.google.protobuf.Empty\"O\x82\xd3\
    \xe4\x93\x02I\"D/api/applications/{integration.application_id}/integrati\
    ons/influxdb:\x01*\x12\xa3\x01\n\x16GetInfluxDBIntegration\x12\".api.Get\
    InfluxDBIntegrationRequest\x1a#.api.GetInfluxDBIntegrationResponse\"@\
    \x82\xd3\xe4\x93\x02:\x128/api/applications/{application_id}/integration\
    s/influxdb\x12\xab\x01\n\x19UpdateInfluxDBIntegration\x12%.api.UpdateInf\
    luxDBIntegrationRequest\x1a\x16.google.protobuf.Empty\"O\x82\xd3\xe4\x93\
    \x02I\x1aD/api/applications/{integration.application_id}/integrations/in\
    fluxdb:\x01*\x12\x9c\x01\n\x19DeleteInfluxDBIntegration\x12%.api.DeleteI\
    nfluxDBIntegrationRequest\x1a\x16.google.protobuf.Empty\"@\x82\xd3\xe4\
    \x93\x02:*8/api/applications/{application_id}/integrations/influxdb\x12\
    \xb4\x01\n\x1cCreateThingsBoardIntegration\x12(.api.CreateThingsBoardInt\
    egrationRequest\x1a\x16.google.protobuf.Empty\"R\x82\xd3\xe4\x93\x02L\"G\
    /api/applications/{integration.application_id}/integrations/thingsboard:\
    \x01*\x12\xaf\x01\n\x19GetThingsBoardIntegration\x12%.api.GetThingsBoard\
    IntegrationRequest\x1a&.api.GetThingsBoardIntegrationResponse\"C\x82\xd3\
    \xe4\x93\x02=\x12;/api/applications/{application_id}/integrations/things\
    board\x12\xb4\x01\n\x1cUpdateThingsBoardIntegration\x12(.api.UpdateThing\
    sBoardIntegrationRequest\x1a\x16.google.protobuf.Empty\"R\x82\xd3\xe4\
    \x93\x02L\x1aG/api/applications/{integration.application_id}/integration\
    s/thingsboard:\x01*\x12\xa5\x01\n\x1cDeleteThingsBoardIntegration\x12(.a\
    pi.DeleteThingsBoardIntegrationRequest\x1a\x16.google.protobuf.Empty\"C\
    \x82\xd3\xe4\x93\x02=*;/api/applications/{application_id}/integrations/t\
    hingsboard\x12\x86\x01\n\x10ListIntegrations\x12\x1b.api.ListIntegration\
    Request\x1a\x1c.api.ListIntegrationResponse\"7\x82\xd3\xe4\x93\x021\x12/\
    /api/applications/{application_id}/integrationsB9Z7github.com/brocaar/ch\
    irpstack-api/go/v3/as/external/apiJ\xeba\n\x07\x12\x05\0\0\xab\x03\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x0b\n\x08\
    \n\x01\x08\x12\x03\x04\0N\n\t\n\x02\x08\x0b\x12\x03\x04\0N\n\t\n\x02\x03\
    \0\x12\x03\x06\x07%\n\t\n\x02\x03\x01\x12\x03\x07\x07$\nG\n\x02\x06\0\
    \x12\x05\n\0\x90\x01\x01\x1a:\x20ApplicationService\x20is\x20the\x20serv\
    ice\x20managing\x20applications.\n\n\n\n\x03\x06\0\x01\x12\x03\n\x08\x1a\
    \n5\n\x04\x06\0\x02\0\x12\x04\x0c\x08\x11\t\x1a'\x20Create\x20creates\
    \x20the\x20given\x20application.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\
    \x0c\x0c\x12\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0c\x13+\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03\x0c6O\n\r\n\x05\x06\0\x02\0\x04\x12\x04\r\x10\
    \x10\x12\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04\r\x10\x10\x12\n\
    6\n\x04\x06\0\x02\x01\x12\x04\x14\x08\x18\t\x1a(\x20Get\x20returns\x20th\
    e\x20requested\x20application.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\
    \x14\x0c\x0f\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x14\x10%\n\x0c\n\x05\
    \x06\0\x02\x01\x03\x12\x03\x140F\n\r\n\x05\x06\0\x02\x01\x04\x12\x04\x15\
    \x10\x17\x12\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04\x15\x10\
    \x17\x12\n5\n\x04\x06\0\x02\x02\x12\x04\x1b\x08\x20\t\x1a'\x20Update\x20\
    updates\x20the\x20given\x20application.\n\n\x0c\n\x05\x06\0\x02\x02\x01\
    \x12\x03\x1b\x0c\x12\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1b\x13+\n\
    \x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1b6K\n\r\n\x05\x06\0\x02\x02\x04\
    \x12\x04\x1c\x10\x1f\x12\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\
    \x04\x1c\x10\x1f\x12\n5\n\x04\x06\0\x02\x03\x12\x04#\x08'\t\x1a'\x20Dele\
    te\x20deletes\x20the\x20given\x20application.\n\n\x0c\n\x05\x06\0\x02\
    \x03\x01\x12\x03#\x0c\x12\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03#\x13+\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03#6K\n\r\n\x05\x06\0\x02\x03\x04\x12\
    \x04$\x10&\x12\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04$\x10&\
    \x12\n6\n\x04\x06\0\x02\x04\x12\x04*\x08.\t\x1a(\x20List\x20lists\x20the\
    \x20available\x20applications.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03*\
    \x0c\x10\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03*\x11'\n\x0c\n\x05\x06\0\
    \x02\x04\x03\x12\x03*2I\n\r\n\x05\x06\0\x02\x04\x04\x12\x04+\x10-\x12\n\
    \x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04+\x10-\x12\nM\n\x04\x06\
    \0\x02\x05\x12\x041\x086\t\x1a?\x20CreateHTTPIntegration\x20creates\x20a\
    \x20HTTP\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\
    \x031\x0c!\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x031\">\n\x0c\n\x05\x06\0\
    \x02\x05\x03\x12\x031I^\n\r\n\x05\x06\0\x02\x05\x04\x12\x042\x105\x12\n\
    \x11\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x042\x105\x12\nL\n\x04\x06\
    \0\x02\x06\x12\x049\x08=\t\x1a>\x20GetHTTPIntegration\x20returns\x20the\
    \x20HTTP\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\
    \x039\x0c\x1e\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x039\x1f8\n\x0c\n\x05\
    \x06\0\x02\x06\x03\x12\x039C]\n\r\n\x05\x06\0\x02\x06\x04\x12\x04:\x10<\
    \x12\n\x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04:\x10<\x12\nO\n\
    \x04\x06\0\x02\x07\x12\x04@\x08E\t\x1aA\x20UpdateHTTPIntegration\x20upda\
    tes\x20the\x20HTTP\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\
    \x07\x01\x12\x03@\x0c!\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03@\">\n\x0c\n\
    \x05\x06\0\x02\x07\x03\x12\x03@I^\n\r\n\x05\x06\0\x02\x07\x04\x12\x04A\
    \x10D\x12\n\x11\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x04A\x10D\x12\nK\
    \n\x04\x06\0\x02\x08\x12\x04H\x08L\t\x1a=\x20DeleteIntegration\x20delete\
    s\x20the\x20HTTP\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\x08\
    \x01\x12\x03H\x0c!\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03H\">\n\x0c\n\x05\
    \x06\0\x02\x08\x03\x12\x03HI^\n\r\n\x05\x06\0\x02\x08\x04\x12\x04I\x10K\
    \x12\n\x11\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x04I\x10K\x12\nU\n\
    \x04\x06\0\x02\t\x12\x04O\x08T\t\x1aG\x20CreateInfluxDBIntegration\x20cr\
    eate\x20an\x20InfluxDB\x20application-integration.\n\n\x0c\n\x05\x06\0\
    \x02\t\x01\x12\x03O\x0c%\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03O&F\n\x0c\n\
    \x05\x06\0\x02\t\x03\x12\x03OQf\n\r\n\x05\x06\0\x02\t\x04\x12\x04P\x10S\
    \x12\n\x11\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x04P\x10S\x12\nT\n\x04\
    \x06\0\x02\n\x12\x04W\x08[\t\x1aF\x20GetInfluxDBIntegration\x20returns\
    \x20the\x20InfluxDB\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\
    \n\x01\x12\x03W\x0c\"\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03W#@\n\x0c\n\x05\
    \x06\0\x02\n\x03\x12\x03WKi\n\r\n\x05\x06\0\x02\n\x04\x12\x04X\x10Z\x12\
    \n\x11\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x04X\x10Z\x12\nW\n\x04\x06\
    \0\x02\x0b\x12\x04^\x08c\t\x1aI\x20UpdateInfluxDBIntegration\x20updates\
    \x20the\x20InfluxDB\x20application-integration.\n\n\x0c\n\x05\x06\0\x02\
    \x0b\x01\x12\x03^\x0c%\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03^&F\n\x0c\n\
    \x05\x06\0\x02\x0b\x03\x12\x03^Qf\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04_\
    \x10b\x12\n\x11\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x04_\x10b\x12\nW\
    \n\x04\x06\0\x02\x0c\x12\x04f\x08j\t\x1aI\x20DeleteInfluxDBIntegration\
    \x20deletes\x20the\x20InfluxDB\x20application-integration.\n\n\x0c\n\x05\
    \x06\0\x02\x0c\x01\x12\x03f\x0c%\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03f&\
    F\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03fQf\n\r\n\x05\x06\0\x02\x0c\x04\
    \x12\x04g\x10i\x12\n\x11\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x04g\
    \x10i\x12\n[\n\x04\x06\0\x02\r\x12\x04m\x04r\x05\x1aM\x20CreateThingsBoa\
    rdIntegration\x20creates\x20a\x20ThingsBoard\x20application-integration.\
    \n\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03m\x08$\n\x0c\n\x05\x06\0\x02\r\x02\
    \x12\x03m%H\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03mSh\n\r\n\x05\x06\0\x02\r\
    \x04\x12\x04n\x08q\n\n\x11\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x04n\
    \x08q\n\nZ\n\x04\x06\0\x02\x0e\x12\x04u\x04y\x05\x1aL\x20GetThingsBoardI\
    ntegration\x20returns\x20the\x20ThingsBoard\x20application-integration.\
    \n\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03u\x08!\n\x0c\n\x05\x06\0\x02\x0e\
    \x02\x12\x03u\"B\n\x0c\n\x05\x06\0\x02\x0e\x03\x12\x03uMn\n\r\n\x05\x06\
    \0\x02\x0e\x04\x12\x04v\x08x\n\n\x11\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\
    \x12\x04v\x08x\n\n^\n\x04\x06\0\x02\x0f\x12\x05|\x04\x81\x01\x05\x1aO\
    \x20UpdateThingsBoardIntegration\x20updates\x20the\x20ThingsBoard\x20app\
    lication-integration.\n\n\x0c\n\x05\x06\0\x02\x0f\x01\x12\x03|\x08$\n\
    \x0c\n\x05\x06\0\x02\x0f\x02\x12\x03|%H\n\x0c\n\x05\x06\0\x02\x0f\x03\
    \x12\x03|Sh\n\x0e\n\x05\x06\0\x02\x0f\x04\x12\x05}\x08\x80\x01\n\n\x12\n\
    \t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x05}\x08\x80\x01\n\n_\n\x04\x06\0\
    \x02\x10\x12\x06\x84\x01\x04\x88\x01\x05\x1aO\x20DeleteThingsBoardIntegr\
    ation\x20deletes\x20the\x20ThingsBoard\x20application-integration.\n\n\r\
    \n\x05\x06\0\x02\x10\x01\x12\x04\x84\x01\x08$\n\r\n\x05\x06\0\x02\x10\
    \x02\x12\x04\x84\x01%H\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\x84\x01Sh\n\
    \x0f\n\x05\x06\0\x02\x10\x04\x12\x06\x85\x01\x08\x87\x01\n\n\x13\n\t\x06\
    \0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\x85\x01\x08\x87\x01\n\nE\n\x04\x06\
    \0\x02\x11\x12\x06\x8b\x01\x08\x8f\x01\t\x1a5\x20ListIntegrations\x20lis\
    ts\x20all\x20configured\x20integrations.\n\n\r\n\x05\x06\0\x02\x11\x01\
    \x12\x04\x8b\x01\x0c\x1c\n\r\n\x05\x06\0\x02\x11\x02\x12\x04\x8b\x01\x1d\
    3\n\r\n\x05\x06\0\x02\x11\x03\x12\x04\x8b\x01>U\n\x0f\n\x05\x06\0\x02\
    \x11\x04\x12\x06\x8c\x01\x10\x8e\x01\x12\n\x13\n\t\x06\0\x02\x11\x04\xb0\
    \xca\xbc\"\x12\x06\x8c\x01\x10\x8e\x01\x12\n\x0c\n\x02\x05\0\x12\x06\x92\
    \x01\0\x96\x01\x01\n\x0b\n\x03\x05\0\x01\x12\x04\x92\x01\x05\x14\n\x0c\n\
    \x04\x05\0\x02\0\x12\x04\x93\x01\x08\x11\n\r\n\x05\x05\0\x02\0\x01\x12\
    \x04\x93\x01\x08\x0c\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x93\x01\x0f\x10\n\
    \x0c\n\x04\x05\0\x02\x01\x12\x04\x94\x01\x08\x15\n\r\n\x05\x05\0\x02\x01\
    \x01\x12\x04\x94\x01\x08\x10\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x94\x01\
    \x13\x14\n\x0c\n\x04\x05\0\x02\x02\x12\x04\x95\x01\x04\x14\n\r\n\x05\x05\
    \0\x02\x02\x01\x12\x04\x95\x01\x04\x0f\n\r\n\x05\x05\0\x02\x02\x02\x12\
    \x04\x95\x01\x12\x13\n\x0c\n\x02\x04\0\x12\x06\x98\x01\0\xbb\x01\x01\n\
    \x0b\n\x03\x04\0\x01\x12\x04\x98\x01\x08\x13\nO\n\x04\x04\0\x02\0\x12\
    \x04\x9b\x01\x08\x15\x1aA\x20Application\x20ID.\n\x20This\x20will\x20be\
    \x20automatically\x20assigned\x20on\x20create.\n\n\x0f\n\x05\x04\0\x02\0\
    \x04\x12\x06\x9b\x01\x08\x98\x01\x15\n\r\n\x05\x04\0\x02\0\x05\x12\x04\
    \x9b\x01\x08\r\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x9b\x01\x0e\x10\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\x9b\x01\x13\x14\n9\n\x04\x04\0\x02\x01\x12\
    \x04\x9e\x01\x08\x18\x1a+\x20Name\x20of\x20the\x20application\x20(must\
    \x20be\x20unique).\n\n\x0f\n\x05\x04\0\x02\x01\x04\x12\x06\x9e\x01\x08\
    \x9b\x01\x15\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x9e\x01\x08\x0e\n\r\n\
    \x05\x04\0\x02\x01\x01\x12\x04\x9e\x01\x0f\x13\n\r\n\x05\x04\0\x02\x01\
    \x03\x12\x04\x9e\x01\x16\x17\n/\n\x04\x04\0\x02\x02\x12\x04\xa1\x01\x08\
    \x1f\x1a!\x20Description\x20of\x20the\x20application.\n\n\x0f\n\x05\x04\
    \0\x02\x02\x04\x12\x06\xa1\x01\x08\x9e\x01\x18\n\r\n\x05\x04\0\x02\x02\
    \x05\x12\x04\xa1\x01\x08\x0e\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\xa1\x01\
    \x0f\x1a\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xa1\x01\x1d\x1e\nq\n\x04\
    \x04\0\x02\x03\x12\x04\xa5\x01\x08A\x1ac\x20ID\x20of\x20the\x20organizat\
    ion\x20to\x20which\x20the\x20application\x20belongs.\n\x20After\x20creat\
    e,\x20this\x20can\x20not\x20be\x20modified.\n\n\x0f\n\x05\x04\0\x02\x03\
    \x04\x12\x06\xa5\x01\x08\xa1\x01\x1f\n\r\n\x05\x04\0\x02\x03\x05\x12\x04\
    \xa5\x01\x08\r\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\xa5\x01\x0e\x1d\n\r\n\
    \x05\x04\0\x02\x03\x03\x12\x04\xa5\x01\x20!\n\r\n\x05\x04\0\x02\x03\x08\
    \x12\x04\xa5\x01\"@\n\r\n\x05\x04\0\x02\x03\n\x12\x04\xa5\x01/?\n*\n\x04\
    \x04\0\x02\x04\x12\x04\xa8\x01\x08G\x1a\x1c\x20ID\x20of\x20the\x20servic\
    e\x20profile.\n\n\x0f\n\x05\x04\0\x02\x04\x04\x12\x06\xa8\x01\x08\xa5\
    \x01A\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\xa8\x01\x08\x0e\n\r\n\x05\x04\
    \0\x02\x04\x01\x12\x04\xa8\x01\x0f!\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\
    \xa8\x01$%\n\r\n\x05\x04\0\x02\x04\x08\x12\x04\xa8\x01&F\n\r\n\x05\x04\0\
    \x02\x04\n\x12\x04\xa8\x013E\n\xe5\x01\n\x04\x04\0\x02\x05\x12\x04\xae\
    \x01\x08!\x1a\xd6\x01\x20Payload\x20codec.\n\x20NOTE:\x20These\x20field\
    \x20have\x20moved\x20to\x20the\x20device-profile\x20and\x20will\x20be\
    \x20removed\n\x20in\x20the\x20next\x20major\x20release.\x20When\x20set,\
    \x20the\x20device-profile\x20payload_\x20fields\n\x20have\x20priority\
    \x20over\x20the\x20application\x20payload_\x20fields.\n\n\x0f\n\x05\x04\
    \0\x02\x05\x04\x12\x06\xae\x01\x08\xa8\x01G\n\r\n\x05\x04\0\x02\x05\x05\
    \x12\x04\xae\x01\x08\x0e\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xae\x01\x0f\
    \x1c\n\r\n\x05\x04\0\x02\x05\x03\x12\x04\xae\x01\x1f\x20\n\xee\x01\n\x04\
    \x04\0\x02\x06\x12\x04\xb4\x01\x08*\x1a\xdf\x01\x20Payload\x20encoder\
    \x20script.\n\x20NOTE:\x20These\x20field\x20have\x20moved\x20to\x20the\
    \x20device-profile\x20and\x20will\x20be\x20removed\n\x20in\x20the\x20nex\
    t\x20major\x20release.\x20When\x20set,\x20the\x20device-profile\x20paylo\
    ad_\x20fields\n\x20have\x20priority\x20over\x20the\x20application\x20pay\
    load_\x20fields.\n\n\x0f\n\x05\x04\0\x02\x06\x04\x12\x06\xb4\x01\x08\xae\
    \x01!\n\r\n\x05\x04\0\x02\x06\x05\x12\x04\xb4\x01\x08\x0e\n\r\n\x05\x04\
    \0\x02\x06\x01\x12\x04\xb4\x01\x0f%\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\
    \xb4\x01()\n\xee\x01\n\x04\x04\0\x02\x07\x12\x04\xba\x01\x08*\x1a\xdf\
    \x01\x20Payload\x20decoder\x20script.\n\x20NOTE:\x20These\x20field\x20ha\
    ve\x20moved\x20to\x20the\x20device-profile\x20and\x20will\x20be\x20remov\
    ed\n\x20in\x20the\x20next\x20major\x20release.\x20When\x20set,\x20the\
    \x20device-profile\x20payload_\x20fields\n\x20have\x20priority\x20over\
    \x20the\x20application\x20payload_\x20fields.\n\n\x0f\n\x05\x04\0\x02\
    \x07\x04\x12\x06\xba\x01\x08\xb4\x01*\n\r\n\x05\x04\0\x02\x07\x05\x12\
    \x04\xba\x01\x08\x0e\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xba\x01\x0f%\n\
    \r\n\x05\x04\0\x02\x07\x03\x12\x04\xba\x01()\n\x0c\n\x02\x04\x01\x12\x06\
    \xbd\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\xbd\x01\x08\x1b\n\
    \x1f\n\x04\x04\x01\x02\0\x12\x04\xbf\x01\x08\x15\x1a\x11\x20Application\
    \x20ID.\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xbf\x01\x08\xbd\x01\x1d\
    \n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xbf\x01\x08\r\n\r\n\x05\x04\x01\x02\
    \0\x01\x12\x04\xbf\x01\x0e\x10\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xbf\
    \x01\x13\x14\n(\n\x04\x04\x01\x02\x01\x12\x04\xc2\x01\x08\x18\x1a\x1a\
    \x20Name\x20of\x20the\x20application.\n\n\x0f\n\x05\x04\x01\x02\x01\x04\
    \x12\x06\xc2\x01\x08\xbf\x01\x15\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\
    \xc2\x01\x08\x0e\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc2\x01\x0f\x13\n\
    \r\n\x05\x04\x01\x02\x01\x03\x12\x04\xc2\x01\x16\x17\n/\n\x04\x04\x01\
    \x02\x02\x12\x04\xc5\x01\x08\x1f\x1a!\x20Description\x20of\x20the\x20app\
    lication.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\x12\x06\xc5\x01\x08\xc2\x01\
    \x18\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xc5\x01\x08\x0e\n\r\n\x05\x04\
    \x01\x02\x02\x01\x12\x04\xc5\x01\x0f\x1a\n\r\n\x05\x04\x01\x02\x02\x03\
    \x12\x04\xc5\x01\x1d\x1e\nH\n\x04\x04\x01\x02\x03\x12\x04\xc8\x01\x08A\
    \x1a:\x20ID\x20of\x20the\x20organization\x20to\x20which\x20the\x20applic\
    ation\x20belongs.\n\n\x0f\n\x05\x04\x01\x02\x03\x04\x12\x06\xc8\x01\x08\
    \xc5\x01\x1f\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\xc8\x01\x08\r\n\r\n\
    \x05\x04\x01\x02\x03\x01\x12\x04\xc8\x01\x0e\x1d\n\r\n\x05\x04\x01\x02\
    \x03\x03\x12\x04\xc8\x01\x20!\n\r\n\x05\x04\x01\x02\x03\x08\x12\x04\xc8\
    \x01\"@\n\r\n\x05\x04\x01\x02\x03\n\x12\x04\xc8\x01/?\n*\n\x04\x04\x01\
    \x02\x04\x12\x04\xcb\x01\x08G\x1a\x1c\x20ID\x20of\x20the\x20service\x20p\
    rofile.\n\n\x0f\n\x05\x04\x01\x02\x04\x04\x12\x06\xcb\x01\x08\xc8\x01A\n\
    \r\n\x05\x04\x01\x02\x04\x05\x12\x04\xcb\x01\x08\x0e\n\r\n\x05\x04\x01\
    \x02\x04\x01\x12\x04\xcb\x01\x0f!\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\
    \xcb\x01$%\n\r\n\x05\x04\x01\x02\x04\x08\x12\x04\xcb\x01&F\n\r\n\x05\x04\
    \x01\x02\x04\n\x12\x04\xcb\x013E\n%\n\x04\x04\x01\x02\x05\x12\x04\xce\
    \x01\x08(\x1a\x17\x20Service-profile\x20name.\n\n\x0f\n\x05\x04\x01\x02\
    \x05\x04\x12\x06\xce\x01\x08\xcb\x01G\n\r\n\x05\x04\x01\x02\x05\x05\x12\
    \x04\xce\x01\x08\x0e\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\xce\x01\x0f#\
    \n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\xce\x01&'\n\x0c\n\x02\x04\x02\x12\
    \x06\xd2\x01\0\xd5\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\xd2\x01\x08\
    \x20\n-\n\x04\x04\x02\x02\0\x12\x04\xd4\x01\x08$\x1a\x1f\x20Application\
    \x20object\x20to\x20create.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xd4\
    \x01\x08\xd2\x01\"\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xd4\x01\x08\x13\n\
    \r\n\x05\x04\x02\x02\0\x01\x12\x04\xd4\x01\x14\x1f\n\r\n\x05\x04\x02\x02\
    \0\x03\x12\x04\xd4\x01\"#\n\x0c\n\x02\x04\x03\x12\x06\xd7\x01\0\xda\x01\
    \x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xd7\x01\x08!\n\x1f\n\x04\x04\x03\
    \x02\0\x12\x04\xd9\x01\x08\x15\x1a\x11\x20Application\x20ID.\n\n\x0f\n\
    \x05\x04\x03\x02\0\x04\x12\x06\xd9\x01\x08\xd7\x01#\n\r\n\x05\x04\x03\
    \x02\0\x05\x12\x04\xd9\x01\x08\r\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xd9\
    \x01\x0e\x10\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xd9\x01\x13\x14\n\x0c\n\
    \x02\x04\x04\x12\x06\xdc\x01\0\xdf\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\
    \x04\xdc\x01\x08\x1d\n\x1f\n\x04\x04\x04\x02\0\x12\x04\xde\x01\x08\x15\
    \x1a\x11\x20Application\x20ID.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\
    \xde\x01\x08\xdc\x01\x1f\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xde\x01\x08\
    \r\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xde\x01\x0e\x10\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xde\x01\x13\x14\n\x0c\n\x02\x04\x05\x12\x06\xe1\x01\0\
    \xe4\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xe1\x01\x08\x1e\n#\n\x04\
    \x04\x05\x02\0\x12\x04\xe3\x01\x08$\x1a\x15\x20Application\x20object.\n\
    \n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xe3\x01\x08\xe1\x01\x20\n\r\n\x05\
    \x04\x05\x02\0\x06\x12\x04\xe3\x01\x08\x13\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\xe3\x01\x14\x1f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xe3\x01\"#\
    \n\x0c\n\x02\x04\x06\x12\x06\xe6\x01\0\xe9\x01\x01\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\xe6\x01\x08\x20\n-\n\x04\x04\x06\x02\0\x12\x04\xe8\x01\x08$\
    \x1a\x1f\x20Application\x20object\x20to\x20update.\n\n\x0f\n\x05\x04\x06\
    \x02\0\x04\x12\x06\xe8\x01\x08\xe6\x01\"\n\r\n\x05\x04\x06\x02\0\x06\x12\
    \x04\xe8\x01\x08\x13\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xe8\x01\x14\x1f\
    \n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xe8\x01\"#\n\x0c\n\x02\x04\x07\x12\
    \x06\xeb\x01\0\xee\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xeb\x01\x08\
    \x20\n\x1f\n\x04\x04\x07\x02\0\x12\x04\xed\x01\x08\x15\x1a\x11\x20Applic\
    ation\x20ID.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xed\x01\x08\xeb\x01\
    \"\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xed\x01\x08\r\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\xed\x01\x0e\x10\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\
    \xed\x01\x13\x14\n\x0c\n\x02\x04\x08\x12\x06\xf0\x01\0\xfc\x01\x01\n\x0b\
    \n\x03\x04\x08\x01\x12\x04\xf0\x01\x08\x1e\nH\n\x04\x04\x08\x02\0\x12\
    \x04\xf2\x01\x08\x18\x1a:\x20Max\x20number\x20of\x20applications\x20to\
    \x20return\x20in\x20the\x20result-test.\n\n\x0f\n\x05\x04\x08\x02\0\x04\
    \x12\x06\xf2\x01\x08\xf0\x01\x20\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xf2\
    \x01\x08\r\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xf2\x01\x0e\x13\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xf2\x01\x16\x17\n:\n\x04\x04\x08\x02\x01\x12\
    \x04\xf5\x01\x08\x19\x1a,\x20Offset\x20in\x20the\x20result-set\x20(for\
    \x20pagination).\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xf5\x01\x08\
    \xf2\x01\x18\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xf5\x01\x08\r\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\xf5\x01\x0e\x14\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xf5\x01\x17\x18\n4\n\x04\x04\x08\x02\x02\x12\x04\xf8\
    \x01\x08A\x1a&\x20ID\x20of\x20the\x20organization\x20to\x20filter\x20on.\
    \n\n\x0f\n\x05\x04\x08\x02\x02\x04\x12\x06\xf8\x01\x08\xf5\x01\x19\n\r\n\
    \x05\x04\x08\x02\x02\x05\x12\x04\xf8\x01\x08\r\n\r\n\x05\x04\x08\x02\x02\
    \x01\x12\x04\xf8\x01\x0e\x1d\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xf8\
    \x01\x20!\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\xf8\x01\"@\n\r\n\x05\x04\
    \x08\x02\x02\n\x12\x04\xf8\x01/?\n*\n\x04\x04\x08\x02\x03\x12\x04\xfb\
    \x01\x08\x1a\x1a\x1c\x20Search\x20on\x20name\x20(optional).\n\n\x0f\n\
    \x05\x04\x08\x02\x03\x04\x12\x06\xfb\x01\x08\xf8\x01A\n\r\n\x05\x04\x08\
    \x02\x03\x05\x12\x04\xfb\x01\x08\x0e\n\r\n\x05\x04\x08\x02\x03\x01\x12\
    \x04\xfb\x01\x0f\x15\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xfb\x01\x18\
    \x19\n\x0c\n\x02\x04\t\x12\x06\xfe\x01\0\x84\x02\x01\n\x0b\n\x03\x04\t\
    \x01\x12\x04\xfe\x01\x08\x1f\nM\n\x04\x04\t\x02\0\x12\x04\x80\x02\x08\
    \x1e\x1a?\x20Total\x20number\x20of\x20applications\x20available\x20withi\
    n\x20the\x20result-set.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\x80\x02\
    \x08\xfe\x01!\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x80\x02\x08\r\n\r\n\x05\
    \x04\t\x02\0\x01\x12\x04\x80\x02\x0e\x19\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\x80\x02\x1c\x1d\n4\n\x04\x04\t\x02\x01\x12\x04\x83\x02\x080\x1a&\
    \x20Applications\x20within\x20this\x20result-set.\n\n\r\n\x05\x04\t\x02\
    \x01\x04\x12\x04\x83\x02\x08\x10\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\x83\
    \x02\x11$\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x83\x02%+\n\r\n\x05\x04\t\
    \x02\x01\x03\x12\x04\x83\x02./\n\x0c\n\x02\x04\n\x12\x06\x86\x02\0\x8c\
    \x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\x86\x02\x08\x1d\n\x13\n\x04\x04\n\
    \x02\0\x12\x04\x88\x02\x08\x17\x1a\x05\x20Key\n\n\x0f\n\x05\x04\n\x02\0\
    \x04\x12\x06\x88\x02\x08\x86\x02\x1f\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \x88\x02\x08\x0e\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x88\x02\x0f\x12\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\x88\x02\x15\x16\n\x15\n\x04\x04\n\x02\x01\
    \x12\x04\x8b\x02\x08\x19\x1a\x07\x20Value\n\n\x0f\n\x05\x04\n\x02\x01\
    \x04\x12\x06\x8b\x02\x08\x88\x02\x17\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \x8b\x02\x08\x0e\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x8b\x02\x0f\x14\n\r\
    \n\x05\x04\n\x02\x01\x03\x12\x04\x8b\x02\x17\x18\n\x0c\n\x02\x04\x0b\x12\
    \x06\x8e\x02\0\xa6\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x8e\x02\x08\
    \x17\n*\n\x04\x04\x0b\x02\0\x12\x04\x90\x02\x08?\x1a\x1c\x20The\x20id\
    \x20of\x20the\x20application.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\
    \x90\x02\x08\x8e\x02\x19\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x90\x02\x08\
    \r\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x90\x02\x0e\x1c\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\x90\x02\x1f\x20\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\
    \x90\x02!>\n\r\n\x05\x04\x0b\x02\0\n\x12\x04\x90\x02.=\n>\n\x04\x04\x0b\
    \x02\x01\x12\x04\x93\x02\x083\x1a0\x20The\x20headers\x20to\x20use\x20whe\
    n\x20making\x20HTTP\x20callbacks.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\
    \x04\x93\x02\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\x93\x02\x11&\
    \n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x93\x02'.\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\x93\x0212\n0\n\x04\x04\x0b\x02\x02\x12\x04\x96\x02\x08A\
    \x1a\"\x20The\x20URL\x20to\x20call\x20for\x20uplink\x20data.\n\n\x0f\n\
    \x05\x04\x0b\x02\x02\x04\x12\x06\x96\x02\x08\x93\x023\n\r\n\x05\x04\x0b\
    \x02\x02\x05\x12\x04\x96\x02\x08\x0e\n\r\n\x05\x04\x0b\x02\x02\x01\x12\
    \x04\x96\x02\x0f\x1e\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x96\x02!\"\n\
    \r\n\x05\x04\x0b\x02\x02\x08\x12\x04\x96\x02#@\n\r\n\x05\x04\x0b\x02\x02\
    \n\x12\x04\x96\x020?\n7\n\x04\x04\x0b\x02\x03\x12\x04\x99\x02\x08M\x1a)\
    \x20The\x20URL\x20to\x20call\x20for\x20join\x20notifications.\n\n\x0f\n\
    \x05\x04\x0b\x02\x03\x04\x12\x06\x99\x02\x08\x96\x02A\n\r\n\x05\x04\x0b\
    \x02\x03\x05\x12\x04\x99\x02\x08\x0e\n\r\n\x05\x04\x0b\x02\x03\x01\x12\
    \x04\x99\x02\x0f$\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x99\x02'(\n\r\n\
    \x05\x04\x0b\x02\x03\x08\x12\x04\x99\x02)L\n\r\n\x05\x04\x0b\x02\x03\n\
    \x12\x04\x99\x026K\nT\n\x04\x04\x0b\x02\x04\x12\x04\x9c\x02\x08K\x1aF\
    \x20The\x20URL\x20to\x20call\x20for\x20ACK\x20notifications\x20(for\x20c\
    onfirmed\x20downlink\x20data).\n\n\x0f\n\x05\x04\x0b\x02\x04\x04\x12\x06\
    \x9c\x02\x08\x99\x02M\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x9c\x02\x08\
    \x0e\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x9c\x02\x0f#\n\r\n\x05\x04\
    \x0b\x02\x04\x03\x12\x04\x9c\x02&'\n\r\n\x05\x04\x0b\x02\x04\x08\x12\x04\
    \x9c\x02(J\n\r\n\x05\x04\x0b\x02\x04\n\x12\x04\x9c\x025I\n8\n\x04\x04\
    \x0b\x02\x05\x12\x04\x9f\x02\x08O\x1a*\x20The\x20URL\x20to\x20call\x20fo\
    r\x20error\x20notifications.\n\n\x0f\n\x05\x04\x0b\x02\x05\x04\x12\x06\
    \x9f\x02\x08\x9c\x02K\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x9f\x02\x08\
    \x0e\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x9f\x02\x0f%\n\r\n\x05\x04\
    \x0b\x02\x05\x03\x12\x04\x9f\x02()\n\r\n\x05\x04\x0b\x02\x05\x08\x12\x04\
    \x9f\x02*N\n\r\n\x05\x04\x0b\x02\x05\n\x12\x04\x9f\x027M\n@\n\x04\x04\
    \x0b\x02\x06\x12\x04\xa2\x02\x08Q\x1a2\x20The\x20URL\x20to\x20call\x20fo\
    r\x20device-status\x20notifications.\n\n\x0f\n\x05\x04\x0b\x02\x06\x04\
    \x12\x06\xa2\x02\x08\x9f\x02O\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xa2\
    \x02\x08\x0e\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\xa2\x02\x0f&\n\r\n\
    \x05\x04\x0b\x02\x06\x03\x12\x04\xa2\x02)*\n\r\n\x05\x04\x0b\x02\x06\x08\
    \x12\x04\xa2\x02+P\n\r\n\x05\x04\x0b\x02\x06\n\x12\x04\xa2\x028O\n;\n\
    \x04\x04\x0b\x02\x07\x12\x04\xa5\x02\x08U\x1a-\x20The\x20URL\x20to\x20ca\
    ll\x20for\x20location\x20notifications.\n\n\x0f\n\x05\x04\x0b\x02\x07\
    \x04\x12\x06\xa5\x02\x08\xa2\x02Q\n\r\n\x05\x04\x0b\x02\x07\x05\x12\x04\
    \xa5\x02\x08\x0e\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\xa5\x02\x0f(\n\r\
    \n\x05\x04\x0b\x02\x07\x03\x12\x04\xa5\x02+,\n\r\n\x05\x04\x0b\x02\x07\
    \x08\x12\x04\xa5\x02-T\n\r\n\x05\x04\x0b\x02\x07\n\x12\x04\xa5\x02:S\n\
    \x0c\n\x02\x04\x0c\x12\x06\xa8\x02\0\xab\x02\x01\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\xa8\x02\x08$\n-\n\x04\x04\x0c\x02\0\x12\x04\xaa\x02\x08(\x1a\
    \x1f\x20Integration\x20object\x20to\x20create.\n\n\x0f\n\x05\x04\x0c\x02\
    \0\x04\x12\x06\xaa\x02\x08\xa8\x02&\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\
    \xaa\x02\x08\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xaa\x02\x18#\n\r\n\
    \x05\x04\x0c\x02\0\x03\x12\x04\xaa\x02&'\n\x0c\n\x02\x04\r\x12\x06\xad\
    \x02\0\xb0\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xad\x02\x08!\n\x1f\n\
    \x04\x04\r\x02\0\x12\x04\xaf\x02\x08?\x1a\x11\x20Application\x20ID.\n\n\
    \x0f\n\x05\x04\r\x02\0\x04\x12\x06\xaf\x02\x08\xad\x02#\n\r\n\x05\x04\r\
    \x02\0\x05\x12\x04\xaf\x02\x08\r\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xaf\
    \x02\x0e\x1c\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xaf\x02\x1f\x20\n\r\n\x05\
    \x04\r\x02\0\x08\x12\x04\xaf\x02!>\n\r\n\x05\x04\r\x02\0\n\x12\x04\xaf\
    \x02.=\n\x0c\n\x02\x04\x0e\x12\x06\xb2\x02\0\xb5\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xb2\x02\x08\"\n#\n\x04\x04\x0e\x02\0\x12\x04\xb4\x02\
    \x08(\x1a\x15\x20Integration\x20object.\n\n\x0f\n\x05\x04\x0e\x02\0\x04\
    \x12\x06\xb4\x02\x08\xb2\x02$\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xb4\
    \x02\x08\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xb4\x02\x18#\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xb4\x02&'\n\x0c\n\x02\x04\x0f\x12\x06\xb7\x02\
    \0\xba\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xb7\x02\x08$\n-\n\x04\x04\
    \x0f\x02\0\x12\x04\xb9\x02\x08(\x1a\x1f\x20Integration\x20object\x20to\
    \x20update.\n\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\x06\xb9\x02\x08\xb7\x02&\
    \n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xb9\x02\x08\x17\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\xb9\x02\x18#\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xb9\
    \x02&'\n\x0c\n\x02\x04\x10\x12\x06\xbc\x02\0\xbf\x02\x01\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\xbc\x02\x08$\n*\n\x04\x04\x10\x02\0\x12\x04\xbe\x02\x08\
    ?\x1a\x1c\x20The\x20id\x20of\x20the\x20application.\n\n\x0f\n\x05\x04\
    \x10\x02\0\x04\x12\x06\xbe\x02\x08\xbc\x02&\n\r\n\x05\x04\x10\x02\0\x05\
    \x12\x04\xbe\x02\x08\r\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xbe\x02\x0e\
    \x1c\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xbe\x02\x1f\x20\n\r\n\x05\x04\
    \x10\x02\0\x08\x12\x04\xbe\x02!>\n\r\n\x05\x04\x10\x02\0\n\x12\x04\xbe\
    \x02.=\n\x0c\n\x02\x04\x11\x12\x06\xc1\x02\0\xc4\x02\x01\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\xc1\x02\x08\x1e\n*\n\x04\x04\x11\x02\0\x12\x04\xc3\x02\
    \x08?\x1a\x1c\x20The\x20id\x20of\x20the\x20application.\n\n\x0f\n\x05\
    \x04\x11\x02\0\x04\x12\x06\xc3\x02\x08\xc1\x02\x20\n\r\n\x05\x04\x11\x02\
    \0\x05\x12\x04\xc3\x02\x08\r\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xc3\x02\
    \x0e\x1c\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc3\x02\x1f\x20\n\r\n\x05\
    \x04\x11\x02\0\x08\x12\x04\xc3\x02!>\n\r\n\x05\x04\x11\x02\0\n\x12\x04\
    \xc3\x02.=\n\x0c\n\x02\x04\x12\x12\x06\xc6\x02\0\xc9\x02\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xc6\x02\x08\x1b\n!\n\x04\x04\x12\x02\0\x12\x04\xc8\
    \x02\x08!\x1a\x13\x20Integration\x20kind.\n\n\x0f\n\x05\x04\x12\x02\0\
    \x04\x12\x06\xc8\x02\x08\xc6\x02\x1d\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\
    \xc8\x02\x08\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc8\x02\x18\x1c\n\r\
    \n\x05\x04\x12\x02\0\x03\x12\x04\xc8\x02\x1f\x20\n\x0c\n\x02\x04\x13\x12\
    \x06\xcb\x02\0\xd1\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xcb\x02\x08\
    \x1f\nM\n\x04\x04\x13\x02\0\x12\x04\xcd\x02\x08\x1e\x1a?\x20Total\x20num\
    ber\x20of\x20integrations\x20available\x20within\x20the\x20result-set.\n\
    \n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xcd\x02\x08\xcb\x02!\n\r\n\x05\
    \x04\x13\x02\0\x05\x12\x04\xcd\x02\x08\r\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\xcd\x02\x0e\x19\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xcd\x02\x1c\x1d\
    \n/\n\x04\x04\x13\x02\x01\x12\x04\xd0\x02\x080\x1a!\x20Integrations\x20w\
    ithin\x20result-set.\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xd0\x02\x08\
    \x10\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xd0\x02\x11$\n\r\n\x05\x04\
    \x13\x02\x01\x01\x12\x04\xd0\x02%+\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\
    \xd0\x02./\n\x0c\n\x02\x05\x01\x12\x06\xd3\x02\0\xda\x02\x01\n\x0b\n\x03\
    \x05\x01\x01\x12\x04\xd3\x02\x05\x16\n\x0c\n\x04\x05\x01\x02\0\x12\x04\
    \xd4\x02\x08\x0f\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xd4\x02\x08\n\n\r\n\
    \x05\x05\x01\x02\0\x02\x12\x04\xd4\x02\r\x0e\n\x0c\n\x04\x05\x01\x02\x01\
    \x12\x04\xd5\x02\x08\x0e\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xd5\x02\
    \x08\t\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xd5\x02\x0c\r\n\x0c\n\x04\
    \x05\x01\x02\x02\x12\x04\xd6\x02\x08\x0f\n\r\n\x05\x05\x01\x02\x02\x01\
    \x12\x04\xd6\x02\x08\n\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xd6\x02\r\
    \x0e\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\xd7\x02\x08\x0e\n\r\n\x05\x05\
    \x01\x02\x03\x01\x12\x04\xd7\x02\x08\t\n\r\n\x05\x05\x01\x02\x03\x02\x12\
    \x04\xd7\x02\x0c\r\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xd8\x02\x08\x0e\n\
    \r\n\x05\x05\x01\x02\x04\x01\x12\x04\xd8\x02\x08\t\n\r\n\x05\x05\x01\x02\
    \x04\x02\x12\x04\xd8\x02\x0c\r\n\x0c\n\x04\x05\x01\x02\x05\x12\x04\xd9\
    \x02\x08\x0e\n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xd9\x02\x08\t\n\r\n\
    \x05\x05\x01\x02\x05\x02\x12\x04\xd9\x02\x0c\r\n\x0c\n\x02\x04\x14\x12\
    \x06\xdc\x02\0\xf1\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xdc\x02\x08\
    \x1b\n\x1f\n\x04\x04\x14\x02\0\x12\x04\xde\x02\x08?\x1a\x11\x20Applicati\
    on\x20ID.\n\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xde\x02\x08\xdc\x02\
    \x1d\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xde\x02\x08\r\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xde\x02\x0e\x1c\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xde\x02\x1f\x20\n\r\n\x05\x04\x14\x02\0\x08\x12\x04\xde\x02!>\n\r\n\x05\
    \x04\x14\x02\0\n\x12\x04\xde\x02.=\nO\n\x04\x04\x14\x02\x01\x12\x04\xe1\
    \x02\x08\x1c\x1aA\x20InfluxDB\x20API\x20write\x20endpoint\x20(e.g.\x20ht\
    tp://localhost:8086/write).\n\n\x0f\n\x05\x04\x14\x02\x01\x04\x12\x06\
    \xe1\x02\x08\xde\x02?\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xe1\x02\x08\
    \x0e\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xe1\x02\x0f\x17\n\r\n\x05\x04\
    \x14\x02\x01\x03\x12\x04\xe1\x02\x1a\x1b\n'\n\x04\x04\x14\x02\x02\x12\
    \x04\xe4\x02\x08\x16\x1a\x19\x20InfluxDB\x20database\x20name.\n\n\x0f\n\
    \x05\x04\x14\x02\x02\x04\x12\x06\xe4\x02\x08\xe1\x02\x1c\n\r\n\x05\x04\
    \x14\x02\x02\x05\x12\x04\xe4\x02\x08\x0e\n\r\n\x05\x04\x14\x02\x02\x01\
    \x12\x04\xe4\x02\x0f\x11\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xe4\x02\
    \x14\x15\n\"\n\x04\x04\x14\x02\x03\x12\x04\xe7\x02\x08\x1c\x1a\x14\x20In\
    fluxDB\x20username.\n\n\x0f\n\x05\x04\x14\x02\x03\x04\x12\x06\xe7\x02\
    \x08\xe4\x02\x16\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\xe7\x02\x08\x0e\n\
    \r\n\x05\x04\x14\x02\x03\x01\x12\x04\xe7\x02\x0f\x17\n\r\n\x05\x04\x14\
    \x02\x03\x03\x12\x04\xe7\x02\x1a\x1b\n\"\n\x04\x04\x14\x02\x04\x12\x04\
    \xea\x02\x08\x1c\x1a\x14\x20InfluxDB\x20password.\n\n\x0f\n\x05\x04\x14\
    \x02\x04\x04\x12\x06\xea\x02\x08\xe7\x02\x1c\n\r\n\x05\x04\x14\x02\x04\
    \x05\x12\x04\xea\x02\x08\x0e\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xea\
    \x02\x0f\x17\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xea\x02\x1a\x1b\n/\n\
    \x04\x04\x14\x02\x05\x12\x04\xed\x02\x08)\x1a!\x20InfluxDB\x20retention\
    \x20policy\x20name.\n\n\x0f\n\x05\x04\x14\x02\x05\x04\x12\x06\xed\x02\
    \x08\xea\x02\x1c\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xed\x02\x08\x0e\n\
    \r\n\x05\x04\x14\x02\x05\x01\x12\x04\xed\x02\x0f$\n\r\n\x05\x04\x14\x02\
    \x05\x03\x12\x04\xed\x02'(\n-\n\x04\x04\x14\x02\x06\x12\x04\xf0\x02\x08(\
    \x1a\x1f\x20InfluxDB\x20timestamp\x20precision.\n\n\x0f\n\x05\x04\x14\
    \x02\x06\x04\x12\x06\xf0\x02\x08\xed\x02)\n\r\n\x05\x04\x14\x02\x06\x06\
    \x12\x04\xf0\x02\x08\x19\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xf0\x02\
    \x1a#\n\r\n\x05\x04\x14\x02\x06\x03\x12\x04\xf0\x02&'\n\x0c\n\x02\x04\
    \x15\x12\x06\xf3\x02\0\xf6\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xf3\
    \x02\x08(\n-\n\x04\x04\x15\x02\0\x12\x04\xf5\x02\x08,\x1a\x1f\x20Integra\
    tion\x20object\x20to\x20create.\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\
    \xf5\x02\x08\xf3\x02*\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\xf5\x02\x08\
    \x1b\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xf5\x02\x1c'\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\xf5\x02*+\n\x0c\n\x02\x04\x16\x12\x06\xf8\x02\0\xfb\
    \x02\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xf8\x02\x08%\n\x1f\n\x04\x04\
    \x16\x02\0\x12\x04\xfa\x02\x08?\x1a\x11\x20Application\x20ID.\n\n\x0f\n\
    \x05\x04\x16\x02\0\x04\x12\x06\xfa\x02\x08\xf8\x02'\n\r\n\x05\x04\x16\
    \x02\0\x05\x12\x04\xfa\x02\x08\r\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xfa\
    \x02\x0e\x1c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xfa\x02\x1f\x20\n\r\n\
    \x05\x04\x16\x02\0\x08\x12\x04\xfa\x02!>\n\r\n\x05\x04\x16\x02\0\n\x12\
    \x04\xfa\x02.=\n\x0c\n\x02\x04\x17\x12\x06\xfd\x02\0\x80\x03\x01\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\xfd\x02\x08&\n#\n\x04\x04\x17\x02\0\x12\x04\xff\
    \x02\x08,\x1a\x15\x20Integration\x20object.\n\n\x0f\n\x05\x04\x17\x02\0\
    \x04\x12\x06\xff\x02\x08\xfd\x02(\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\
    \xff\x02\x08\x1b\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xff\x02\x1c'\n\r\n\
    \x05\x04\x17\x02\0\x03\x12\x04\xff\x02*+\n\x0c\n\x02\x04\x18\x12\x06\x82\
    \x03\0\x85\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x82\x03\x08(\n#\n\x04\
    \x04\x18\x02\0\x12\x04\x84\x03\x08,\x1a\x15\x20Integration\x20object.\n\
    \n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\x84\x03\x08\x82\x03*\n\r\n\x05\
    \x04\x18\x02\0\x06\x12\x04\x84\x03\x08\x1b\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\x84\x03\x1c'\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x84\x03*+\n\
    \x0c\n\x02\x04\x19\x12\x06\x87\x03\0\x8a\x03\x01\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\x87\x03\x08(\n\x1f\n\x04\x04\x19\x02\0\x12\x04\x89\x03\x08?\x1a\
    \x11\x20Application\x20ID.\n\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\x89\
    \x03\x08\x87\x03*\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x89\x03\x08\r\n\r\
    \n\x05\x04\x19\x02\0\x01\x12\x04\x89\x03\x0e\x1c\n\r\n\x05\x04\x19\x02\0\
    \x03\x12\x04\x89\x03\x1f\x20\n\r\n\x05\x04\x19\x02\0\x08\x12\x04\x89\x03\
    !>\n\r\n\x05\x04\x19\x02\0\n\x12\x04\x89\x03.=\n\x0c\n\x02\x04\x1a\x12\
    \x06\x8c\x03\0\x92\x03\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x8c\x03\x08\
    \x1e\n\x1f\n\x04\x04\x1a\x02\0\x12\x04\x8e\x03\x08?\x1a\x11\x20Applicati\
    on\x20ID.\n\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\x8e\x03\x08\x8c\x03\
    \x20\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x8e\x03\x08\r\n\r\n\x05\x04\x1a\
    \x02\0\x01\x12\x04\x8e\x03\x0e\x1c\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\
    \x8e\x03\x1f\x20\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\x8e\x03!>\n\r\n\x05\
    \x04\x1a\x02\0\n\x12\x04\x8e\x03.=\nE\n\x04\x04\x1a\x02\x01\x12\x04\x91\
    \x03\x04\x16\x1a7\x20ThingsBoard\x20server\x20endpoint,\x20e.g.\x20https\
    ://example.com\n\n\x0f\n\x05\x04\x1a\x02\x01\x04\x12\x06\x91\x03\x04\x8e\
    \x03?\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\x91\x03\x04\n\n\r\n\x05\x04\
    \x1a\x02\x01\x01\x12\x04\x91\x03\x0b\x11\n\r\n\x05\x04\x1a\x02\x01\x03\
    \x12\x04\x91\x03\x14\x15\n\x0c\n\x02\x04\x1b\x12\x06\x94\x03\0\x97\x03\
    \x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\x94\x03\x08+\n-\n\x04\x04\x1b\x02\0\
    \x12\x04\x96\x03\x04+\x1a\x1f\x20Integration\x20object\x20to\x20create.\
    \n\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\x96\x03\x04\x94\x03-\n\r\n\x05\
    \x04\x1b\x02\0\x06\x12\x04\x96\x03\x04\x1a\n\r\n\x05\x04\x1b\x02\0\x01\
    \x12\x04\x96\x03\x1b&\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x96\x03)*\n\
    \x0c\n\x02\x04\x1c\x12\x06\x99\x03\0\x9c\x03\x01\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\x99\x03\x08(\n\x1f\n\x04\x04\x1c\x02\0\x12\x04\x9b\x03\x08?\x1a\
    \x11\x20Application\x20ID.\n\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\x9b\
    \x03\x08\x99\x03*\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x9b\x03\x08\r\n\r\
    \n\x05\x04\x1c\x02\0\x01\x12\x04\x9b\x03\x0e\x1c\n\r\n\x05\x04\x1c\x02\0\
    \x03\x12\x04\x9b\x03\x1f\x20\n\r\n\x05\x04\x1c\x02\0\x08\x12\x04\x9b\x03\
    !>\n\r\n\x05\x04\x1c\x02\0\n\x12\x04\x9b\x03.=\n\x0c\n\x02\x04\x1d\x12\
    \x06\x9e\x03\0\xa1\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x9e\x03\x08)\
    \n#\n\x04\x04\x1d\x02\0\x12\x04\xa0\x03\x04+\x1a\x15\x20Integration\x20o\
    bject.\n\n\x0f\n\x05\x04\x1d\x02\0\x04\x12\x06\xa0\x03\x04\x9e\x03+\n\r\
    \n\x05\x04\x1d\x02\0\x06\x12\x04\xa0\x03\x04\x1a\n\r\n\x05\x04\x1d\x02\0\
    \x01\x12\x04\xa0\x03\x1b&\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xa0\x03)*\
    \n\x0c\n\x02\x04\x1e\x12\x06\xa3\x03\0\xa6\x03\x01\n\x0b\n\x03\x04\x1e\
    \x01\x12\x04\xa3\x03\x08+\n#\n\x04\x04\x1e\x02\0\x12\x04\xa5\x03\x04+\
    \x1a\x15\x20Integration\x20object.\n\n\x0f\n\x05\x04\x1e\x02\0\x04\x12\
    \x06\xa5\x03\x04\xa3\x03-\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xa5\x03\
    \x04\x1a\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xa5\x03\x1b&\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xa5\x03)*\n\x0c\n\x02\x04\x1f\x12\x06\xa8\x03\0\
    \xab\x03\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xa8\x03\x08+\n\x1f\n\x04\
    \x04\x1f\x02\0\x12\x04\xaa\x03\x08?\x1a\x11\x20Application\x20ID.\n\n\
    \x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xaa\x03\x08\xa8\x03-\n\r\n\x05\x04\
    \x1f\x02\0\x05\x12\x04\xaa\x03\x08\r\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\
    \xaa\x03\x0e\x1c\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xaa\x03\x1f\x20\n\r\
    \n\x05\x04\x1f\x02\0\x08\x12\x04\xaa\x03!>\n\r\n\x05\x04\x1f\x02\0\n\x12\
    \x04\xaa\x03.=b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
