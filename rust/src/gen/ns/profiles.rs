// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ns/profiles.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct ServiceProfile {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub ul_rate: u32,
    pub ul_bucket_size: u32,
    pub ul_rate_policy: RatePolicy,
    pub dl_rate: u32,
    pub dl_bucket_size: u32,
    pub dl_rate_policy: RatePolicy,
    pub add_gw_metadata: bool,
    pub dev_status_req_freq: u32,
    pub report_dev_status_battery: bool,
    pub report_dev_status_margin: bool,
    pub dr_min: u32,
    pub dr_max: u32,
    pub channel_mask: ::std::vec::Vec<u8>,
    pub pr_allowed: bool,
    pub hr_allowed: bool,
    pub ra_allowed: bool,
    pub nwk_geo_loc: bool,
    pub target_per: u32,
    pub min_gw_diversity: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceProfile {
    fn default() -> &'a ServiceProfile {
        <ServiceProfile as ::protobuf::Message>::default_instance()
    }
}

impl ServiceProfile {
    pub fn new() -> ServiceProfile {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // uint32 ul_rate = 2;


    pub fn get_ul_rate(&self) -> u32 {
        self.ul_rate
    }
    pub fn clear_ul_rate(&mut self) {
        self.ul_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_ul_rate(&mut self, v: u32) {
        self.ul_rate = v;
    }

    // uint32 ul_bucket_size = 3;


    pub fn get_ul_bucket_size(&self) -> u32 {
        self.ul_bucket_size
    }
    pub fn clear_ul_bucket_size(&mut self) {
        self.ul_bucket_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_ul_bucket_size(&mut self, v: u32) {
        self.ul_bucket_size = v;
    }

    // .ns.RatePolicy ul_rate_policy = 4;


    pub fn get_ul_rate_policy(&self) -> RatePolicy {
        self.ul_rate_policy
    }
    pub fn clear_ul_rate_policy(&mut self) {
        self.ul_rate_policy = RatePolicy::DROP;
    }

    // Param is passed by value, moved
    pub fn set_ul_rate_policy(&mut self, v: RatePolicy) {
        self.ul_rate_policy = v;
    }

    // uint32 dl_rate = 5;


    pub fn get_dl_rate(&self) -> u32 {
        self.dl_rate
    }
    pub fn clear_dl_rate(&mut self) {
        self.dl_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_dl_rate(&mut self, v: u32) {
        self.dl_rate = v;
    }

    // uint32 dl_bucket_size = 6;


    pub fn get_dl_bucket_size(&self) -> u32 {
        self.dl_bucket_size
    }
    pub fn clear_dl_bucket_size(&mut self) {
        self.dl_bucket_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_dl_bucket_size(&mut self, v: u32) {
        self.dl_bucket_size = v;
    }

    // .ns.RatePolicy dl_rate_policy = 7;


    pub fn get_dl_rate_policy(&self) -> RatePolicy {
        self.dl_rate_policy
    }
    pub fn clear_dl_rate_policy(&mut self) {
        self.dl_rate_policy = RatePolicy::DROP;
    }

    // Param is passed by value, moved
    pub fn set_dl_rate_policy(&mut self, v: RatePolicy) {
        self.dl_rate_policy = v;
    }

    // bool add_gw_metadata = 8;


    pub fn get_add_gw_metadata(&self) -> bool {
        self.add_gw_metadata
    }
    pub fn clear_add_gw_metadata(&mut self) {
        self.add_gw_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_add_gw_metadata(&mut self, v: bool) {
        self.add_gw_metadata = v;
    }

    // uint32 dev_status_req_freq = 9;


    pub fn get_dev_status_req_freq(&self) -> u32 {
        self.dev_status_req_freq
    }
    pub fn clear_dev_status_req_freq(&mut self) {
        self.dev_status_req_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_dev_status_req_freq(&mut self, v: u32) {
        self.dev_status_req_freq = v;
    }

    // bool report_dev_status_battery = 10;


    pub fn get_report_dev_status_battery(&self) -> bool {
        self.report_dev_status_battery
    }
    pub fn clear_report_dev_status_battery(&mut self) {
        self.report_dev_status_battery = false;
    }

    // Param is passed by value, moved
    pub fn set_report_dev_status_battery(&mut self, v: bool) {
        self.report_dev_status_battery = v;
    }

    // bool report_dev_status_margin = 11;


    pub fn get_report_dev_status_margin(&self) -> bool {
        self.report_dev_status_margin
    }
    pub fn clear_report_dev_status_margin(&mut self) {
        self.report_dev_status_margin = false;
    }

    // Param is passed by value, moved
    pub fn set_report_dev_status_margin(&mut self, v: bool) {
        self.report_dev_status_margin = v;
    }

    // uint32 dr_min = 12;


    pub fn get_dr_min(&self) -> u32 {
        self.dr_min
    }
    pub fn clear_dr_min(&mut self) {
        self.dr_min = 0;
    }

    // Param is passed by value, moved
    pub fn set_dr_min(&mut self, v: u32) {
        self.dr_min = v;
    }

    // uint32 dr_max = 13;


    pub fn get_dr_max(&self) -> u32 {
        self.dr_max
    }
    pub fn clear_dr_max(&mut self) {
        self.dr_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_dr_max(&mut self, v: u32) {
        self.dr_max = v;
    }

    // bytes channel_mask = 14;


    pub fn get_channel_mask(&self) -> &[u8] {
        &self.channel_mask
    }
    pub fn clear_channel_mask(&mut self) {
        self.channel_mask.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.channel_mask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.channel_mask
    }

    // Take field
    pub fn take_channel_mask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.channel_mask, ::std::vec::Vec::new())
    }

    // bool pr_allowed = 15;


    pub fn get_pr_allowed(&self) -> bool {
        self.pr_allowed
    }
    pub fn clear_pr_allowed(&mut self) {
        self.pr_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_pr_allowed(&mut self, v: bool) {
        self.pr_allowed = v;
    }

    // bool hr_allowed = 16;


    pub fn get_hr_allowed(&self) -> bool {
        self.hr_allowed
    }
    pub fn clear_hr_allowed(&mut self) {
        self.hr_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_hr_allowed(&mut self, v: bool) {
        self.hr_allowed = v;
    }

    // bool ra_allowed = 17;


    pub fn get_ra_allowed(&self) -> bool {
        self.ra_allowed
    }
    pub fn clear_ra_allowed(&mut self) {
        self.ra_allowed = false;
    }

    // Param is passed by value, moved
    pub fn set_ra_allowed(&mut self, v: bool) {
        self.ra_allowed = v;
    }

    // bool nwk_geo_loc = 18;


    pub fn get_nwk_geo_loc(&self) -> bool {
        self.nwk_geo_loc
    }
    pub fn clear_nwk_geo_loc(&mut self) {
        self.nwk_geo_loc = false;
    }

    // Param is passed by value, moved
    pub fn set_nwk_geo_loc(&mut self, v: bool) {
        self.nwk_geo_loc = v;
    }

    // uint32 target_per = 19;


    pub fn get_target_per(&self) -> u32 {
        self.target_per
    }
    pub fn clear_target_per(&mut self) {
        self.target_per = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_per(&mut self, v: u32) {
        self.target_per = v;
    }

    // uint32 min_gw_diversity = 20;


    pub fn get_min_gw_diversity(&self) -> u32 {
        self.min_gw_diversity
    }
    pub fn clear_min_gw_diversity(&mut self) {
        self.min_gw_diversity = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_gw_diversity(&mut self, v: u32) {
        self.min_gw_diversity = v;
    }
}

impl ::protobuf::Message for ServiceProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ul_rate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ul_bucket_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ul_rate_policy, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dl_rate = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dl_bucket_size = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dl_rate_policy, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.add_gw_metadata = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dev_status_req_freq = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_dev_status_battery = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_dev_status_margin = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dr_min = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dr_max = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.channel_mask)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pr_allowed = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hr_allowed = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ra_allowed = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nwk_geo_loc = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_per = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_gw_diversity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if self.ul_rate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ul_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ul_bucket_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ul_bucket_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ul_rate_policy != RatePolicy::DROP {
            my_size += ::protobuf::rt::enum_size(4, self.ul_rate_policy);
        }
        if self.dl_rate != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dl_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dl_bucket_size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.dl_bucket_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dl_rate_policy != RatePolicy::DROP {
            my_size += ::protobuf::rt::enum_size(7, self.dl_rate_policy);
        }
        if self.add_gw_metadata != false {
            my_size += 2;
        }
        if self.dev_status_req_freq != 0 {
            my_size += ::protobuf::rt::value_size(9, self.dev_status_req_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.report_dev_status_battery != false {
            my_size += 2;
        }
        if self.report_dev_status_margin != false {
            my_size += 2;
        }
        if self.dr_min != 0 {
            my_size += ::protobuf::rt::value_size(12, self.dr_min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dr_max != 0 {
            my_size += ::protobuf::rt::value_size(13, self.dr_max, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.channel_mask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.channel_mask);
        }
        if self.pr_allowed != false {
            my_size += 2;
        }
        if self.hr_allowed != false {
            my_size += 3;
        }
        if self.ra_allowed != false {
            my_size += 3;
        }
        if self.nwk_geo_loc != false {
            my_size += 3;
        }
        if self.target_per != 0 {
            my_size += ::protobuf::rt::value_size(19, self.target_per, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_gw_diversity != 0 {
            my_size += ::protobuf::rt::value_size(20, self.min_gw_diversity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if self.ul_rate != 0 {
            os.write_uint32(2, self.ul_rate)?;
        }
        if self.ul_bucket_size != 0 {
            os.write_uint32(3, self.ul_bucket_size)?;
        }
        if self.ul_rate_policy != RatePolicy::DROP {
            os.write_enum(4, self.ul_rate_policy.value())?;
        }
        if self.dl_rate != 0 {
            os.write_uint32(5, self.dl_rate)?;
        }
        if self.dl_bucket_size != 0 {
            os.write_uint32(6, self.dl_bucket_size)?;
        }
        if self.dl_rate_policy != RatePolicy::DROP {
            os.write_enum(7, self.dl_rate_policy.value())?;
        }
        if self.add_gw_metadata != false {
            os.write_bool(8, self.add_gw_metadata)?;
        }
        if self.dev_status_req_freq != 0 {
            os.write_uint32(9, self.dev_status_req_freq)?;
        }
        if self.report_dev_status_battery != false {
            os.write_bool(10, self.report_dev_status_battery)?;
        }
        if self.report_dev_status_margin != false {
            os.write_bool(11, self.report_dev_status_margin)?;
        }
        if self.dr_min != 0 {
            os.write_uint32(12, self.dr_min)?;
        }
        if self.dr_max != 0 {
            os.write_uint32(13, self.dr_max)?;
        }
        if !self.channel_mask.is_empty() {
            os.write_bytes(14, &self.channel_mask)?;
        }
        if self.pr_allowed != false {
            os.write_bool(15, self.pr_allowed)?;
        }
        if self.hr_allowed != false {
            os.write_bool(16, self.hr_allowed)?;
        }
        if self.ra_allowed != false {
            os.write_bool(17, self.ra_allowed)?;
        }
        if self.nwk_geo_loc != false {
            os.write_bool(18, self.nwk_geo_loc)?;
        }
        if self.target_per != 0 {
            os.write_uint32(19, self.target_per)?;
        }
        if self.min_gw_diversity != 0 {
            os.write_uint32(20, self.min_gw_diversity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceProfile {
        ServiceProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &ServiceProfile| { &m.id },
                    |m: &mut ServiceProfile| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ul_rate",
                    |m: &ServiceProfile| { &m.ul_rate },
                    |m: &mut ServiceProfile| { &mut m.ul_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ul_bucket_size",
                    |m: &ServiceProfile| { &m.ul_bucket_size },
                    |m: &mut ServiceProfile| { &mut m.ul_bucket_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RatePolicy>>(
                    "ul_rate_policy",
                    |m: &ServiceProfile| { &m.ul_rate_policy },
                    |m: &mut ServiceProfile| { &mut m.ul_rate_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dl_rate",
                    |m: &ServiceProfile| { &m.dl_rate },
                    |m: &mut ServiceProfile| { &mut m.dl_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dl_bucket_size",
                    |m: &ServiceProfile| { &m.dl_bucket_size },
                    |m: &mut ServiceProfile| { &mut m.dl_bucket_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RatePolicy>>(
                    "dl_rate_policy",
                    |m: &ServiceProfile| { &m.dl_rate_policy },
                    |m: &mut ServiceProfile| { &mut m.dl_rate_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "add_gw_metadata",
                    |m: &ServiceProfile| { &m.add_gw_metadata },
                    |m: &mut ServiceProfile| { &mut m.add_gw_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dev_status_req_freq",
                    |m: &ServiceProfile| { &m.dev_status_req_freq },
                    |m: &mut ServiceProfile| { &mut m.dev_status_req_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_dev_status_battery",
                    |m: &ServiceProfile| { &m.report_dev_status_battery },
                    |m: &mut ServiceProfile| { &mut m.report_dev_status_battery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_dev_status_margin",
                    |m: &ServiceProfile| { &m.report_dev_status_margin },
                    |m: &mut ServiceProfile| { &mut m.report_dev_status_margin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dr_min",
                    |m: &ServiceProfile| { &m.dr_min },
                    |m: &mut ServiceProfile| { &mut m.dr_min },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dr_max",
                    |m: &ServiceProfile| { &m.dr_max },
                    |m: &mut ServiceProfile| { &mut m.dr_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "channel_mask",
                    |m: &ServiceProfile| { &m.channel_mask },
                    |m: &mut ServiceProfile| { &mut m.channel_mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pr_allowed",
                    |m: &ServiceProfile| { &m.pr_allowed },
                    |m: &mut ServiceProfile| { &mut m.pr_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hr_allowed",
                    |m: &ServiceProfile| { &m.hr_allowed },
                    |m: &mut ServiceProfile| { &mut m.hr_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ra_allowed",
                    |m: &ServiceProfile| { &m.ra_allowed },
                    |m: &mut ServiceProfile| { &mut m.ra_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "nwk_geo_loc",
                    |m: &ServiceProfile| { &m.nwk_geo_loc },
                    |m: &mut ServiceProfile| { &mut m.nwk_geo_loc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_per",
                    |m: &ServiceProfile| { &m.target_per },
                    |m: &mut ServiceProfile| { &mut m.target_per },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "min_gw_diversity",
                    |m: &ServiceProfile| { &m.min_gw_diversity },
                    |m: &mut ServiceProfile| { &mut m.min_gw_diversity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceProfile>(
                    "ServiceProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceProfile {
        static mut instance: ::protobuf::lazy::Lazy<ServiceProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceProfile,
        };
        unsafe {
            instance.get(ServiceProfile::new)
        }
    }
}

impl ::protobuf::Clear for ServiceProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.ul_rate = 0;
        self.ul_bucket_size = 0;
        self.ul_rate_policy = RatePolicy::DROP;
        self.dl_rate = 0;
        self.dl_bucket_size = 0;
        self.dl_rate_policy = RatePolicy::DROP;
        self.add_gw_metadata = false;
        self.dev_status_req_freq = 0;
        self.report_dev_status_battery = false;
        self.report_dev_status_margin = false;
        self.dr_min = 0;
        self.dr_max = 0;
        self.channel_mask.clear();
        self.pr_allowed = false;
        self.hr_allowed = false;
        self.ra_allowed = false;
        self.nwk_geo_loc = false;
        self.target_per = 0;
        self.min_gw_diversity = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceProfile {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub supports_class_b: bool,
    pub class_b_timeout: u32,
    pub ping_slot_period: u32,
    pub ping_slot_dr: u32,
    pub ping_slot_freq: u32,
    pub supports_class_c: bool,
    pub class_c_timeout: u32,
    pub mac_version: ::std::string::String,
    pub reg_params_revision: ::std::string::String,
    pub rx_delay_1: u32,
    pub rx_dr_offset_1: u32,
    pub rx_datarate_2: u32,
    pub rx_freq_2: u32,
    pub factory_preset_freqs: ::std::vec::Vec<u32>,
    pub max_eirp: u32,
    pub max_duty_cycle: u32,
    pub supports_join: bool,
    pub rf_region: ::std::string::String,
    pub supports_32bit_f_cnt: bool,
    pub geoloc_buffer_ttl: u32,
    pub geoloc_min_buffer_size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceProfile {
    fn default() -> &'a DeviceProfile {
        <DeviceProfile as ::protobuf::Message>::default_instance()
    }
}

impl DeviceProfile {
    pub fn new() -> DeviceProfile {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // bool supports_class_b = 2;


    pub fn get_supports_class_b(&self) -> bool {
        self.supports_class_b
    }
    pub fn clear_supports_class_b(&mut self) {
        self.supports_class_b = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_class_b(&mut self, v: bool) {
        self.supports_class_b = v;
    }

    // uint32 class_b_timeout = 3;


    pub fn get_class_b_timeout(&self) -> u32 {
        self.class_b_timeout
    }
    pub fn clear_class_b_timeout(&mut self) {
        self.class_b_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_class_b_timeout(&mut self, v: u32) {
        self.class_b_timeout = v;
    }

    // uint32 ping_slot_period = 4;


    pub fn get_ping_slot_period(&self) -> u32 {
        self.ping_slot_period
    }
    pub fn clear_ping_slot_period(&mut self) {
        self.ping_slot_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_period(&mut self, v: u32) {
        self.ping_slot_period = v;
    }

    // uint32 ping_slot_dr = 5;


    pub fn get_ping_slot_dr(&self) -> u32 {
        self.ping_slot_dr
    }
    pub fn clear_ping_slot_dr(&mut self) {
        self.ping_slot_dr = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_dr(&mut self, v: u32) {
        self.ping_slot_dr = v;
    }

    // uint32 ping_slot_freq = 6;


    pub fn get_ping_slot_freq(&self) -> u32 {
        self.ping_slot_freq
    }
    pub fn clear_ping_slot_freq(&mut self) {
        self.ping_slot_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_slot_freq(&mut self, v: u32) {
        self.ping_slot_freq = v;
    }

    // bool supports_class_c = 7;


    pub fn get_supports_class_c(&self) -> bool {
        self.supports_class_c
    }
    pub fn clear_supports_class_c(&mut self) {
        self.supports_class_c = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_class_c(&mut self, v: bool) {
        self.supports_class_c = v;
    }

    // uint32 class_c_timeout = 8;


    pub fn get_class_c_timeout(&self) -> u32 {
        self.class_c_timeout
    }
    pub fn clear_class_c_timeout(&mut self) {
        self.class_c_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_class_c_timeout(&mut self, v: u32) {
        self.class_c_timeout = v;
    }

    // string mac_version = 9;


    pub fn get_mac_version(&self) -> &str {
        &self.mac_version
    }
    pub fn clear_mac_version(&mut self) {
        self.mac_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_version(&mut self, v: ::std::string::String) {
        self.mac_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_version(&mut self) -> &mut ::std::string::String {
        &mut self.mac_version
    }

    // Take field
    pub fn take_mac_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_version, ::std::string::String::new())
    }

    // string reg_params_revision = 10;


    pub fn get_reg_params_revision(&self) -> &str {
        &self.reg_params_revision
    }
    pub fn clear_reg_params_revision(&mut self) {
        self.reg_params_revision.clear();
    }

    // Param is passed by value, moved
    pub fn set_reg_params_revision(&mut self, v: ::std::string::String) {
        self.reg_params_revision = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reg_params_revision(&mut self) -> &mut ::std::string::String {
        &mut self.reg_params_revision
    }

    // Take field
    pub fn take_reg_params_revision(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reg_params_revision, ::std::string::String::new())
    }

    // uint32 rx_delay_1 = 11;


    pub fn get_rx_delay_1(&self) -> u32 {
        self.rx_delay_1
    }
    pub fn clear_rx_delay_1(&mut self) {
        self.rx_delay_1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_delay_1(&mut self, v: u32) {
        self.rx_delay_1 = v;
    }

    // uint32 rx_dr_offset_1 = 12;


    pub fn get_rx_dr_offset_1(&self) -> u32 {
        self.rx_dr_offset_1
    }
    pub fn clear_rx_dr_offset_1(&mut self) {
        self.rx_dr_offset_1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_dr_offset_1(&mut self, v: u32) {
        self.rx_dr_offset_1 = v;
    }

    // uint32 rx_datarate_2 = 13;


    pub fn get_rx_datarate_2(&self) -> u32 {
        self.rx_datarate_2
    }
    pub fn clear_rx_datarate_2(&mut self) {
        self.rx_datarate_2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_datarate_2(&mut self, v: u32) {
        self.rx_datarate_2 = v;
    }

    // uint32 rx_freq_2 = 14;


    pub fn get_rx_freq_2(&self) -> u32 {
        self.rx_freq_2
    }
    pub fn clear_rx_freq_2(&mut self) {
        self.rx_freq_2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_rx_freq_2(&mut self, v: u32) {
        self.rx_freq_2 = v;
    }

    // repeated uint32 factory_preset_freqs = 15;


    pub fn get_factory_preset_freqs(&self) -> &[u32] {
        &self.factory_preset_freqs
    }
    pub fn clear_factory_preset_freqs(&mut self) {
        self.factory_preset_freqs.clear();
    }

    // Param is passed by value, moved
    pub fn set_factory_preset_freqs(&mut self, v: ::std::vec::Vec<u32>) {
        self.factory_preset_freqs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_factory_preset_freqs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.factory_preset_freqs
    }

    // Take field
    pub fn take_factory_preset_freqs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.factory_preset_freqs, ::std::vec::Vec::new())
    }

    // uint32 max_eirp = 16;


    pub fn get_max_eirp(&self) -> u32 {
        self.max_eirp
    }
    pub fn clear_max_eirp(&mut self) {
        self.max_eirp = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_eirp(&mut self, v: u32) {
        self.max_eirp = v;
    }

    // uint32 max_duty_cycle = 17;


    pub fn get_max_duty_cycle(&self) -> u32 {
        self.max_duty_cycle
    }
    pub fn clear_max_duty_cycle(&mut self) {
        self.max_duty_cycle = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_duty_cycle(&mut self, v: u32) {
        self.max_duty_cycle = v;
    }

    // bool supports_join = 18;


    pub fn get_supports_join(&self) -> bool {
        self.supports_join
    }
    pub fn clear_supports_join(&mut self) {
        self.supports_join = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_join(&mut self, v: bool) {
        self.supports_join = v;
    }

    // string rf_region = 19;


    pub fn get_rf_region(&self) -> &str {
        &self.rf_region
    }
    pub fn clear_rf_region(&mut self) {
        self.rf_region.clear();
    }

    // Param is passed by value, moved
    pub fn set_rf_region(&mut self, v: ::std::string::String) {
        self.rf_region = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rf_region(&mut self) -> &mut ::std::string::String {
        &mut self.rf_region
    }

    // Take field
    pub fn take_rf_region(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rf_region, ::std::string::String::new())
    }

    // bool supports_32bit_f_cnt = 20;


    pub fn get_supports_32bit_f_cnt(&self) -> bool {
        self.supports_32bit_f_cnt
    }
    pub fn clear_supports_32bit_f_cnt(&mut self) {
        self.supports_32bit_f_cnt = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_32bit_f_cnt(&mut self, v: bool) {
        self.supports_32bit_f_cnt = v;
    }

    // uint32 geoloc_buffer_ttl = 21;


    pub fn get_geoloc_buffer_ttl(&self) -> u32 {
        self.geoloc_buffer_ttl
    }
    pub fn clear_geoloc_buffer_ttl(&mut self) {
        self.geoloc_buffer_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_geoloc_buffer_ttl(&mut self, v: u32) {
        self.geoloc_buffer_ttl = v;
    }

    // uint32 geoloc_min_buffer_size = 22;


    pub fn get_geoloc_min_buffer_size(&self) -> u32 {
        self.geoloc_min_buffer_size
    }
    pub fn clear_geoloc_min_buffer_size(&mut self) {
        self.geoloc_min_buffer_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_geoloc_min_buffer_size(&mut self, v: u32) {
        self.geoloc_min_buffer_size = v;
    }
}

impl ::protobuf::Message for DeviceProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_class_b = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_b_timeout = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_period = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_dr = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_slot_freq = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_class_c = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_c_timeout = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_version)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reg_params_revision)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_delay_1 = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_dr_offset_1 = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_datarate_2 = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rx_freq_2 = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.factory_preset_freqs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_eirp = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_duty_cycle = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_join = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rf_region)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_32bit_f_cnt = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.geoloc_buffer_ttl = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.geoloc_min_buffer_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if self.supports_class_b != false {
            my_size += 2;
        }
        if self.class_b_timeout != 0 {
            my_size += ::protobuf::rt::value_size(3, self.class_b_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_period != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ping_slot_period, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_dr != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ping_slot_dr, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ping_slot_freq != 0 {
            my_size += ::protobuf::rt::value_size(6, self.ping_slot_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supports_class_c != false {
            my_size += 2;
        }
        if self.class_c_timeout != 0 {
            my_size += ::protobuf::rt::value_size(8, self.class_c_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mac_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.mac_version);
        }
        if !self.reg_params_revision.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.reg_params_revision);
        }
        if self.rx_delay_1 != 0 {
            my_size += ::protobuf::rt::value_size(11, self.rx_delay_1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_dr_offset_1 != 0 {
            my_size += ::protobuf::rt::value_size(12, self.rx_dr_offset_1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_datarate_2 != 0 {
            my_size += ::protobuf::rt::value_size(13, self.rx_datarate_2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rx_freq_2 != 0 {
            my_size += ::protobuf::rt::value_size(14, self.rx_freq_2, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.factory_preset_freqs {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.max_eirp != 0 {
            my_size += ::protobuf::rt::value_size(16, self.max_eirp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_duty_cycle != 0 {
            my_size += ::protobuf::rt::value_size(17, self.max_duty_cycle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supports_join != false {
            my_size += 3;
        }
        if !self.rf_region.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.rf_region);
        }
        if self.supports_32bit_f_cnt != false {
            my_size += 3;
        }
        if self.geoloc_buffer_ttl != 0 {
            my_size += ::protobuf::rt::value_size(21, self.geoloc_buffer_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.geoloc_min_buffer_size != 0 {
            my_size += ::protobuf::rt::value_size(22, self.geoloc_min_buffer_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if self.supports_class_b != false {
            os.write_bool(2, self.supports_class_b)?;
        }
        if self.class_b_timeout != 0 {
            os.write_uint32(3, self.class_b_timeout)?;
        }
        if self.ping_slot_period != 0 {
            os.write_uint32(4, self.ping_slot_period)?;
        }
        if self.ping_slot_dr != 0 {
            os.write_uint32(5, self.ping_slot_dr)?;
        }
        if self.ping_slot_freq != 0 {
            os.write_uint32(6, self.ping_slot_freq)?;
        }
        if self.supports_class_c != false {
            os.write_bool(7, self.supports_class_c)?;
        }
        if self.class_c_timeout != 0 {
            os.write_uint32(8, self.class_c_timeout)?;
        }
        if !self.mac_version.is_empty() {
            os.write_string(9, &self.mac_version)?;
        }
        if !self.reg_params_revision.is_empty() {
            os.write_string(10, &self.reg_params_revision)?;
        }
        if self.rx_delay_1 != 0 {
            os.write_uint32(11, self.rx_delay_1)?;
        }
        if self.rx_dr_offset_1 != 0 {
            os.write_uint32(12, self.rx_dr_offset_1)?;
        }
        if self.rx_datarate_2 != 0 {
            os.write_uint32(13, self.rx_datarate_2)?;
        }
        if self.rx_freq_2 != 0 {
            os.write_uint32(14, self.rx_freq_2)?;
        }
        for v in &self.factory_preset_freqs {
            os.write_uint32(15, *v)?;
        };
        if self.max_eirp != 0 {
            os.write_uint32(16, self.max_eirp)?;
        }
        if self.max_duty_cycle != 0 {
            os.write_uint32(17, self.max_duty_cycle)?;
        }
        if self.supports_join != false {
            os.write_bool(18, self.supports_join)?;
        }
        if !self.rf_region.is_empty() {
            os.write_string(19, &self.rf_region)?;
        }
        if self.supports_32bit_f_cnt != false {
            os.write_bool(20, self.supports_32bit_f_cnt)?;
        }
        if self.geoloc_buffer_ttl != 0 {
            os.write_uint32(21, self.geoloc_buffer_ttl)?;
        }
        if self.geoloc_min_buffer_size != 0 {
            os.write_uint32(22, self.geoloc_min_buffer_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceProfile {
        DeviceProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &DeviceProfile| { &m.id },
                    |m: &mut DeviceProfile| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_class_b",
                    |m: &DeviceProfile| { &m.supports_class_b },
                    |m: &mut DeviceProfile| { &mut m.supports_class_b },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "class_b_timeout",
                    |m: &DeviceProfile| { &m.class_b_timeout },
                    |m: &mut DeviceProfile| { &mut m.class_b_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_period",
                    |m: &DeviceProfile| { &m.ping_slot_period },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_dr",
                    |m: &DeviceProfile| { &m.ping_slot_dr },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_dr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping_slot_freq",
                    |m: &DeviceProfile| { &m.ping_slot_freq },
                    |m: &mut DeviceProfile| { &mut m.ping_slot_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_class_c",
                    |m: &DeviceProfile| { &m.supports_class_c },
                    |m: &mut DeviceProfile| { &mut m.supports_class_c },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "class_c_timeout",
                    |m: &DeviceProfile| { &m.class_c_timeout },
                    |m: &mut DeviceProfile| { &mut m.class_c_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mac_version",
                    |m: &DeviceProfile| { &m.mac_version },
                    |m: &mut DeviceProfile| { &mut m.mac_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reg_params_revision",
                    |m: &DeviceProfile| { &m.reg_params_revision },
                    |m: &mut DeviceProfile| { &mut m.reg_params_revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_delay_1",
                    |m: &DeviceProfile| { &m.rx_delay_1 },
                    |m: &mut DeviceProfile| { &mut m.rx_delay_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_dr_offset_1",
                    |m: &DeviceProfile| { &m.rx_dr_offset_1 },
                    |m: &mut DeviceProfile| { &mut m.rx_dr_offset_1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_datarate_2",
                    |m: &DeviceProfile| { &m.rx_datarate_2 },
                    |m: &mut DeviceProfile| { &mut m.rx_datarate_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rx_freq_2",
                    |m: &DeviceProfile| { &m.rx_freq_2 },
                    |m: &mut DeviceProfile| { &mut m.rx_freq_2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "factory_preset_freqs",
                    |m: &DeviceProfile| { &m.factory_preset_freqs },
                    |m: &mut DeviceProfile| { &mut m.factory_preset_freqs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_eirp",
                    |m: &DeviceProfile| { &m.max_eirp },
                    |m: &mut DeviceProfile| { &mut m.max_eirp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_duty_cycle",
                    |m: &DeviceProfile| { &m.max_duty_cycle },
                    |m: &mut DeviceProfile| { &mut m.max_duty_cycle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_join",
                    |m: &DeviceProfile| { &m.supports_join },
                    |m: &mut DeviceProfile| { &mut m.supports_join },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rf_region",
                    |m: &DeviceProfile| { &m.rf_region },
                    |m: &mut DeviceProfile| { &mut m.rf_region },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supports_32bit_f_cnt",
                    |m: &DeviceProfile| { &m.supports_32bit_f_cnt },
                    |m: &mut DeviceProfile| { &mut m.supports_32bit_f_cnt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "geoloc_buffer_ttl",
                    |m: &DeviceProfile| { &m.geoloc_buffer_ttl },
                    |m: &mut DeviceProfile| { &mut m.geoloc_buffer_ttl },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "geoloc_min_buffer_size",
                    |m: &DeviceProfile| { &m.geoloc_min_buffer_size },
                    |m: &mut DeviceProfile| { &mut m.geoloc_min_buffer_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceProfile>(
                    "DeviceProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceProfile {
        static mut instance: ::protobuf::lazy::Lazy<DeviceProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceProfile,
        };
        unsafe {
            instance.get(DeviceProfile::new)
        }
    }
}

impl ::protobuf::Clear for DeviceProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.supports_class_b = false;
        self.class_b_timeout = 0;
        self.ping_slot_period = 0;
        self.ping_slot_dr = 0;
        self.ping_slot_freq = 0;
        self.supports_class_c = false;
        self.class_c_timeout = 0;
        self.mac_version.clear();
        self.reg_params_revision.clear();
        self.rx_delay_1 = 0;
        self.rx_dr_offset_1 = 0;
        self.rx_datarate_2 = 0;
        self.rx_freq_2 = 0;
        self.factory_preset_freqs.clear();
        self.max_eirp = 0;
        self.max_duty_cycle = 0;
        self.supports_join = false;
        self.rf_region.clear();
        self.supports_32bit_f_cnt = false;
        self.geoloc_buffer_ttl = 0;
        self.geoloc_min_buffer_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingProfile {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub as_id: ::std::string::String,
    pub ca_cert: ::std::string::String,
    pub tls_cert: ::std::string::String,
    pub tls_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingProfile {
    fn default() -> &'a RoutingProfile {
        <RoutingProfile as ::protobuf::Message>::default_instance()
    }
}

impl RoutingProfile {
    pub fn new() -> RoutingProfile {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // string as_id = 2;


    pub fn get_as_id(&self) -> &str {
        &self.as_id
    }
    pub fn clear_as_id(&mut self) {
        self.as_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_as_id(&mut self, v: ::std::string::String) {
        self.as_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_id(&mut self) -> &mut ::std::string::String {
        &mut self.as_id
    }

    // Take field
    pub fn take_as_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.as_id, ::std::string::String::new())
    }

    // string ca_cert = 3;


    pub fn get_ca_cert(&self) -> &str {
        &self.ca_cert
    }
    pub fn clear_ca_cert(&mut self) {
        self.ca_cert.clear();
    }

    // Param is passed by value, moved
    pub fn set_ca_cert(&mut self, v: ::std::string::String) {
        self.ca_cert = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_cert(&mut self) -> &mut ::std::string::String {
        &mut self.ca_cert
    }

    // Take field
    pub fn take_ca_cert(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ca_cert, ::std::string::String::new())
    }

    // string tls_cert = 4;


    pub fn get_tls_cert(&self) -> &str {
        &self.tls_cert
    }
    pub fn clear_tls_cert(&mut self) {
        self.tls_cert.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls_cert(&mut self, v: ::std::string::String) {
        self.tls_cert = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls_cert(&mut self) -> &mut ::std::string::String {
        &mut self.tls_cert
    }

    // Take field
    pub fn take_tls_cert(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tls_cert, ::std::string::String::new())
    }

    // string tls_key = 5;


    pub fn get_tls_key(&self) -> &str {
        &self.tls_key
    }
    pub fn clear_tls_key(&mut self) {
        self.tls_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_tls_key(&mut self, v: ::std::string::String) {
        self.tls_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls_key(&mut self) -> &mut ::std::string::String {
        &mut self.tls_key
    }

    // Take field
    pub fn take_tls_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tls_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoutingProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.as_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ca_cert)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tls_cert)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tls_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.as_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.as_id);
        }
        if !self.ca_cert.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ca_cert);
        }
        if !self.tls_cert.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tls_cert);
        }
        if !self.tls_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tls_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.as_id.is_empty() {
            os.write_string(2, &self.as_id)?;
        }
        if !self.ca_cert.is_empty() {
            os.write_string(3, &self.ca_cert)?;
        }
        if !self.tls_cert.is_empty() {
            os.write_string(4, &self.tls_cert)?;
        }
        if !self.tls_key.is_empty() {
            os.write_string(5, &self.tls_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingProfile {
        RoutingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &RoutingProfile| { &m.id },
                    |m: &mut RoutingProfile| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "as_id",
                    |m: &RoutingProfile| { &m.as_id },
                    |m: &mut RoutingProfile| { &mut m.as_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ca_cert",
                    |m: &RoutingProfile| { &m.ca_cert },
                    |m: &mut RoutingProfile| { &mut m.ca_cert },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tls_cert",
                    |m: &RoutingProfile| { &m.tls_cert },
                    |m: &mut RoutingProfile| { &mut m.tls_cert },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tls_key",
                    |m: &RoutingProfile| { &m.tls_key },
                    |m: &mut RoutingProfile| { &mut m.tls_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingProfile>(
                    "RoutingProfile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingProfile {
        static mut instance: ::protobuf::lazy::Lazy<RoutingProfile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingProfile,
        };
        unsafe {
            instance.get(RoutingProfile::new)
        }
    }
}

impl ::protobuf::Clear for RoutingProfile {
    fn clear(&mut self) {
        self.id.clear();
        self.as_id.clear();
        self.ca_cert.clear();
        self.tls_cert.clear();
        self.tls_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RatePolicy {
    DROP = 0,
    MARK = 1,
}

impl ::protobuf::ProtobufEnum for RatePolicy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RatePolicy> {
        match value {
            0 => ::std::option::Option::Some(RatePolicy::DROP),
            1 => ::std::option::Option::Some(RatePolicy::MARK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RatePolicy] = &[
            RatePolicy::DROP,
            RatePolicy::MARK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RatePolicy", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RatePolicy {
}

impl ::std::default::Default for RatePolicy {
    fn default() -> Self {
        RatePolicy::DROP
    }
}

impl ::protobuf::reflect::ProtobufValue for RatePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11ns/profiles.proto\x12\x02ns\"\xec\x05\n\x0eServiceProfile\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x17\n\x07ul_rate\x18\x02\x20\
    \x01(\rR\x06ulRate\x12$\n\x0eul_bucket_size\x18\x03\x20\x01(\rR\x0culBuc\
    ketSize\x124\n\x0eul_rate_policy\x18\x04\x20\x01(\x0e2\x0e.ns.RatePolicy\
    R\x0culRatePolicy\x12\x17\n\x07dl_rate\x18\x05\x20\x01(\rR\x06dlRate\x12\
    $\n\x0edl_bucket_size\x18\x06\x20\x01(\rR\x0cdlBucketSize\x124\n\x0edl_r\
    ate_policy\x18\x07\x20\x01(\x0e2\x0e.ns.RatePolicyR\x0cdlRatePolicy\x12&\
    \n\x0fadd_gw_metadata\x18\x08\x20\x01(\x08R\raddGwMetadata\x12-\n\x13dev\
    _status_req_freq\x18\t\x20\x01(\rR\x10devStatusReqFreq\x129\n\x19report_\
    dev_status_battery\x18\n\x20\x01(\x08R\x16reportDevStatusBattery\x127\n\
    \x18report_dev_status_margin\x18\x0b\x20\x01(\x08R\x15reportDevStatusMar\
    gin\x12\x15\n\x06dr_min\x18\x0c\x20\x01(\rR\x05drMin\x12\x15\n\x06dr_max\
    \x18\r\x20\x01(\rR\x05drMax\x12!\n\x0cchannel_mask\x18\x0e\x20\x01(\x0cR\
    \x0bchannelMask\x12\x1d\n\npr_allowed\x18\x0f\x20\x01(\x08R\tprAllowed\
    \x12\x1d\n\nhr_allowed\x18\x10\x20\x01(\x08R\thrAllowed\x12\x1d\n\nra_al\
    lowed\x18\x11\x20\x01(\x08R\traAllowed\x12\x1e\n\x0bnwk_geo_loc\x18\x12\
    \x20\x01(\x08R\tnwkGeoLoc\x12\x1d\n\ntarget_per\x18\x13\x20\x01(\rR\ttar\
    getPer\x12(\n\x10min_gw_diversity\x18\x14\x20\x01(\rR\x0eminGwDiversity\
    \"\xd0\x06\n\rDeviceProfile\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\
    \x12(\n\x10supports_class_b\x18\x02\x20\x01(\x08R\x0esupportsClassB\x12&\
    \n\x0fclass_b_timeout\x18\x03\x20\x01(\rR\rclassBTimeout\x12(\n\x10ping_\
    slot_period\x18\x04\x20\x01(\rR\x0epingSlotPeriod\x12\x20\n\x0cping_slot\
    _dr\x18\x05\x20\x01(\rR\npingSlotDr\x12$\n\x0eping_slot_freq\x18\x06\x20\
    \x01(\rR\x0cpingSlotFreq\x12(\n\x10supports_class_c\x18\x07\x20\x01(\x08\
    R\x0esupportsClassC\x12&\n\x0fclass_c_timeout\x18\x08\x20\x01(\rR\rclass\
    CTimeout\x12\x1f\n\x0bmac_version\x18\t\x20\x01(\tR\nmacVersion\x12.\n\
    \x13reg_params_revision\x18\n\x20\x01(\tR\x11regParamsRevision\x12\x1c\n\
    \nrx_delay_1\x18\x0b\x20\x01(\rR\x08rxDelay1\x12#\n\x0erx_dr_offset_1\
    \x18\x0c\x20\x01(\rR\x0brxDrOffset1\x12\"\n\rrx_datarate_2\x18\r\x20\x01\
    (\rR\x0brxDatarate2\x12\x1a\n\trx_freq_2\x18\x0e\x20\x01(\rR\x07rxFreq2\
    \x120\n\x14factory_preset_freqs\x18\x0f\x20\x03(\rR\x12factoryPresetFreq\
    s\x12\x19\n\x08max_eirp\x18\x10\x20\x01(\rR\x07maxEirp\x12$\n\x0emax_dut\
    y_cycle\x18\x11\x20\x01(\rR\x0cmaxDutyCycle\x12#\n\rsupports_join\x18\
    \x12\x20\x01(\x08R\x0csupportsJoin\x12\x1b\n\trf_region\x18\x13\x20\x01(\
    \tR\x08rfRegion\x12/\n\x14supports_32bit_f_cnt\x18\x14\x20\x01(\x08R\x11\
    supports32bitFCnt\x12*\n\x11geoloc_buffer_ttl\x18\x15\x20\x01(\rR\x0fgeo\
    locBufferTtl\x123\n\x16geoloc_min_buffer_size\x18\x16\x20\x01(\rR\x13geo\
    locMinBufferSize\"\x82\x01\n\x0eRoutingProfile\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x0cR\x02id\x12\x13\n\x05as_id\x18\x02\x20\x01(\tR\x04asId\x12\
    \x17\n\x07ca_cert\x18\x03\x20\x01(\tR\x06caCert\x12\x19\n\x08tls_cert\
    \x18\x04\x20\x01(\tR\x07tlsCert\x12\x17\n\x07tls_key\x18\x05\x20\x01(\tR\
    \x06tlsKey*\x20\n\nRatePolicy\x12\x08\n\x04DROP\x10\0\x12\x08\n\x04MARK\
    \x10\x01B&Z$github.com/brocaar/chirpstack-api/nsJ\xbf0\n\x07\x12\x05\0\0\
    \xa6\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\
    \x08\n\n\x08\n\x01\x08\x12\x03\x04\0;\n\t\n\x02\x08\x0b\x12\x03\x04\0;\n\
    \n\n\x02\x05\0\x12\x04\x06\0\x0c\x01\n\n\n\x03\x05\0\x01\x12\x03\x06\x05\
    \x0f\n\x13\n\x04\x05\0\x02\0\x12\x03\x08\x04\r\x1a\x06\x20Drop\n\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03\x08\x04\x08\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x08\x0b\x0c\n\x13\n\x04\x05\0\x02\x01\x12\x03\x0b\x04\r\x1a\x06\x20\
    Mark\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x0b\x04\x08\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\x0b\x0b\x0c\n\n\n\x02\x04\0\x12\x04\x0e\0J\x01\n\
    \n\n\x03\x04\0\x01\x12\x03\x0e\x08\x16\n\"\n\x04\x04\0\x02\0\x12\x03\x10\
    \x04\x11\x1a\x15\x20Service-profile\x20ID.\n\n\r\n\x05\x04\0\x02\0\x04\
    \x12\x04\x10\x04\x0e\x18\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x10\x04\t\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03\x10\n\x0c\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x10\x0f\x10\nD\n\x04\x04\0\x02\x01\x12\x03\x13\x04\x17\x1a7\x20\
    Token\x20bucket\x20filling\x20rate,\x20including\x20ACKs\x20(packet/h).\
    \n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x13\x04\x10\x11\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x13\x04\n\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x13\
    \x0b\x12\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x13\x15\x16\n'\n\x04\x04\
    \0\x02\x02\x12\x03\x16\x04\x1e\x1a\x1a\x20Token\x20bucket\x20burst\x20si\
    ze.\n\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\x16\x04\x13\x17\n\x0c\n\x05\
    \x04\0\x02\x02\x05\x12\x03\x16\x04\n\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03\x16\x0b\x19\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x16\x1c\x1d\n2\n\
    \x04\x04\0\x02\x03\x12\x03\x19\x04\"\x1a%\x20Drop\x20or\x20mark\x20when\
    \x20exceeding\x20ULRate.\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\x19\x04\
    \x16\x1e\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x19\x04\x0e\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03\x19\x0f\x1d\n\x0c\n\x05\x04\0\x02\x03\x03\x12\
    \x03\x19\x20!\nD\n\x04\x04\0\x02\x04\x12\x03\x1c\x04\x17\x1a7\x20Token\
    \x20bucket\x20filling\x20rate,\x20including\x20ACKs\x20(packet/h).\n\n\r\
    \n\x05\x04\0\x02\x04\x04\x12\x04\x1c\x04\x19\"\n\x0c\n\x05\x04\0\x02\x04\
    \x05\x12\x03\x1c\x04\n\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1c\x0b\x12\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x1c\x15\x16\n'\n\x04\x04\0\x02\
    \x05\x12\x03\x1f\x04\x1e\x1a\x1a\x20Token\x20bucket\x20burst\x20size.\n\
    \n\r\n\x05\x04\0\x02\x05\x04\x12\x04\x1f\x04\x1c\x17\n\x0c\n\x05\x04\0\
    \x02\x05\x05\x12\x03\x1f\x04\n\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x1f\
    \x0b\x19\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x1f\x1c\x1d\n2\n\x04\x04\
    \0\x02\x06\x12\x03\"\x04\"\x1a%\x20Drop\x20or\x20mark\x20when\x20exceedi\
    ng\x20DLRate.\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x04\"\x04\x1f\x1e\n\x0c\
    \n\x05\x04\0\x02\x06\x06\x12\x03\"\x04\x0e\n\x0c\n\x05\x04\0\x02\x06\x01\
    \x12\x03\"\x0f\x1d\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\"\x20!\n\\\n\
    \x04\x04\0\x02\x07\x12\x03%\x04\x1d\x1aO\x20GW\x20metadata\x20(RSSI,\x20\
    SNR,\x20GW\x20geoloc.,\x20etc.)\x20are\x20added\x20to\x20the\x20packet\
    \x20sent\x20to\x20AS.\n\n\r\n\x05\x04\0\x02\x07\x04\x12\x04%\x04\"\"\n\
    \x0c\n\x05\x04\0\x02\x07\x05\x12\x03%\x04\x08\n\x0c\n\x05\x04\0\x02\x07\
    \x01\x12\x03%\t\x18\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03%\x1b\x1c\nP\n\
    \x04\x04\0\x02\x08\x12\x03(\x04#\x1aC\x20Frequency\x20to\x20initiate\x20\
    an\x20End-Device\x20status\x20request\x20(request/day).\n\n\r\n\x05\x04\
    \0\x02\x08\x04\x12\x04(\x04%\x1d\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03(\
    \x04\n\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03(\x0b\x1e\n\x0c\n\x05\x04\0\
    \x02\x08\x03\x12\x03(!\"\n5\n\x04\x04\0\x02\t\x12\x03+\x04(\x1a(\x20Repo\
    rt\x20End-Device\x20battery\x20level\x20to\x20AS.\n\n\r\n\x05\x04\0\x02\
    \t\x04\x12\x04+\x04(#\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03+\x04\x08\n\x0c\
    \n\x05\x04\0\x02\t\x01\x12\x03+\t\"\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03+\
    %'\n.\n\x04\x04\0\x02\n\x12\x03.\x04'\x1a!\x20Report\x20End-Device\x20ma\
    rgin\x20to\x20AS.\n\n\r\n\x05\x04\0\x02\n\x04\x12\x04.\x04+(\n\x0c\n\x05\
    \x04\0\x02\n\x05\x12\x03.\x04\x08\n\x0c\n\x05\x04\0\x02\n\x01\x12\x03.\t\
    !\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03.$&\n7\n\x04\x04\0\x02\x0b\x12\x031\
    \x04\x17\x1a*\x20Minimum\x20allowed\x20data\x20rate.\x20Used\x20for\x20A\
    DR.\n\n\r\n\x05\x04\0\x02\x0b\x04\x12\x041\x04.'\n\x0c\n\x05\x04\0\x02\
    \x0b\x05\x12\x031\x04\n\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x031\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x0b\x03\x12\x031\x14\x16\n7\n\x04\x04\0\x02\x0c\x12\
    \x034\x04\x17\x1a*\x20Maximum\x20allowed\x20data\x20rate.\x20Used\x20for\
    \x20ADR.\n\n\r\n\x05\x04\0\x02\x0c\x04\x12\x044\x041\x17\n\x0c\n\x05\x04\
    \0\x02\x0c\x05\x12\x034\x04\n\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x034\x0b\
    \x11\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x034\x14\x16\nK\n\x04\x04\0\x02\r\
    \x12\x037\x04\x1c\x1a>\x20Channel\x20mask.\x20sNS\x20does\x20not\x20have\
    \x20to\x20obey\x20(i.e.,\x20informative).\n\n\r\n\x05\x04\0\x02\r\x04\
    \x12\x047\x044\x17\n\x0c\n\x05\x04\0\x02\r\x05\x12\x037\x04\t\n\x0c\n\
    \x05\x04\0\x02\r\x01\x12\x037\n\x16\n\x0c\n\x05\x04\0\x02\r\x03\x12\x037\
    \x19\x1b\n'\n\x04\x04\0\x02\x0e\x12\x03:\x04\x19\x1a\x1a\x20Passive\x20R\
    oaming\x20allowed.\n\n\r\n\x05\x04\0\x02\x0e\x04\x12\x04:\x047\x1c\n\x0c\
    \n\x05\x04\0\x02\x0e\x05\x12\x03:\x04\x08\n\x0c\n\x05\x04\0\x02\x0e\x01\
    \x12\x03:\t\x13\n\x0c\n\x05\x04\0\x02\x0e\x03\x12\x03:\x16\x18\n(\n\x04\
    \x04\0\x02\x0f\x12\x03=\x04\x19\x1a\x1b\x20Handover\x20Roaming\x20allowe\
    d.\n\n\r\n\x05\x04\0\x02\x0f\x04\x12\x04=\x04:\x19\n\x0c\n\x05\x04\0\x02\
    \x0f\x05\x12\x03=\x04\x08\n\x0c\n\x05\x04\0\x02\x0f\x01\x12\x03=\t\x13\n\
    \x0c\n\x05\x04\0\x02\x0f\x03\x12\x03=\x16\x18\n*\n\x04\x04\0\x02\x10\x12\
    \x03@\x04\x19\x1a\x1d\x20Roaming\x20Activation\x20allowed.\n\n\r\n\x05\
    \x04\0\x02\x10\x04\x12\x04@\x04=\x19\n\x0c\n\x05\x04\0\x02\x10\x05\x12\
    \x03@\x04\x08\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03@\t\x13\n\x0c\n\x05\
    \x04\0\x02\x10\x03\x12\x03@\x16\x18\n2\n\x04\x04\0\x02\x11\x12\x03C\x04\
    \x1a\x1a%\x20Enable\x20network\x20geolocation\x20service.\n\n\r\n\x05\
    \x04\0\x02\x11\x04\x12\x04C\x04@\x19\n\x0c\n\x05\x04\0\x02\x11\x05\x12\
    \x03C\x04\x08\n\x0c\n\x05\x04\0\x02\x11\x01\x12\x03C\t\x14\n\x0c\n\x05\
    \x04\0\x02\x11\x03\x12\x03C\x17\x19\n(\n\x04\x04\0\x02\x12\x12\x03F\x04\
    \x1b\x1a\x1b\x20Target\x20Packet\x20Error\x20Rate.\n\n\r\n\x05\x04\0\x02\
    \x12\x04\x12\x04F\x04C\x1a\n\x0c\n\x05\x04\0\x02\x12\x05\x12\x03F\x04\n\
    \n\x0c\n\x05\x04\0\x02\x12\x01\x12\x03F\x0b\x15\n\x0c\n\x05\x04\0\x02\
    \x12\x03\x12\x03F\x18\x1a\n=\n\x04\x04\0\x02\x13\x12\x03I\x04!\x1a0\x20M\
    inimum\x20number\x20of\x20receiving\x20GWs\x20(informative).\n\n\r\n\x05\
    \x04\0\x02\x13\x04\x12\x04I\x04F\x1b\n\x0c\n\x05\x04\0\x02\x13\x05\x12\
    \x03I\x04\n\n\x0c\n\x05\x04\0\x02\x13\x01\x12\x03I\x0b\x1b\n\x0c\n\x05\
    \x04\0\x02\x13\x03\x12\x03I\x1e\x20\n\x0b\n\x02\x04\x01\x12\x05L\0\x92\
    \x01\x01\n\n\n\x03\x04\x01\x01\x12\x03L\x08\x15\n!\n\x04\x04\x01\x02\0\
    \x12\x03N\x04\x11\x1a\x14\x20Device-profile\x20ID.\n\n\r\n\x05\x04\x01\
    \x02\0\x04\x12\x04N\x04L\x17\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03N\x04\
    \t\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03N\n\x0c\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x03N\x0f\x10\n+\n\x04\x04\x01\x02\x01\x12\x03Q\x04\x1e\x1a\
    \x1e\x20End-Device\x20supports\x20Class\x20B.\n\n\r\n\x05\x04\x01\x02\
    \x01\x04\x12\x04Q\x04N\x11\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03Q\x04\
    \x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03Q\t\x19\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03Q\x1c\x1d\n\x86\x01\n\x04\x04\x01\x02\x02\x12\x03T\
    \x04\x1f\x1ay\x20Maximum\x20delay\x20for\x20the\x20End-Device\x20to\x20a\
    nswer\x20a\x20MAC\x20request\x20or\x20a\x20confirmed\x20DL\x20frame\x20(\
    mandatory\x20if\x20class\x20B\x20mode\x20supported).\n\n\r\n\x05\x04\x01\
    \x02\x02\x04\x12\x04T\x04Q\x1e\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03T\
    \x04\n\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03T\x0b\x1a\n\x0c\n\x05\x04\
    \x01\x02\x02\x03\x12\x03T\x1d\x1e\n3\n\x04\x04\x01\x02\x03\x12\x03W\x04\
    \x20\x1a&\x20Mandatory\x20if\x20class\x20B\x20mode\x20supported.\n\n\r\n\
    \x05\x04\x01\x02\x03\x04\x12\x04W\x04T\x1f\n\x0c\n\x05\x04\x01\x02\x03\
    \x05\x12\x03W\x04\n\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03W\x0b\x1b\n\
    \x0c\n\x05\x04\x01\x02\x03\x03\x12\x03W\x1e\x1f\n3\n\x04\x04\x01\x02\x04\
    \x12\x03Z\x04\x1c\x1a&\x20Mandatory\x20if\x20class\x20B\x20mode\x20suppo\
    rted.\n\n\r\n\x05\x04\x01\x02\x04\x04\x12\x04Z\x04W\x20\n\x0c\n\x05\x04\
    \x01\x02\x04\x05\x12\x03Z\x04\n\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03Z\
    \x0b\x17\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03Z\x1a\x1b\n3\n\x04\x04\
    \x01\x02\x05\x12\x03]\x04\x1e\x1a&\x20Mandatory\x20if\x20class\x20B\x20m\
    ode\x20supported.\n\n\r\n\x05\x04\x01\x02\x05\x04\x12\x04]\x04Z\x1c\n\
    \x0c\n\x05\x04\x01\x02\x05\x05\x12\x03]\x04\n\n\x0c\n\x05\x04\x01\x02\
    \x05\x01\x12\x03]\x0b\x19\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03]\x1c\
    \x1d\n+\n\x04\x04\x01\x02\x06\x12\x03`\x04\x1e\x1a\x1e\x20End-Device\x20\
    supports\x20Class\x20C.\n\n\r\n\x05\x04\x01\x02\x06\x04\x12\x04`\x04]\
    \x1e\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03`\x04\x08\n\x0c\n\x05\x04\
    \x01\x02\x06\x01\x12\x03`\t\x19\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03`\
    \x1c\x1d\n\x86\x01\n\x04\x04\x01\x02\x07\x12\x03c\x04\x1f\x1ay\x20Maximu\
    m\x20delay\x20for\x20the\x20End-Device\x20to\x20answer\x20a\x20MAC\x20re\
    quest\x20or\x20a\x20confirmed\x20DL\x20frame\x20(mandatory\x20if\x20clas\
    s\x20C\x20mode\x20supported).\n\n\r\n\x05\x04\x01\x02\x07\x04\x12\x04c\
    \x04`\x1e\n\x0c\n\x05\x04\x01\x02\x07\x05\x12\x03c\x04\n\n\x0c\n\x05\x04\
    \x01\x02\x07\x01\x12\x03c\x0b\x1a\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\
    \x03c\x1d\x1e\nB\n\x04\x04\x01\x02\x08\x12\x03f\x04\x1b\x1a5\x20Version\
    \x20of\x20the\x20LoRaWAN\x20supported\x20by\x20the\x20End-Device.\n\n\r\
    \n\x05\x04\x01\x02\x08\x04\x12\x04f\x04c\x1f\n\x0c\n\x05\x04\x01\x02\x08\
    \x05\x12\x03f\x04\n\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03f\x0b\x16\n\
    \x0c\n\x05\x04\x01\x02\x08\x03\x12\x03f\x19\x1a\nX\n\x04\x04\x01\x02\t\
    \x12\x03i\x04$\x1aK\x20Revision\x20of\x20the\x20Regional\x20Parameters\
    \x20document\x20supported\x20by\x20the\x20End-Device.\n\n\r\n\x05\x04\
    \x01\x02\t\x04\x12\x04i\x04f\x1b\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03i\
    \x04\n\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03i\x0b\x1e\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03i!#\n5\n\x04\x04\x01\x02\n\x12\x03l\x04\x1b\x1a(\
    \x20Class\x20A\x20RX1\x20delay\x20(mandatory\x20for\x20ABP).\n\n\r\n\x05\
    \x04\x01\x02\n\x04\x12\x04l\x04i$\n\x0c\n\x05\x04\x01\x02\n\x05\x12\x03l\
    \x04\n\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03l\x0b\x15\n\x0c\n\x05\x04\
    \x01\x02\n\x03\x12\x03l\x18\x1a\n8\n\x04\x04\x01\x02\x0b\x12\x03o\x04\
    \x1f\x1a+\x20RX1\x20data\x20rate\x20offset\x20(mandatory\x20for\x20ABP).\
    \n\n\r\n\x05\x04\x01\x02\x0b\x04\x12\x04o\x04l\x1b\n\x0c\n\x05\x04\x01\
    \x02\x0b\x05\x12\x03o\x04\n\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03o\x0b\
    \x19\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03o\x1c\x1e\n1\n\x04\x04\x01\
    \x02\x0c\x12\x03r\x04\x1e\x1a$\x20RX2\x20data\x20rate\x20(mandatory\x20f\
    or\x20ABP).\n\n\r\n\x05\x04\x01\x02\x0c\x04\x12\x04r\x04o\x1f\n\x0c\n\
    \x05\x04\x01\x02\x0c\x05\x12\x03r\x04\n\n\x0c\n\x05\x04\x01\x02\x0c\x01\
    \x12\x03r\x0b\x18\n\x0c\n\x05\x04\x01\x02\x0c\x03\x12\x03r\x1b\x1d\n9\n\
    \x04\x04\x01\x02\r\x12\x03u\x04\x1a\x1a,\x20RX2\x20channel\x20frequency\
    \x20(mandatory\x20for\x20ABP).\n\n\r\n\x05\x04\x01\x02\r\x04\x12\x04u\
    \x04r\x1e\n\x0c\n\x05\x04\x01\x02\r\x05\x12\x03u\x04\n\n\x0c\n\x05\x04\
    \x01\x02\r\x01\x12\x03u\x0b\x14\n\x0c\n\x05\x04\x01\x02\r\x03\x12\x03u\
    \x17\x19\nF\n\x04\x04\x01\x02\x0e\x12\x03x\x04.\x1a9\x20List\x20of\x20fa\
    ctory-preset\x20frequencies\x20(mandatory\x20for\x20ABP).\n\n\x0c\n\x05\
    \x04\x01\x02\x0e\x04\x12\x03x\x04\x0c\n\x0c\n\x05\x04\x01\x02\x0e\x05\
    \x12\x03x\r\x13\n\x0c\n\x05\x04\x01\x02\x0e\x01\x12\x03x\x14(\n\x0c\n\
    \x05\x04\x01\x02\x0e\x03\x12\x03x+-\n8\n\x04\x04\x01\x02\x0f\x12\x03{\
    \x04\x19\x1a+\x20Maximum\x20EIRP\x20supported\x20by\x20the\x20End-Device\
    .\n\n\r\n\x05\x04\x01\x02\x0f\x04\x12\x04{\x04x.\n\x0c\n\x05\x04\x01\x02\
    \x0f\x05\x12\x03{\x04\n\n\x0c\n\x05\x04\x01\x02\x0f\x01\x12\x03{\x0b\x13\
    \n\x0c\n\x05\x04\x01\x02\x0f\x03\x12\x03{\x16\x18\n>\n\x04\x04\x01\x02\
    \x10\x12\x03~\x04\x1f\x1a1\x20Maximum\x20duty\x20cycle\x20supported\x20b\
    y\x20the\x20End-Device.\n\n\r\n\x05\x04\x01\x02\x10\x04\x12\x04~\x04{\
    \x19\n\x0c\n\x05\x04\x01\x02\x10\x05\x12\x03~\x04\n\n\x0c\n\x05\x04\x01\
    \x02\x10\x01\x12\x03~\x0b\x19\n\x0c\n\x05\x04\x01\x02\x10\x03\x12\x03~\
    \x1c\x1e\n=\n\x04\x04\x01\x02\x11\x12\x04\x81\x01\x04\x1c\x1a/\x20End-De\
    vice\x20supports\x20Join\x20(OTAA)\x20or\x20not\x20(ABP).\n\n\x0e\n\x05\
    \x04\x01\x02\x11\x04\x12\x05\x81\x01\x04~\x1f\n\r\n\x05\x04\x01\x02\x11\
    \x05\x12\x04\x81\x01\x04\x08\n\r\n\x05\x04\x01\x02\x11\x01\x12\x04\x81\
    \x01\t\x16\n\r\n\x05\x04\x01\x02\x11\x03\x12\x04\x81\x01\x19\x1b\n\x1f\n\
    \x04\x04\x01\x02\x12\x12\x04\x84\x01\x04\x1a\x1a\x11\x20RF\x20region\x20\
    name.\n\n\x0f\n\x05\x04\x01\x02\x12\x04\x12\x06\x84\x01\x04\x81\x01\x1c\
    \n\r\n\x05\x04\x01\x02\x12\x05\x12\x04\x84\x01\x04\n\n\r\n\x05\x04\x01\
    \x02\x12\x01\x12\x04\x84\x01\x0b\x14\n\r\n\x05\x04\x01\x02\x12\x03\x12\
    \x04\x84\x01\x17\x19\nR\n\x04\x04\x01\x02\x13\x12\x04\x87\x01\x04#\x1aD\
    \x20End-Device\x20uses\x2032bit\x20FCnt\x20(mandatory\x20for\x20LoRaWAN\
    \x201.0\x20End-Device).\n\n\x0f\n\x05\x04\x01\x02\x13\x04\x12\x06\x87\
    \x01\x04\x84\x01\x1a\n\r\n\x05\x04\x01\x02\x13\x05\x12\x04\x87\x01\x04\
    \x08\n\r\n\x05\x04\x01\x02\x13\x01\x12\x04\x87\x01\t\x1d\n\r\n\x05\x04\
    \x01\x02\x13\x03\x12\x04\x87\x01\x20\"\n\xb7\x01\n\x04\x04\x01\x02\x14\
    \x12\x04\x8c\x01\x04\"\x1a\xa8\x01\x20Geolocation\x20buffer\x20TTL\x20(i\
    n\x20seconds).\n\x20When\x20>\x200,\x20uplink\x20RX\x20meta-data\x20will\
    \x20be\x20stored\x20in\x20a\x20buffer\x20so\x20that\n\x20the\x20meta-dat\
    a\x20of\x20multiple\x20uplinks\x20can\x20be\x20used\x20for\x20geolocatio\
    n.\n\n\x0f\n\x05\x04\x01\x02\x14\x04\x12\x06\x8c\x01\x04\x87\x01#\n\r\n\
    \x05\x04\x01\x02\x14\x05\x12\x04\x8c\x01\x04\n\n\r\n\x05\x04\x01\x02\x14\
    \x01\x12\x04\x8c\x01\x0b\x1c\n\r\n\x05\x04\x01\x02\x14\x03\x12\x04\x8c\
    \x01\x1f!\n\x8c\x01\n\x04\x04\x01\x02\x15\x12\x04\x91\x01\x04'\x1a~\x20G\
    eolocation\x20minimum\x20buffer\x20size.\n\x20When\x20>\x200,\x20geoloca\
    tion\x20will\x20only\x20be\x20performed\x20when\x20the\x20buffer\x20has\
    \n\x20at\x20least\x20the\x20given\x20size.\n\n\x0f\n\x05\x04\x01\x02\x15\
    \x04\x12\x06\x91\x01\x04\x8c\x01\"\n\r\n\x05\x04\x01\x02\x15\x05\x12\x04\
    \x91\x01\x04\n\n\r\n\x05\x04\x01\x02\x15\x01\x12\x04\x91\x01\x0b!\n\r\n\
    \x05\x04\x01\x02\x15\x03\x12\x04\x91\x01$&\n\x0c\n\x02\x04\x02\x12\x06\
    \x94\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x94\x01\x08\x16\n\
    *\n\x04\x04\x02\x02\0\x12\x04\x96\x01\x04\x11\x1a\x1c\x20ID\x20of\x20the\
    \x20routing\x20profile.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\x96\x01\
    \x04\x94\x01\x18\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x96\x01\x04\t\n\r\n\
    \x05\x04\x02\x02\0\x01\x12\x04\x96\x01\n\x0c\n\r\n\x05\x04\x02\x02\0\x03\
    \x12\x04\x96\x01\x0f\x10\n&\n\x04\x04\x02\x02\x01\x12\x04\x99\x01\x04\
    \x15\x1a\x18\x20Application-server\x20ID.\n\n\x0f\n\x05\x04\x02\x02\x01\
    \x04\x12\x06\x99\x01\x04\x96\x01\x11\n\r\n\x05\x04\x02\x02\x01\x05\x12\
    \x04\x99\x01\x04\n\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\x99\x01\x0b\x10\
    \n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x99\x01\x13\x14\n8\n\x04\x04\x02\
    \x02\x02\x12\x04\x9c\x01\x04\x17\x1a*\x20CA\x20certificate\x20for\x20con\
    necting\x20to\x20the\x20AS.\n\n\x0f\n\x05\x04\x02\x02\x02\x04\x12\x06\
    \x9c\x01\x04\x99\x01\x15\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\x9c\x01\
    \x04\n\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x9c\x01\x0b\x12\n\r\n\x05\
    \x04\x02\x02\x02\x03\x12\x04\x9c\x01\x15\x16\n9\n\x04\x04\x02\x02\x03\
    \x12\x04\x9f\x01\x04\x18\x1a+\x20TLS\x20certificate\x20for\x20connecting\
    \x20to\x20the\x20AS.\n\n\x0f\n\x05\x04\x02\x02\x03\x04\x12\x06\x9f\x01\
    \x04\x9c\x01\x17\n\r\n\x05\x04\x02\x02\x03\x05\x12\x04\x9f\x01\x04\n\n\r\
    \n\x05\x04\x02\x02\x03\x01\x12\x04\x9f\x01\x0b\x13\n\r\n\x05\x04\x02\x02\
    \x03\x03\x12\x04\x9f\x01\x16\x17\n\x8e\x02\n\x04\x04\x02\x02\x04\x12\x04\
    \xa5\x01\x04\x17\x1a\xff\x01\x20TLS\x20key\x20for\x20connecting\x20to\
    \x20the\x20AS.\n\x20Note:\x20when\x20retrieving\x20the\x20routing-profil\
    e,\x20the\x20tls_key\x20is\x20not\x20returned\n\x20for\x20security\x20re\
    asons.\x20When\x20updating\x20the\x20routing-profile,\x20an\x20empty\x20\
    tls_key\n\x20does\x20not\x20clear\x20the\x20certificate,\x20unless\x20th\
    e\x20tls_cert\x20is\x20also\x20left\x20blank.\n\n\x0f\n\x05\x04\x02\x02\
    \x04\x04\x12\x06\xa5\x01\x04\x9f\x01\x18\n\r\n\x05\x04\x02\x02\x04\x05\
    \x12\x04\xa5\x01\x04\n\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\xa5\x01\x0b\
    \x12\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xa5\x01\x15\x16b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
